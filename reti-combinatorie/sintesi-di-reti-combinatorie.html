<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="stylesheet" href="../styles/style.css" />
    <link rel="stylesheet" href="../styles/index-style.css" />
    <link rel="stylesheet" href="../styles/content-style.css" />
    <link rel="icon" type="image/x-icon" href="../resources/favicon.ico">
    <link rel="apple-touch-icon" href="../resources/favicon.png" />
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-78NHLXDQD8"></script>
    <script src="../scripts/script.js"></script>
    <style>:root { --bg-clr: #ff7f50; --fg-clr: #262626; }</style>
    <meta name="theme-color" content="#ff7f50" />
    <meta name="keywords" content="reti logiche, reti combinatorie, reti sequenziali" />
    <meta name="description" content="Il seguente sito contiene gli appunti e le definizioni del corso 'Reti logiche'.">
    <meta name="robots" content="index">
    <script defer async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <title>Reti logiche - Reti combinatorie - Sintesi di reti combinatorie</title>
</head>
<body>
    <div class="container">
        <header class="header-wrapper">
            <div class="title-wrapper">
                <span class="title">
                    Reti logiche
                </span>
                <span class="subtitle">
                    by lorenzoarlo
                </span>
            </div>
            <span class="page-title">
                Reti combinatorie
            </span>
        </header>
        <section class="content-wrapper">
            <h1 class="section-title content-width">Sintesi di reti combinatorie</h1>
            <article class="content-container content-width">
                <div class="definition environment" id="def2-1"><h2 class="environment-title">Definizione - Rete combinatoria</h2><div class="environment-body">     Una rete logica si definisce <strong>combinatoria</strong> se le uscite (dette variabili dipendenti) dipendono univocamente dagli ingressi (variabili dipendenti) correnti.      Ciò significa che in presenza di una <strong>stessa configurazione di ingressi</strong> si ha sempre lo <strong>stesso risultato</strong>.     <br/>     Il <strong>comportamento</strong> di una rete combinatoria può essere espresso con una descrizione in linguaggio naturale (che non è tuttavia univocamente interpretabile) o con una tabella della verità mentre la struttura può essere espressa in modo equivalente da un'espressione o da uno schema logico (si sceglie il migliore in base alle esigenze). </div></div><div class="definition environment" id="def2-2"><h2 class="environment-title">Definizione - Composizione e decomposizione di reti combinatorie</h2><div class="environment-body">     Disporre in serie e/o paralello delle reti combinatorie forma ancora una rete combinatoria.     <br/>     Decomporre una singola rete combinatoria con <span class="math-span">\( m\)</span> uscite in <span class="math-span">\( m\)</span> reti combinatorie poste in parallelo con una sola uscita è possibile e può essere utile per studiare questo tipo di reti.  </div></div><div class="definition environment" id="def2-3"><h2 class="environment-title">Definizione - Da espressione a schema logico</h2><div class="environment-body">     Ogni struttura formata da gate connessi in serie e/o parallelo è descritta da una e una sola espressione ed ogni espressione descrive una sola struttura formata da gate connessi in serie e/o in parallelo.      Esiste quindi una relazione 1:1.     <br/>     Per individuare uno schema descritto da un'espressione è necessario partire dalle <strong>espressioni con priorità maggiore</strong> (quindi gli AND e le espressioni tra parentesi) sostituendole con lo schema equivalente e ripetere il procedimento per ogni espressione. </div></div><div class="myexample environment" id="example5"><h2 class="environment-title">Esempio - Da espressione a schema logico</h2><div class="environment-body">     Si vuole creare lo schema logico corrispondente alla seguente espressione     <span class="math-block">\[         a' \cdot b + a \cdot c          \]</span>     innanzitutto dividiamolo in parentesi, ottenendo     <span class="math-block">\[         ((a') \cdot b) + (a \cdot c)      \]</span>     A questo punto, partendo dalle parentesi più interne, aggiungiamo componenti, ovvero     <ul class="list-container"><li class="list-item">iniziamo dall'espressione <span class="math-span">\( (a')\)</span>:         <div class="image-environment"><div class="image-wrapper spaced-25"><img alt="Immagine" src="../resources/espressione-schema-1.png"/></div></div></li><li class="list-item">continuiamo con l'espressione <span class="math-span">\( ((a') \cdot b)\)</span>:         <div class="image-environment"><div class="image-wrapper spaced-40"><img alt="Immagine" src="../resources/espressione-schema-2.png"/></div></div></li><li class="list-item">e aggiungiamo l'espressione <span class="math-span">\( (a \cdot c)\)</span>;         <div class="image-environment"><div class="image-wrapper spaced-40"><img alt="Immagine" src="../resources/espressione-schema-3.png"/></div></div></li><li class="list-item">infine, uniamo i risultati di queste due espressioni con un gate OR, in modo da rappresentare l'espressione <span class="math-span">\( ((a') \cdot b) + (a \cdot c)\)</span><div class="image-environment"><div class="image-wrapper spaced-50"><img alt="Immagine" src="../resources/espressione-schema-4.png"/></div></div></li></ul></div></div><div class="definition environment" id="def2-4"><h2 class="environment-title">Definizione - Analisi - Da espressione a tabella della verità</h2><div class="environment-body">     Per ottenere la tabella della verità da un'espressione di <span class="math-span">\( n\)</span> input è sufficiente sostituire ad ogni variabile il suo valore.     Ripetendo tale processo per <span class="math-span">\( 2^{n}\)</span> volte, ovvero provando ogni possibile combinazione di ingressi, si ottiene la tabella della verità. </div></div><div class="definition environment" id="def2-5"><h2 class="environment-title">Definizione - Sintesi - Da tabella della verità a espressioni</h2><div class="environment-body">     Dato che ogni tabella della verità può essere espressa da diverse espressioni, si pone il problema di quale tra queste utilizzare.     Uno dei metodi più semplici è utilizzare le <strong>espressioni canoniche</strong>. </div></div><div class="definition environment" id="def2-6"><h2 class="environment-title">Definizione - Espressione canonica SP (Somma di Prodotti)</h2><div class="environment-body">     "Ogni funzione di <span class="math-span">\( n\)</span> variabili è descritta (ovvero si può creare) da una <strong>somma di tanti prodotti logici quante sono le configurazioni per cui vale <span class="math-span">\( 1\)</span></strong>. In ciascun prodotto (detto anche <strong>mintermine</strong>) appare ogni variabile in forma vera se nella configurazione corrente vale <span class="math-span">\( 1\)</span>, in forma negata se vale <span class="math-span">\( 0\)</span>".     <div class="mynote environment"><h3 class="environment-title">Osservazioni personali - Why works?</h3><div class="environment-body">         Tale algoritmo è valido in quanto è possibile considerare il valore <span class="math-span">\( 1\)</span> come neutro per il gate AND e il valore <span class="math-span">\( 1\)</span> come dominante nel gate OR.          <br/>         Considerando quindi le configurazioni che hanno valore <span class="math-span">\( 1\)</span>, si va a creare per il prodotto corrispondente il valore <span class="math-span">\( 1\)</span> che andrà poi a modificare l'uscita.     </div></div></div></div><div class="myexample environment" id="example6"><h2 class="environment-title">Esempio - Ottenere l'espressione canonica SP da una tabella della verità</h2><div class="environment-body">     Considerando la seguente tabella della verità     <div class="image-environment"><div class="image-wrapper spaced-20"><img alt="Immagine" src="../resources/generated-17.png"/></div></div>     si vuole ottenere l'espressione canonica SP. Consideriamo quindi le configurazioni per cui la funzione (ovvero l'uscita <span class="math-span">\( z\)</span>) vale <span class="math-span">\( 1\)</span>: si hanno quindi due casi.     <br/>     Procediamo quindi con la consapevolezza che avremo la somma di due prodotti logici, ovvero     <span class="math-block">\[         (\ldots) + (\ldots)     \]</span>     Consideriamo quindi queste due configurazioni:     <div class="image-environment"><div class="image-wrapper spaced-20"><img alt="Immagine" src="../resources/generated-18.png"/></div></div>     L'algoritmo prevede che in ciascun prodotto ogni variabile appare nella sua forma "vera" se ha valore <span class="math-span">\( 1\)</span> mentre nella sua forma negata se ha valore <span class="math-span">\( 0\)</span>.     <br/>       Considerando quindi la prima configurazione, avremo che il mintermine corrispondente è il seguente     <span class="math-block">\[         (\bar{x} \cdot y) + (\ldots)     \]</span>     in quanto <span class="math-span">\( x\)</span> ha valore <span class="math-span">\( 0\)</span> e <span class="math-span">\( y\)</span> ha valore <span class="math-span">\( 1\)</span>. Procedendo in maniera analoga, avremo che il secondo mintermine è il seguente:     <span class="math-block">\[         (\bar{x} \cdot y) + (x \cdot \bar{y})     \]</span></div></div><div class="definition environment" id="def2-7"><h2 class="environment-title">Definizione - Espressione canonica PS (Prodotto di somme)</h2><div class="environment-body">     "Ogni funzione di <span class="math-span">\( n\)</span> variabili è descritta (ovvero può essere creare) da un prodotto di tante somme logiche quante sono le configurazioni per cui vale <span class="math-span">\( 0\)</span>. In ciascuna somma (detta anche maxtermine) appare ogni variabile in forma vera se nella configurazione corrente vale <span class="math-span">\( 0\)</span>, in forma negata se vale <span class="math-span">\( 1\)</span>". </div></div><div class="definition environment" id="def2-8"><h2 class="environment-title">Definizione - Notazione simbolica per le espressioni canoniche</h2><div class="environment-body">     Considerando una funzione <span class="math-span">\( S\)</span> dipendente da tre ingressi <span class="math-span">\( a, b, c\)</span>, per indicare la sua realizzazione con la forma canonica SP si utilizza la seguente notazione     <span class="math-block">\[         S(a, b, c) = \sum_{3} m(0, 1, 2, 3)     \]</span>     dove il <span class="math-span">\( 3\)</span> a pedice indica il numero di ingressi e <span class="math-span">\( 0, 1, 2, 3\)</span> sono le configurazioni in binario degli ingressi in cui la funzione vale <span class="math-span">\( 1\)</span> (i <strong>mintermini</strong>).     Tale espresione equivale alla seguente espressione     <span class="math-block">\[         S(a, b, c) = (a' \cdot b' \cdot c) + (a' \cdot b \cdot c') + (a' \cdot b \cdot c) + (a \cdot b' \cdot c')     \]</span><br/>     Analogamente, per indicare la sua realizzazione con la forma canonica <span class="math-span">\( PS\)</span>, si utilizza la seguente notazione     <span class="math-block">\[         S(a, b, c) = \prod_{3} M(4, 5, 6, 7)     \]</span>     dove il <span class="math-span">\( 3\)</span> a pedice indica il numero di ingressi e <span class="math-span">\( 4, 5, 6, 7\)</span> sono le configurazioni in binario degli ingressi in cui la funzione vale <span class="math-span">\( 0\)</span> (i <strong>maxtermini</strong>). </div></div><div class="definition environment" id="def2-9"><h2 class="environment-title">Definizione - Il problema della sintesi</h2><div class="environment-body">     Quando si progetta una rete combinatoria si possono considerare diversi parametri (anche contrapposti):      <ul class="list-container"><li class="list-item">la <strong>rapidità di progetto</strong>, ovvero quanto tempo si impiega per realizzare il circuito;         </li><li class="list-item">la <strong>massima velocità</strong> della rete, ovvero il tempo che impiega la rete per eseguire le varie operazioni;         </li><li class="list-item">la <strong>massima flessibilità</strong>, ovvero quanto la rete si può adattare ai cambiamenti;         </li><li class="list-item">la <strong>minima complessità</strong>, ovvero quanti e quali gate sono impiegati per realizzare la rete.     </li></ul>     Nel caso di circuiti combinatori, è possibile individuare due tipologie in base ai parametri massimizzati:     <ul class="list-container"><li class="list-item"><strong>reti programmabili</strong>, caratterizzate da rapidità di progetto e massima flessibilità;         </li><li class="list-item"><strong>reti di costo minimo</strong>, caratterizzate da massima velocità e minima complessità.     </li></ul></div></div><div class="definition environment" id="def2-10"><h2 class="environment-title">Definizione - Ritardo complessivo di una rete combinatoria</h2><div class="environment-body">     Dato che l'astrazione della tabella della verità nasconde il ritardo di propagazione del gate reale (che può cambiare da una tecnologia ad un'altra, ma anche se si passa da valore <span class="math-span">\( 0\)</span> a <span class="math-span">\( 1\)</span> o viceversa), risulta quindi utile considerare il ritardo <span class="math-span">\( \tau_{p}\)</span> equivalente al caso peggiore possibile.     <br/>     Seguendo questo ragionamento, si considera il <strong>ritardo complessivo della rete</strong> come la somma dei ritardi presenti sul percorso più lungo. </div></div><div class="definition environment" id="def2-11"><h2 class="environment-title">Definizione - Complessità di una rete combinatoria</h2><div class="environment-body">     Per confrontare la complessità e la velocità di risposta di reti combinatorie si valutano tre indicatori:     <ul class="list-container"><li class="list-item"><span class="math-span">\( n_{gate}\)</span>, ovvero il <strong>numero di gate</strong> (maggiore è questo numero, più complessa è la rete);         </li><li class="list-item"><span class="math-span">\( n_{conn}\)</span>, ovvero il <strong>numero totale di ingressi dei gate</strong> (maggiore è questo numero, più complessa è la rete);         </li><li class="list-item"><span class="math-span">\( n_{casc}\)</span>, ovvero il <strong>massimo numero di gate disposti in cascata</strong> (minore è questo numero, più veloce è la rete).     </li></ul><div class="mynote environment"><h3 class="environment-title">Osservazioni personali - Ad esempio</h3><div class="environment-body">         Consideriamo la rete <span class="math-span">\( x + (y \cdot z)\)</span>, la cui rappresentazione è la seguente         <div class="image-environment"><div class="image-wrapper spaced-75"><img alt="Immagine" src="../resources/compl-rete-1.png"/></div></div>         si ha che tale rete ha le seguenti caratteristiche:         <ul class="list-container"><li class="list-item"><span class="math-span">\( n_{gate} = 3\)</span>;             </li><li class="list-item"><span class="math-span">\( n_{conn} = 4\)</span>;             </li><li class="list-item"><span class="math-span">\( n_{casc} = 2\)</span>.         </li></ul>         Considerando ora la rete <span class="math-span">\( (x + y) \cdot (x + z)\)</span><div class="image-environment"><div class="image-wrapper spaced-75"><img alt="Immagine" src="../resources/compl-rete-2.png"/></div></div>         si hanno invece le seguenti caratteristiche:         <ul class="list-container"><li class="list-item"><span class="math-span">\( n_{gate} = 3\)</span>;             </li><li class="list-item"><span class="math-span">\( n_{conn} = 6\)</span>;             </li><li class="list-item"><span class="math-span">\( n_{casc} = 2\)</span>.         </li></ul>         Tali reti sono quindi equivalenti e hanno la stessa velocità, tuttavia differiscono in complessità, in quanto la prima è più semplice.     </div></div></div></div><div class="definition environment" id="def2-12"><h2 class="environment-title">Definizione - Ottenere reti di costo minimo</h2><div class="environment-body">     Consideriamo per ipotesi di avere:     <ul class="list-container"><li class="list-item"><strong>ingressi disponibili</strong> sia in <strong>forma vera che in forma negata</strong>;         </li><li class="list-item"><strong>fan-in</strong> dei gate <strong>a piacere</strong></li></ul>      allora è possibile, partendo dall'espressione canonica (SP o PS) e manipolandola adeguatamente, ottenere una funzione:     <ul class="list-container"><li class="list-item">con numero massimo di gate in cascata pari a <span class="math-span">\( 2\)</span>;         </li><li class="list-item">con il minimo numero di gate;         </li><li class="list-item">con il minimo numero di ingressi per i gate.     </li></ul>     Se il numero di gate in cascata è garantito dalle espressioni canoniche, risulta difficile capire se gli altri parametri sono massimizzati.     <br/>     Un metodo per ottenere espressioni migliori è sfruttare le equivalenze notevoli fino a raggiungere l'espressione di costo minimo.      Tuttavia risulta essere difficile capire se si è raggiunto il risultato migliore.     Seguendo il principio di funzionamento delle espressioni canoniche (dove è sufficiente che un mintermine (o un maxtermine) si "attivi" affinchè si "attivi" il circuito),      può essere utile utilizzare dei t<strong>ermini che riconoscano più di una configurazione</strong> (ovvero gli implicanti e gli implicati). </div></div><div class="definition environment" id="def2-13"><h2 class="environment-title">Definizione - Implicante e implicante primo</h2><div class="environment-body">     Un <strong>implicante</strong> è un termine prodotto di <span class="math-span">\( n\)</span> o meno variabili (dove <span class="math-span">\( n\)</span> è il numero di ingressi della rete)      che assume il valore <span class="math-span">\( 1\)</span> solo per configurazioni in cui la funzione vale <span class="math-span">\( 1\)</span> o indifferenza (ovvero vale <span class="math-span">\( 1\)</span> in tutte quelle configurazioni che sono descritte dall'implicante).     <br/>     Un <strong>implicante primo</strong> è invece un implicante che cessa di essere tale rimuovendo un qualsiasi suo letterale.     <br/>     Un <strong>implicante primo</strong> si dice <strong>essenziale</strong> se esiste almeno un mintermine che non è coperto da nessun altro implicante primo (ovvero se per almeno un <span class="math-span">\( 1\)</span> (senza considerare i <span class="math-span">\( -\)</span>) tale implicante è l'unico implicante primo che lo descrive).     <div class="mynote environment"><h3 class="environment-title">Osservazioni personali - Ad esempio</h3><div class="environment-body">         Considerando la seguente tabella della verità         <div class="image-environment"><div class="image-wrapper spaced-30"><img alt="Immagine" src="../resources/generated-19.png"/></div></div>         si ha che i mintermini (ovvero tre ingressi) sono         <span class="math-block">\[             a' \cdot b' \cdot c' \mid             a' \cdot b' \cdot c \mid             a' \cdot b \cdot c' \mid             a' \cdot b \cdot c \mid             a \cdot b' \cdot c' \mid             a \cdot b \cdot c         \]</span>         ovvero tutti i termini che hanno <span class="math-span">\( 1\)</span> o <span class="math-span">\( -\)</span> come uscita.         <br/>         Consideriamo ora i termini a due ingressi, si ha che sono:         <span class="math-block">\[             a' \cdot b' \mid             a' \cdot b \mid             a' \cdot c \mid             a  \cdot c' \mid             b' \cdot c' \mid             b \cdot c         \]</span>         ovvero si ha che tutte le configurazioni che presentano i bit <span class="math-span">\( a\)</span> e <span class="math-span">\( b\)</span> a <span class="math-span">\( 0\)</span> (ovvero <span class="math-span">\( a'\)</span>, <span class="math-span">\( b'\)</span>) hanno come configurazione di uscita <span class="math-span">\( 1\)</span> o indifferenza (e così via).         <br/>         Considerando infine i termini ad un ingresso, si ha         <span class="math-block">\[             a'             \]</span>         Di tutti questi implicanti, si ha che solo         <span class="math-block">\[             a' \mid             b' \cdot c' \mid             b \cdot c           \]</span>         sono implicanti primi. in quanto (ad esempio) nel caso <span class="math-span">\( a' \cdot b\)</span> si ha che rimuovendo <span class="math-span">\( a'\)</span> cessa di essere un implicante ma rimuovendo <span class="math-span">\( b\)</span> no, quindi si ha che non è un implicante primo.         <br/>         Di questi implicanti primi, si ha che:         <ul class="list-container"><li class="list-item"><span class="math-span">\( a'\)</span> è un implicante primo essenziale, in quanto per le configurazioni <span class="math-span">\( 001\)</span> e <span class="math-span">\( 010\)</span> è l'unico implicante valido;             </li><li class="list-item"><span class="math-span">\( b' \cdot c'\)</span> non è un implicante primo essenziale, in quanto descrive solo la configurazione <span class="math-span">\( 000\)</span> che è già descritta da <span class="math-span">\( a'\)</span>. Descrive inoltre la configurazione <span class="math-span">\( 100\)</span> che tuttavia ha come risultato <span class="math-span">\( -\)</span>.             </li><li class="list-item"><span class="math-span">\( b \cdot c\)</span> è un implicante primo essenziale, in quanto è l'unico a descrivere la configurazione <span class="math-span">\( 111\)</span>.         </li></ul></div></div></div></div><div class="definition environment" id="def2-14"><h2 class="environment-title">Definizione - Implicato e implicato primo</h2><div class="environment-body">     Un <strong>implicato</strong> è un termine somma di <span class="math-span">\( n\)</span> o meno variabili (dove <span class="math-span">\( n\)</span> è il numero di ingressi della rete)      che assume il valore <span class="math-span">\( 0\)</span> solo per configurazioni in cui la funzione vale <span class="math-span">\( 0\)</span> o indifferenza (ovvero vale <span class="math-span">\( 0\)</span> in tutte quelle configurazioni che sono descritte dall'implicato).     <br/>     Un <strong>implicato primo</strong> è invece un implicato che cessa di essere tale rimuovendo un qualsiasi suo letterale.     <br/>     Un <strong>implicato primo</strong> si dice <strong>essenziale</strong> se esiste almeno un maxtermine che non è coperto da nessun altro implicante primo (ovvero se per almeno uno <span class="math-span">\( 0\)</span> (senza considerare i <span class="math-span">\( -\)</span>) tale implicato è l'unico implicato primo che lo descrive). </div></div><div class="definition environment" id="def2-15"><h2 class="environment-title">Definizione - Espressione minima</h2><div class="environment-body">     L'<strong>espressione minima</strong> associata ad una qualsiasi tabella della verità è la <strong>somma di implicanti primi essenziali nel caso SP</strong>, mentre è il prodotto degli implicati primi essenziali nel caso PS.     <br/>     Per ottenere l'espressione minima esistono sia metodi algoritmici, eseguiti solitamente da un calcolatore, che metodi grafici, eseguibili manualmente dall'essere umano. </div></div><div class="definition environment" id="def2-16"><h2 class="environment-title">Definizione - Mappa di Karnaugh</h2><div class="environment-body">     Una <strong>mappa di Karnaugh</strong> è la <strong>rappresentazione bidimensionale della tabella della verità</strong> di una funzione fino a quattro variabili.      Le configurazioni di ingresse sono elencate ai bordi utilizzando il codice di Gray, che permette di avere configurazioni consecutive che differiscono per un solo bit.     <br/>     Le mappe permettono di identificare graficamente <strong>configurazioni adiacenti con lo stesso valore di uscita</strong> (cosa utile per trovare poi implicanti e implicati primi essenziali).     <div class="mynote environment"><h3 class="environment-title">Osservazioni personali - Ad esempio</h3><div class="environment-body">         La tabella della verità         <div class="image-environment"><div class="image-wrapper spaced-30"><img alt="Immagine" src="../resources/generated-20.png"/></div></div>         è rappresentata dalla seguente mappa di Karnaugh         <div class="image-environment"><div class="image-wrapper spaced-40"><img alt="Immagine" src="../resources/generated-21.png"/></div></div></div></div></div></div><div class="definition environment" id="def2-17"><h2 class="environment-title">Definizione - Celle adiacenti su mappe di Karnaugh</h2><div class="environment-body">     In una mappa che descrive una funzione di <span class="math-span">\( n\)</span> variabili si ha che ogni cella ha <span class="math-span">\( n\)</span> celle adiacenti.      Ogni cella è adiacente a tutte le celle le cui coordinate differiscono di un solo bit.     <br/>     Graficamente si hanno le seguenti regole:     <ul class="list-container"><li class="list-item">sono adiacenti le <strong>celle aventi un lato in comune</strong>, ovvero         <div class="image-environment"><div class="image-wrapper spaced-40"><img alt="Immagine" src="../resources/generated-22.png"/></div></div></li><li class="list-item">sono adiacenti le <strong>celle poste all'estremità di una stessa riga o colonna</strong>, ovvero         <div class="image-environment"><div class="image-wrapper spaced-40"><img alt="Immagine" src="../resources/generated-23.png"/></div></div></li><li class="list-item">quando si hanno più mappe, sono adiacenti le <strong>celle che occupano la stessa posizione nelle sotto-mappe adiacenti</strong>, ovvero         <div class="image-environment"><div class="image-wrapper spaced-85"><img alt="Immagine" src="../resources/generated-24.png"/></div></div></li></ul></div></div><div class="definition environment" id="def2-18"><h2 class="environment-title">Definizione - Raggruppamento rettangolare</h2><div class="environment-body">     In una mappa di Karnaugh, un <strong>raggruppamento rettangolare di ordine <span class="math-span">\( p\)</span></strong> è un insieme di <span class="math-span">\( 2^{p}\)</span> celle (il cui valore è uguale o è indifferenza) che hanno <span class="math-span">\( p\)</span> celle adiacenti dello stesso valore (o indifferenza).     <div class="mynote environment"><h3 class="environment-title">Osservazioni personali - Ad esempio</h3><div class="environment-body">         Considerando la seguente mappa         <div class="image-environment"><div class="image-wrapper spaced-40"><img alt="Immagine" src="../resources/generated-25.png"/></div></div>         sono evidenziati due raggruppamenti di <span class="math-span">\( 8\)</span> celle (ovvero di ordine <span class="math-span">\( 3\)</span>) e si ha che ogni cella ha almeno <span class="math-span">\( 3\)</span> celle adiacenti dello stesso valore.          <br/>         Ad esempio, nel caso della cella <span class="math-span">\( 0000\)</span><div class="image-environment"><div class="image-wrapper spaced-40"><img alt="Immagine" src="../resources/generated-26.png"/></div></div></div></div></div></div><div class="definition environment" id="def2-19"><h2 class="environment-title">Definizione - Raggruppamenti rettangolari ed implicanti</h2><div class="environment-body">     Considerando un raggruppamento di ordine <span class="math-span">\( p\)</span> le cui celle hanno valore <span class="math-span">\( 1\)</span>, esso individua un implicante della funzione.     In particolare, si avrà un prodotto di <span class="math-span">\( (n - p)\)</span> variabili (ovvero le variabili che rimangono uguali per tutte le celle del raggruppamento) in forma vera se valgono <span class="math-span">\( 1\)</span> ed in forma negata se valgono <span class="math-span">\( 0\)</span>.     <br/>     Inoltre ogni raggruppamento che non è incluso in un altro raggruppamento di ordine superiore, è un implicante primo.     <div class="mynote environment"><h3 class="environment-title">Osservazioni personali - Ad esempio</h3><div class="environment-body">         Considerando la seguente mappa         <div class="image-environment"><div class="image-wrapper spaced-40"><img alt="Immagine" src="../resources/generated-27.png"/></div></div>         si ha che il raggruppamento evidenziato rappresenta un implicante, in particolare si ha che:         <ul class="list-container"><li class="list-item">la variabile <span class="math-span">\( a\)</span> varia;             </li><li class="list-item">la variabile <span class="math-span">\( b\)</span> rimane costante (ed ha valore <span class="math-span">\( 1\)</span>);             </li><li class="list-item">la variabile <span class="math-span">\( c\)</span> rimane costante (ed ha valore <span class="math-span">\( 0\)</span>);             </li><li class="list-item">la variabile <span class="math-span">\( d\)</span> varia.         </li></ul>         Detto ciò, si ha che l'implicante individuato dal raggruppamento è <span class="math-span">\( (b \cdot c')\)</span>.     </div></div></div></div><div class="definition environment" id="def2-20"><h2 class="environment-title">Definizione - Raggruppamenti rettangolari ed implicati</h2><div class="environment-body">     Considerando un raggruppamento di ordine <span class="math-span">\( p\)</span> le cui celle hanno valore <span class="math-span">\( 0\)</span>, esso individua un implicato della funzione.     In particolare, si avrà una somma di <span class="math-span">\( (n - p)\)</span> variabili (ovvero le celle le cui coordinate rimangono uguali per tutte le celle del raggruppamento) in forma vera se valgono <span class="math-span">\( 0\)</span> ed in forma negata se valgono <span class="math-span">\( 1\)</span>.     <br/>     Inoltre ogni raggruppamento che non è incluso in un altro raggruppamento di ordine superiore, è un implicato primo.     <div class="mynote environment"><h3 class="environment-title">Osservazioni personali - Ad esempio</h3><div class="environment-body">         Considerando la seguente mappa         <div class="image-environment"><div class="image-wrapper spaced-40"><img alt="Immagine" src="../resources/generated-28.png"/></div></div>         si hanno due raggruppamenti evidenziati: il più piccolo è un raggruppamento di ordine <span class="math-span">\( 2\)</span> mentre il più grande è di ordine <span class="math-span">\( 3\)</span>. Si ha quindi il minore non è un implicato primo, in quanto si ha che è contenuto in un raggruppamento più grande.         <br/>         Considerando quindi il raggruppamento più grande si ha che:         <ul class="list-container"><li class="list-item">la variabile <span class="math-span">\( a\)</span> varia;             </li><li class="list-item">la variabile <span class="math-span">\( b\)</span> varia;             </li><li class="list-item">la variabile <span class="math-span">\( c\)</span> varia;             </li><li class="list-item">la variabile <span class="math-span">\( d\)</span> rimane costante (ed ha valore <span class="math-span">\( 1\)</span>).         </li></ul>         Si ha quindi che l'implicato è una somma di un solo termine, ovvero <span class="math-span">\( (d')\)</span>.     </div></div></div></div><div class="definition environment" id="def2-21"><h2 class="environment-title">Definizione - Copertura di una funzione su una mappa</h2><div class="environment-body">     La copertura di una funzione su una mappa è l'insieme di raggruppamenti rettangolari composto dall'unione di tutte le celle contenenti valore <span class="math-span">\( 1\)</span> o indifferenza (nel caso di "copertura degli uni") e <span class="math-span">\( 0\)</span> o indifferenza (nel caso di "copertura degli zeri").     <br/>     Ogni copertura fornisce una possibile espressione (SP nel caso di copertura degli uni, PS nel caso di copertura degli zeri).     <br/>     Tra tutte le possibili coperture si possono individuare le <strong>coperture minime</strong>, ovvero quella composta dal minor numero possibile di raggruppamenti di dimensione massima.     <div class="mynote environment"><h3 class="environment-title">Osservazioni personali - Ad esempio</h3><div class="environment-body">         Considerando la seguente mappa         <div class="image-environment"><div class="image-wrapper spaced-40"><img alt="Immagine" src="../resources/generated-29.png"/></div></div>         È possibile individuare due raggruppamenti:         <div class="image-environment"><div class="image-wrapper spaced-40"><img alt="Immagine" src="../resources/generated-30.png"/></div></div>         corrispondenti agli implicati <span class="math-span">\( (c)\)</span> e <span class="math-span">\( (a' + c' + d)\)</span> (ovvero all'espressione <span class="math-span">\( (c \cdot (a' + c' + d))\)</span>): non è tuttavia la copertura minima, in quanto lo è la seguente         <div class="image-environment"><div class="image-wrapper spaced-40"><img alt="Immagine" src="../resources/generated-31.png"/></div></div>         corrispondente agli implicati <span class="math-span">\( (c)\)</span> e <span class="math-span">\( (a' + d)\)</span> (ovvero all'espressione <span class="math-span">\( c \cdot (a' + d)\)</span>).     </div></div></div></div><div class="definition environment" id="def2-22"><h2 class="environment-title">Definizione - Raggruppamenti e termini ridondanti</h2><div class="environment-body">     Un raggruppamento di dimensione massima le cui celle sono tutte incluse in altri raggruppamenti è un <strong>implicato primo non essenziale</strong>: non è quindi "utilizzabile" per ottenere la copertura minima. </div></div><div class="definition environment" id="def2-23"><h2 class="environment-title">Definizione - Individuare la copertura minima</h2><div class="environment-body">     Nonostante non esista un preciso algoritmo per l'individuazione della copertura minima, è però possibile delineare una serie di passi utili a questo scopo.     <ul class="list-container"><li class="list-item">per prima cosa, si sceglie che tipo di espressione cercare (SP o PS);         </li><li class="list-item">si individuano i raggruppamenti rettangolari di dimensione maggiore: nel caso una stessa cella sia compresa in più di un raggruppamento, la si tiene in considerazione per il passo successivo;         </li><li class="list-item">si raggruppano al meglio le celle rimanenti, tenendo conto anche di raggruppare la stessa cella con più di raggruppamenti (evitando però di creare raggruppamenti inutili).     </li></ul></div></div><div class="myexample environment" id="example7"><h2 class="environment-title">Esempio - Sintesi minima di un encoder</h2><div class="environment-body">     Si vuole ottenere l'espressione minima di un encoder (in questo caso di un encoder a <span class="math-span">\( 3\)</span> ingressi), ovvero una rete logica che converte un codice <span class="math-span">\( 1\)</span> su <span class="math-span">\( N\)</span> nel numero binario corrispondente.     <br/>     In particolare, tale rete ha la seguente tabella della verità:     <div class="image-environment"><div class="image-wrapper spaced-40"><img alt="Immagine" src="../resources/generated-32.png"/></div></div>     Abbiamo quindi:     <ul class="list-container"><li class="list-item">la mappa relativa all'uscita <span class="math-span">\( z_{0}\)</span><div class="image-environment"><div class="image-wrapper spaced-40"><img alt="Immagine" src="../resources/generated-33.png"/></div></div>         Per ottenere l'espressione SP consideriamo i seguenti raggruppamenti         <div class="image-environment"><div class="image-wrapper spaced-40"><img alt="Immagine" src="../resources/generated-34.png"/></div></div>         equivalenti all'espressione <span class="math-span">\( (x_{1} + x_{3})\)</span>.         <br/>         L'espressione PS sarà invece data dai seguenti raggruppamenti         <div class="image-environment"><div class="image-wrapper spaced-40"><img alt="Immagine" src="../resources/generated-35.png"/></div></div>         la cui espressione equivalente è <span class="math-span">\( (x_{1} + x_{3})\)</span>, che è esattamente l'espressione minima del caso SP.         </li><li class="list-item">la mappa relativa all'uscita <span class="math-span">\( z_{1}\)</span><div class="image-environment"><div class="image-wrapper spaced-40"><img alt="Immagine" src="../resources/generated-36.png"/></div></div>         Per ottenere l'espressione SP consideriamo i seguenti raggruppamenti         <div class="image-environment"><div class="image-wrapper spaced-40"><img alt="Immagine" src="../resources/generated-37.png"/></div></div>         equivalenti all'espressione <span class="math-span">\( (x_{2} + x_{3})\)</span>.         <br/>         L'espressione PS sarà invece data dai seguenti raggruppamenti         <div class="image-environment"><div class="image-wrapper spaced-40"><img alt="Immagine" src="../resources/generated-38.png"/></div></div>         la cui espressione equivalente è <span class="math-span">\( (x_{2} + x_{3})\)</span>, che è esattamente l'espressione minima del caso SP.     </li></ul></div></div><div class="definition environment" id="def2-24"><h2 class="environment-title">Definizione - Da espressione a tabella della verità con Mappe di Karnaugh</h2><div class="environment-body">     È Se fino ad ora si sono utilizzate le mappe per effettuare la sintesi di una rete (da tabella della verità a espressione minima), è possibile utilizzarle anche per effettuare l'analisi (da espressione o schema logico a tabella della verità):     <ul class="list-container"><li class="list-item">data l'espressione (o dedotta dallo schema logico) la si deve trasformare in una somma di prodotti (ovvero un'espressione SP) o in un prodotto di somme (ovvero un'espressione PS);         </li><li class="list-item">si disegna a questo punto una mappa vuota delle giuste dimensioni (ovvero per <span class="math-span">\( n\)</span> ingressi, una mappa di <span class="math-span">\( 2^{n}\)</span> celle);         </li><li class="list-item">per ogni termine (mintermine nel caso SP, maxtermine nel caso PS) si disegna il raggruppamento corrispondente;         </li><li class="list-item">si inseriscono gli <span class="math-span">\( 1\)</span> (nel caso siano mintermini) e gli <span class="math-span">\( 0\)</span> (nel caso siano maxtermini) nelle celle che fanno parte di almeno un raggruppamento, mentre si inserisce il valore non scelto nelle altre;         </li><li class="list-item">si trasforma la mappa in una tabella della verità.     </li></ul></div></div><div class="myexample environment" id="example8"><h2 class="environment-title">Esempio - Analisi con mappe di Karnaugh - Da espressione a tabella della verità</h2><div class="environment-body">     Considerando la seguente rete logica     <div class="image-environment"><div class="image-wrapper spaced-75"><img alt="Immagine" src="../resources/analisi-con-mappe.png"/></div></div>     si vuole effettuare l'analisi.     <br/>     Per farlo deduciamo l'espressione dallo schema logico:     <ul class="list-container"><li class="list-item">innanzitutto, si può notare che il gate finale è un AND a quattro ingressi, equivalente all'espressione         <span class="math-block">\[             (\ldots) \cdot (\ldots) \cdot (\ldots) \cdot (\ldots)         \]</span></li><li class="list-item">nel primo ingresso vi è un OR a due ingressi, di cui uno è negato (ovvero <span class="math-span">\( (a + c')\)</span>), da cui         <span class="math-block">\[             (a + c') \cdot (\ldots) \cdot (\ldots) \cdot (\ldots)         \]</span></li><li class="list-item">nel secondo vi è un OR a due ingressi, di cui uno è direttamente collegato a <span class="math-span">\( c\)</span> e l'altro è un AND in serie ad un NOT con ingressi <span class="math-span">\( a\)</span> e <span class="math-span">\( b\)</span>, ovvero, equivalente all'espressione <span class="math-span">\( ((a \cdot b)' + c)\)</span>, da cui         <span class="math-block">\[             (a + c') \cdot ((a \cdot b)' + c) \cdot (\ldots) \cdot (\ldots)         \]</span></li><li class="list-item">il terzo ingresso è collegato direttamente a <span class="math-span">\( b\)</span> mentre il quarto a <span class="math-span">\( c\)</span>, da cui si può ottenere l'espressione definitiva         <span class="math-block">\[               (a + c') \cdot ((a \cdot b)' + c) \cdot (b) \cdot (c)         \]</span></li></ul>     Una volta ottenuta l'espressione, si vuole ottenere una forma SP o PS: in questo caso si adatta particolarmente ad una forma PS.      <br/>     Utilizziamo la prima legge di De Morgan (<span class="math-span">\( (a \cdot b)' = a' + b'\)</span>) e otteniamo la seguente espressione     <span class="math-block">\[         (a + c') \cdot (a' + b' + c) \cdot (b) \cdot (c)     \]</span>     che è una forma PS.     <br/>     Disegniamo ora una mappa di Karnaugh sufficientemente grande: dato che abbiamo <span class="math-span">\( 3\)</span> ingressi, sarà una mappa di <span class="math-span">\( 8\)</span> celle, ovvero     <div class="image-environment"><div class="image-wrapper spaced-40"><img alt="Immagine" src="../resources/generated-39.png"/></div></div>     Consideriamo quindi il primo raggruppamento descritto dal maxtermine <span class="math-span">\( a + c'\)</span>: dobbiamo quindi cercare le celle in cui l'ingresso <span class="math-span">\( a\)</span> è uguale a <span class="math-span">\( 0\)</span> mentre l'ingresso <span class="math-span">\( c\)</span> è uguale a <span class="math-span">\( 1\)</span> (in quanto è negato). Avremo quindi     <div class="image-environment"><div class="image-wrapper spaced-40"><img alt="Immagine" src="../resources/generated-40.png"/></div></div>     Con lo stesso ragionamento, disegnamo il raggruppamento descritto da <span class="math-span">\( (a' + b' + c)\)</span>, ovvero     <div class="image-environment"><div class="image-wrapper spaced-40"><img alt="Immagine" src="../resources/generated-41.png"/></div></div>     e i raggruppamenti descritti da <span class="math-span">\( (b)\)</span> e <span class="math-span">\( (c)\)</span>, ovvero     <div class="image-environment"><div class="image-wrapper spaced-40"><img alt="Immagine" src="../resources/generated-42.png"/></div></div>     Inseriamo quindi i valori nelle celle comprese nei raggruppamenti (in questo caso <span class="math-span">\( 0\)</span> dato che abbiamo considerato i maxtermini) e otteniamo la seguente mappa     <div class="image-environment"><div class="image-wrapper spaced-40"><img alt="Immagine" src="../resources/generated-43.png"/></div></div>     che è equivalente alla seguente tabella della verità     <div class="image-environment"><div class="image-wrapper spaced-30"><img alt="Immagine" src="../resources/generated-44.png"/></div></div></div></div><div class="definition environment" id="def2-25"><h2 class="environment-title">Definizione - Sintesi a NAND</h2><div class="environment-body">      Per effettuare la sintesi a NAND di una qualsiasi rete logica è possibile seguire il seguente algoritmo:     <ul class="list-container"><li class="list-item">si parte da un'espressione SP esplicitando le parentesi e gli operatori;         </li><li class="list-item">si sostituiscono tutti gli operatori <span class="math-span">\( \cdot\)</span> con operatori <span class="math-span">\( \uparrow\)</span>;         </li><li class="list-item">si sostituiscono tutti gli operatori <span class="math-span">\( +\)</span> con operatori <span class="math-span">\( \uparrow\)</span> complementando le variabili singole (ovvero quelle non coinvolte in prodotti);         </li><li class="list-item">nel caso non siano disponibili i segnali in forma negata, si esprimono tutti i segnali in tale forma con il NAND del segnale in forma vera.     </li></ul><div class="mynote environment"><h3 class="environment-title">Osservazioni personali - Espressione minima a NAND</h3><div class="environment-body">         Nel caso l'espressione di partenza SP sia nella sua forma minima, si ha che anche l'espressione a NAND è nella sua forma minima.     </div></div></div></div><div class="myexample environment" id="example9"><h2 class="environment-title">Esempio - Sintesi a NAND dell'EXOR</h2><div class="environment-body">     Si vuole effettuare la sintesi a NAND del componente EXOR, la cui espressione canonica SP è la seguente     <span class="math-block">\[         (a \cdot b') + (a' \cdot b)         \]</span>     Iniziamo quindi sostituendo tutti gli operatori <span class="math-span">\( \cdot\)</span><span class="math-block">\begin{aligned}         &amp; (a \uparrow b') + (a' \uparrow b)          &amp; \iff     \end{aligned}</span>     Sostituiamo ora tutti gli operatori <span class="math-span">\( +\)</span> (in questo caso non sono presenti variabili singole, quindi non è necessario complementare alcun ingresso)     <span class="math-block">\begin{aligned}         &amp; (a \uparrow b') \uparrow (a' \uparrow b)          &amp; \iff     \end{aligned}</span>     Sostituiamo infine tutti i segnali in forma negata con la loro rappresentazione a NAND     <span class="math-block">\begin{aligned}         &amp; (a \uparrow (b \uparrow b)) \uparrow ((a \uparrow a) \uparrow b)          &amp;     \end{aligned}</span></div></div><div class="definition environment" id="def2-26"><h2 class="environment-title">Definizione - Sintesi a NOR</h2><div class="environment-body">     Per effettuare la sintesi a NOR di una qualsiasi rete logica è possibile seguire il seguente algoritmo:     <ul class="list-container"><li class="list-item">si parte da un'espressione PS esplicitando le parentesi e gli operatori;         </li><li class="list-item">si sostituiscono tutti gli operatori <span class="math-span">\( +\)</span> con operatori <span class="math-span">\( \downarrow\)</span>;         </li><li class="list-item">si sostituiscono tutti gli operatori <span class="math-span">\( \cdot\)</span> con operatori <span class="math-span">\( \downarrow\)</span> complementando le variabili singole (ovvero quelle non coinvolte in somme);         </li><li class="list-item">nel caso non siano disponibili i segnali in forma negata, si esprimono tutti i segnali in tale forma con il NOR del segnale in forma vera.     </li></ul><div class="mynote environment"><h3 class="environment-title">Osservazioni personali - Espressione minima a NOR</h3><div class="environment-body">         Nel caso l'espressione di partenza PS sia nella sua forma minima, si ha che anche l'espressione a NOR è nella sua forma minima.     </div></div></div></div><div class="myexample environment" id="example10"><h2 class="environment-title">Esempio - Sintesi a NOR del EXNOR</h2><div class="environment-body">     Si vuole effettuare la sintesi a NOR del componente EXNOR ("equivalence"), la cui espressione canonica PS è la seguente     <span class="math-block">\[         (a + b') \cdot (a' + b)         \]</span>     Iniziamo quindi sostituendo tutti gli operatori <span class="math-span">\( +\)</span><span class="math-block">\begin{aligned}         &amp; (a \downarrow b') \cdot (a' \downarrow b)          &amp; \iff     \end{aligned}</span>     Sostituiamo ora tutti gli operatori <span class="math-span">\( \cdot\)</span> (in questo caso non sono presenti variabili singole, quindi non è necessario complementare alcun ingresso)     <span class="math-block">\begin{aligned}         &amp; (a \downarrow b') \downarrow (a' \downarrow b)          &amp; \iff     \end{aligned}</span>     Sostituiamo infine tutti i segnali in forma negata con la loro rappresentazione a NOR     <span class="math-block">\begin{aligned}         &amp; (a \downarrow (b \downarrow b)) \downarrow ((a \downarrow a) \downarrow b)          &amp;     \end{aligned}</span></div></div>
            </article>
            <nav class="buttons-container content-width">
                <a class="navigation-button previous" href="index.html" rel="nofollow"><span>Reti combinatorie</span></a>
                <a class="navigation-button next" href="circuiti-con-decoder-e-multiplexer.html" rel="nofollow"><span>Circuiti con Decoder e Multiplexer</span></a>
            </nav>
        </section>
        <div class="scroll-to-bottom-button" onclick="scroll_to_bottom()">
            <span class="material-symbols-outlined">
                keyboard_double_arrow_down
            </span>
        </div>
        <footer class="footer-wrapper">
            <div class="copyright-wrapper">
                <span> &copy; Copyright 2023</span> /
                <span>made by lorenzoarlo</span>
            </div>
            /
            <div class="privacy-wrapper">
                <span><a href="https://lorenzoarlo.github.io/privacy-and-cookies/" rel="nofollow">Pannello preferenze cookie</a></span> /
                <span><a href="https://lorenzoarlo.github.io/privacy-and-cookies/privacy-policy.html" rel="nofollow" target="_blank" >Privacy Policy</a></span>
            </div>
        </footer>
    </div>
</body>
</html>