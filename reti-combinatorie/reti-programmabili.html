<!DOCTYPE html>
<html lang="IT">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="stylesheet" href="../styles/style.css" />
    <link rel="stylesheet" href="../styles/index-style.css" />
    <link rel="stylesheet" href="../styles/content-style.css" />
    <link rel="icon" type="image/x-icon" href="../resources/favicon.ico">
    <meta name="application-name" content="Reti logiche" />
    <meta name="apple-mobile-web-app-title" content="Reti logiche" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="#ff7f50" />
    <link rel="apple-touch-icon" href="../resources/favicon.png" />
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-78NHLXDQD8"></script>
    <script src="../scripts/script.js"></script>
    <style>:root { --bg-clr: #ff7f50; --fg-clr: #262626; }</style>
    <meta name="theme-color" content="#ff7f50" />
    <meta name="keywords" content="reti logiche, reti combinatorie, reti sequenziali" />
    <meta name="description" content="Il seguente sito contiene gli appunti e le definizioni del corso 'Reti logiche'.">
    <meta name="robots" content="index">
    <script defer async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <title>Reti logiche - Reti combinatorie - Reti programmabili</title>
</head>
<body>
    <div class="container">
        <header class="header-wrapper">
            <div class="title-wrapper">
                <span class="title">
                    Reti logiche
                </span>
                <span class="subtitle">
                    by lorenzoarlo
                </span>
            </div>
            <span class="page-title">
                Reti combinatorie
            </span>
        </header>
        <aside class="sidebar">
            <h2 class="sidebar-title">Reti logiche</h2>
            <div class="index-container">
                <ul class="parent-ul"><li class="section-li"><a href="../index.html">Indice</a></li><li class="section-li "><a href="../concetti-introduttivi/segnali-e-codifiche.html">Concetti introduttivi</a><ul><li class="subsection-li "><a href="../concetti-introduttivi/segnali-e-codifiche.html">Segnali e codifiche</a></li><li class="subsection-li "><a href="../concetti-introduttivi/gate-e-reti-logiche.html">Gate e reti logiche</a></li><li class="subsection-li "><a href="../concetti-introduttivi/reti-come-sistemi-matematici.html">Reti come sistemi matematici</a></li></ul></li><li class="section-li current">Reti combinatorie<ul><li class="subsection-li "><a href="sintesi-di-reti-combinatorie.html">Sintesi di reti combinatorie</a></li><li class="subsection-li "><a href="circuiti-con-decoder-e-multiplexer.html">Circuiti con Decoder e Multiplexer</a></li><li class="subsection-li current">Reti programmabili<ul><li class="definition-li"><a href="#def2-39">Perchè nascono le reti programmabili?</a></li><li class="definition-li"><a href="#def2-40">Memoria</a></li><li class="definition-li"><a href="#def2-41">Rete combinatoria programmabile</a></li><li class="definition-li"><a href="#def2-42">Memorie ROM</a></li><li class="definition-li"><a href="#def2-43">Realizzazione di memorie ROM</a></li><li class="definition-li"><a href="#def2-44">Descrizione di una ROM</a></li><li class="myexample-li"><a href="#example13">Esercizio ROM - Autovelox</a></li><li class="definition-li"><a href="#def2-45">Diversi tipi di ROM</a></li></ul></li><li class="subsection-li "><a href="aritmetica-binaria-e-alu.html">Aritmetica binaria e ALU</a></li><li class="subsection-li "><a href="comportamenti-in-transitorio.html">Comportamenti in transitorio</a></li></ul></li><li class="section-li "><a href="../reti-sequenziali-asincrone/sintesi-di-una-rsa.html">Reti sequenziali asincrone</a><ul><li class="subsection-li "><a href="../reti-sequenziali-asincrone/sintesi-di-una-rsa.html">Sintesi di una RSA</a></li><li class="subsection-li "><a href="../reti-sequenziali-asincrone/analisi-di-una-rsa.html">Analisi di una RSA</a></li><li class="subsection-li "><a href="../reti-sequenziali-asincrone/rsa-notevoli-memorie-binarie.html">RSA notevoli - Memorie binarie</a></li></ul></li><li class="section-li "><a href="../reti-sequenziali-sincrone/caratteristiche-delle-rss.html">Reti sequenziali sincrone</a><ul><li class="subsection-li "><a href="../reti-sequenziali-sincrone/caratteristiche-delle-rss.html">Caratteristiche delle RSS</a></li><li class="subsection-li "><a href="../reti-sequenziali-sincrone/rss-notevoli.html">RSS notevoli</a></li></ul></li></ul>
            </div>
        </aside>
        <div class="sidebar-button" onclick="toggle_sidebar(this)" role="button" >
            keyboard_double_arrow_right
        </div>
        <section class="content-wrapper">
            <h1 class="section-title content-width">Reti programmabili</h1>
            <article class="content-container content-width">
                <div class="definition environment" id="def2-39"><h2 class="environment-title">Definizione - Perchè nascono le reti programmabili?</h2><div class="environment-body">     Con l'avvento della <strong>VLSI</strong> ("<i>Very Large Scale Integration</i>") (grazie a cui sono presenti milioni di gate all'interno dello stesso chip, determinando quindi alti costi di progettazione),      al fine di ammortizzare i costi, è necessario rendere possibile la programmazione. </div></div><div class="definition environment" id="def2-40"><h2 class="environment-title">Definizione - Memoria</h2><div class="environment-body">     Una memoria è la realizzazione circuitale di un array: è, infatti, una <strong>lista di dati indicizzabile con un intero</strong> (l'indirizzo).     <br/>     Anche una tabella della verità può essere vista (logicamente) come una memoria immutabile: in base al valore degli <span class="math-span">\( n\)</span> bit d'ingresso, essa restituisce una delle <span class="math-span">\( 2^{n}\)</span> possibili uscite. </div></div><div class="definition environment" id="def2-41"><h2 class="environment-title">Definizione - Rete combinatoria programmabile</h2><div class="environment-body">     Una rete combinatoria programmabile è una rete in grado di presentare diverse relazioni ingresso/uscita selezionabili tramite la configurazione di segnali interni detti <strong>bit di programmazione</strong> (una memoria immutabile).     <br/>     <div class="image-environment"><div class="image-wrapper spaced-50"><img alt="Immagine" src="../resources/rete-comb-prog.png"/></div></div>     Si ha quindi che     <span class="math-block">\[         z_{i} = F(p_{1}, \ldots, p_{y}, x_{1}, \ldots, x_{n})       \]</span>     o, più sinteticamente     <span class="math-block">\[         z_{i} = F_{p}(x_{1}, \ldots, x_{n})       \]</span>     <div class="mynote environment"><h3 class="environment-title">Nota bene - E il multiplexer?</h3><div class="environment-body">         Il principio di funzionamento è analogo a quello del multiplexer: in esso, tuttavia, i bit di programmazione provengono da segnali <strong>esterni</strong>.     </div></div> </div></div><div class="definition environment" id="def2-42"><h2 class="environment-title">Definizione - Memorie ROM</h2><div class="environment-body">     Le memorie <strong>ROM</strong> ("<i>Read Only Memory</i>") sono memorie non modificabili, ovvero circuiti in cui ad ogni indirizzo corrisponde un dato fissato.     <br/>     Consideriamo ad esempio la seguente memoria     <div class="image-environment"><div class="image-wrapper spaced-30"><img alt="Immagine" src="../resources/generated-49.png"/></div></div>     in cui sono memorizzati <span class="math-span">\( 4\)</span> Byte, indirizzati da <span class="math-span">\( 2\)</span> bit di indirizzi.     <br/>     La stessa tabella può però essere vista anche nel seguente modo     <div class="image-environment"><div class="image-wrapper spaced-60"><img alt="Immagine" src="../resources/generated-50.png"/></div></div>     ovvero un generatore di funzioni combinatorie. </div></div><div class="definition environment" id="def2-43"><h2 class="environment-title">Definizione - Realizzazione di memorie ROM</h2><div class="environment-body">     Per realizzare una ROM si considera ogni uscita come una funzione diversa: ognuna sarà quindi idealmente realizzata nel seguente modo:     <ul class="list-container"><li class="list-item">si utilizza un decoder per avere a disposizione ogni possibile mintermine;         </li><li class="list-item">si utilizza un gate OR che può essere collegato ad ognuno di questi mintermini;         </li><li class="list-item">in base alla funzione che si vuole realizzare, si collegherà o meno ogni mintermine (fisicamente equivale a chiudere o lasciare aperto un contatto).     </li></ul>     Si ha quindi una rete programmabile in grado di realizzare una qualsiasi funzione combinatoria.      <br/>     La programmazione è quindi realizzata internamente (<strong>segnali interni</strong>) e non tramite degli ingressi (si evita quindi di avere un numero sempre maggiore di ingressi).     Per questo motivo si ha che lo stato di tali contatti sono "decisi" dal costruttore su ordine dell'acquirente.      Proprio per questa caratteristica (ovvero essere <strong>OTP</strong> ("<i>One Time Programmable</i>")) sono utili per la memorizzazione di informazioni che non cambiano durante il funzionamento (come il BIOS di un PC). </div></div><div class="definition environment" id="def2-44"><h2 class="environment-title">Definizione - Descrizione di una ROM</h2><div class="environment-body">     Si dice quindi che una ROM <span class="math-span">\( 2^{n} \times k\)</span> è una ROM che:     <ul class="list-container"><li class="list-item">che può memorizzare <span class="math-span">\( 2^{n}\)</span> dati;         </li><li class="list-item">ogni dato è grande <span class="math-span">\( k\)</span> bit;         </li><li class="list-item">è indirizzata tramite <span class="math-span">\( n\)</span> bit (ovvero l'indirizzo è fatto di <span class="math-span">\( n\)</span> bit).     </li></ul> </div></div><div class="myexample environment" id="example13"><h2 class="environment-title">Esempio - Esercizio ROM - Autovelox</h2><div class="environment-body collapsed">     Si vuole progettare una rete combinatoria che realizza una parte del comportamento di un autovelox a due fotocellule. Tale rete è così caratterizzata:     <ul class="list-container"><li class="list-item">un bus in ingresso che riceve il tempo (in millisecondi) trascorso tra l'attivazione della prima e della seconda fotocellula;         </li><li class="list-item">un segnale <span class="mono">AUTO</span> in ingresso che indica se il veicolo è un automobile (<span class="mono">AUTO = 1</span>) o un TIR (<span class="mono">AUTO = 0</span>);         </li><li class="list-item">un'uscita <span class="mono">FOTO</span>;         </li><li class="list-item">una ROM da <span class="math-span">\( 4 \mathrm{ \, KB }\)</span> che realizza una funzione che trasforma i millisecondi in una velocità in <span class="math-span">\( \mathrm{ \, km/h }\)</span> e attiva l'uscita <span class="mono">FOTO</span> se:         <ul class="list-container"><li class="list-item">la velocità è maggiore o uguale di <span class="math-span">\( 128 \mathrm{ \, km/h }\)</span> ed è un auto;             </li><li class="list-item">la velocità è maggiore o uguale di <span class="math-span">\( 64 \mathrm{ \, km/h }\)</span> ed è un TIR.         </li></ul>      </li></ul>     Indicare la dimensione in bit del bus ed indicare il valore massimo di millisecondi che il bus può rappresentare.     <br/>     Per trovare tale valore, consideriamo la dimensione della ROM, ovvero <span class="math-span">\( 4 \mathrm{ \, KB }\)</span>. È quindi una ROM <span class="math-span">\( 4k \times 8\)</span> in quanto ogni byte è uguale ad <span class="math-span">\( 8\)</span> bit.     <br/>     Ora è necessario trovare i bit di indirizzo della memoria e, dato che:     <ul class="list-container"><li class="list-item"><span class="math-span">\( 1 \mathrm{ \, Kb } = 2^{10} \mathrm{ \, bit }\)</span>;         </li><li class="list-item"><span class="math-span">\( 4 \mathrm{ \, b } = 2^{2} \mathrm{ \, bit }\)</span>;     </li></ul>     si ha che:     <ul class="list-container"><li class="list-item">il numero di informazioni memorizzate espresso come potenza di <span class="math-span">\( 2\)</span> è uguale a <span class="math-span">\( 2^{10} \cdot 2^{2} = 2^{12}\)</span>;         </li><li class="list-item">il numero di bit necessari per indirizzare questo numero di informazioni è dato da <span class="math-span">\( \log_{2}(2^{12}) = 12\)</span>.     </li></ul>     Si ha quindi che la dimensione del bus è di <span class="math-span">\( 12\)</span> bit e, da questo dato è possibili ricavare il valore massimo di millisecondi rappresentabile, ovvero     <span class="math-block">\[         2^{12} - 1 = 4095       \]</span>     ovvero <span class="math-span">\( 4095\)</span> millisecondi. </div><div class="environment-tail"><span class="material-symbols-outlined body-visibility-icon" onclick="expand_environment(event)">expand_more</span></div></div><div class="definition environment" id="def2-45"><h2 class="environment-title">Definizione - Diversi tipi di ROM</h2><div class="environment-body">     Proprio per venire incontro alle diverse necessità di "programmazione" nel tempo sono nate:     <ul class="list-container"><li class="list-item">le <strong>PROM</strong> ("<i>Programmable ROM</i>"), ovvero memorie programmabili direttamente dall'utente, ma solo una volta;         </li><li class="list-item">le <strong>EPROM</strong> ("<i>Erasable PROM</i>"), ovvero memorie riprogrammabili: per farlo, è però necessario rimuoverle dal circuito;         </li><li class="list-item">le <strong>EEPROM</strong> ("<i>Electrically EPROM</i>"), ovvero memorie riprogrammabili elettricamente: è quindi possibile farlo senza rimuoverle dal circuito.     </li></ul> </div></div>
            </article>
            <nav class="buttons-container content-width">
                <a class="navigation-button previous" href="circuiti-con-decoder-e-multiplexer.html" rel="nofollow"><span>Circuiti con Decoder e Multiplexer</span></a>
                <a class="navigation-button next" href="aritmetica-binaria-e-alu.html" rel="nofollow"><span>Aritmetica binaria e ALU</span></a>
            </nav>
        </section>
        <div class="scroll-to-bottom-button" onclick="scroll_to_bottom()">
            <span class="material-symbols-outlined">
                keyboard_double_arrow_down
            </span>
        </div>
        <footer class="footer-wrapper">
            <div class="copyright-wrapper">
                <span> &copy; Copyright 2023</span> /
                <span>made by lorenzoarlo</span>
            </div>
            /
            <div class="privacy-wrapper">
                <span><a href="https://lorenzoarlo.github.io/privacy-and-cookies/" rel="nofollow">Pannello preferenze cookie</a></span> /
                <span><a href="https://lorenzoarlo.github.io/privacy-and-cookies/privacy-policy.html" rel="nofollow" target="_blank" >Privacy Policy</a></span>
            </div>
        </footer>
    </div>
</body>
</html>