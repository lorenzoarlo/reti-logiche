<!DOCTYPE html>
<html lang="IT">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="stylesheet" href="../styles/style.css" />
    <link rel="stylesheet" href="../styles/index-style.css" />
    <link rel="stylesheet" href="../styles/content-style.css" />
    <meta name="format-detection" content="telephone=no">
    <meta name="application-name" content="Reti logiche" />
    <meta name="apple-mobile-web-app-title" content="Reti logiche" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="#ff7f50" />
    <link rel="apple-touch-icon" sizes="144x144" href="../apple-icon-144x144.png">
    <link rel="icon" type="image/x-icon" href="../favicon.ico">
    <link rel="icon" type="image/png" sizes="192x192"  href="../android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="96x96" href="../favicon-96x96.png">
    <meta name="msapplication-TileColor" content="#ff7f50">
    <meta name="msapplication-TileImage" content="../ms-icon-144x144.png">
    <meta name="theme-color" content="#ff7f50">
    <link rel="manifest" href="../manifest.json">
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-78NHLXDQD8"></script>
    <script src="../scripts/script.js"></script>
    <style>:root { --bg-clr: #ff7f50; --fg-clr: #262626; }</style>
    <meta name="keywords" content="reti logiche, reti combinatorie, reti sequenziali" />
    <meta name="description" content="Il seguente sito contiene gli appunti e le definizioni del corso 'Reti logiche'.">
    <meta name="robots" content="index">
    <script defer async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <title>Reti logiche - Reti combinatorie - Aritmetica binaria e ALU</title>
</head>
<body>
    <div class="container">
        <header class="header-wrapper">
            <div class="title-wrapper">
                <span class="title">
                    Reti logiche
                </span>
                <span class="subtitle">
                    by lorenzoarlo
                </span>
            </div>
            <span class="page-title">
                Reti combinatorie
            </span>
        </header>
        <aside class="sidebar">
            <h2 class="sidebar-title">Reti logiche</h2>
            <div class="index-container">
                <ul class="parent-ul"><li class="section-li"><a href="../index.html" rel="nofollow">Indice</a></li><li class="section-li "><a href="../concetti-introduttivi/segnali-e-codifiche.html" rel="nofollow">Concetti introduttivi</a><ul><li class="subsection-li "><a href="../concetti-introduttivi/segnali-e-codifiche.html" rel="nofollow">Segnali e codifiche</a></li><li class="subsection-li "><a href="../concetti-introduttivi/gate-e-reti-logiche.html" rel="nofollow">Gate e reti logiche</a></li><li class="subsection-li "><a href="../concetti-introduttivi/reti-come-sistemi-matematici.html" rel="nofollow">Reti come sistemi matematici</a></li></ul></li><li class="section-li current">Reti combinatorie<ul><li class="subsection-li "><a href="sintesi-di-reti-combinatorie.html" rel="nofollow">Sintesi di reti combinatorie</a></li><li class="subsection-li "><a href="circuiti-con-decoder-e-multiplexer.html" rel="nofollow">Circuiti con Decoder e Multiplexer</a></li><li class="subsection-li "><a href="reti-programmabili.html" rel="nofollow">Reti programmabili</a></li><li class="subsection-li current">Aritmetica binaria e ALU<ul><li class="definition-li"><a href="#def2-46" rel="nofollow">Aritmetica binaria tra numeri unsigned (senza segno)</a></li><li class="definition-li"><a href="#def2-47" rel="nofollow">Adder</a></li><li class="definition-li"><a href="#def2-48" rel="nofollow">Half Adder</a></li><li class="definition-li"><a href="#def2-49" rel="nofollow">Full Adder</a></li><li class="definition-li"><a href="#def2-50" rel="nofollow">Adder a \( n\) bit</a></li><li class="definition-li"><a href="#def2-51" rel="nofollow">Complemento a \( \beta - 1\)</a></li><li class="myexample-li"><a href="#example14" rel="nofollow">Complemento a \( 9\) (\( \beta - 1\))</a></li><li class="myexample-li"><a href="#example15" rel="nofollow">Complemento a \( 1\) (\( \beta - 1\))</a></li><li class="definition-li"><a href="#def2-52" rel="nofollow">Complemento a \( \beta\)</a></li><li class="myexample-li"><a href="#example16" rel="nofollow">Complemento a \( 2\) (\( \beta\))</a></li><li class="definition-li"><a href="#def2-53" rel="nofollow">Sottrazione tra numeri unsigned (senza segno) utilizzando un Full Adder</a></li><li class="definition-li"><a href="#def2-54" rel="nofollow">Rappresentazione in base \( 2\) di numeri signed (con segno)</a></li><li class="definition-li"><a href="#def2-55" rel="nofollow">Operazioni tra numeri signed (con segno) utilizzando un Full Adder</a></li><li class="definition-li"><a href="#def2-56" rel="nofollow">Limiti del \( n\)-bit Adder (ripple-carry Adder)</a></li><li class="definition-li"><a href="#def2-57" rel="nofollow">Carry lookahead Adder</a></li><li class="definition-li"><a href="#def2-58" rel="nofollow">Arithmetic Logic Unit (ALU)</a></li></ul></li><li class="subsection-li "><a href="comportamenti-in-transitorio.html" rel="nofollow">Comportamenti in transitorio</a></li></ul></li><li class="section-li "><a href="../reti-sequenziali-asincrone/sintesi-di-una-rsa.html" rel="nofollow">Reti sequenziali asincrone</a><ul><li class="subsection-li "><a href="../reti-sequenziali-asincrone/sintesi-di-una-rsa.html" rel="nofollow">Sintesi di una RSA</a></li><li class="subsection-li "><a href="../reti-sequenziali-asincrone/analisi-di-una-rsa.html" rel="nofollow">Analisi di una RSA</a></li><li class="subsection-li "><a href="../reti-sequenziali-asincrone/rsa-notevoli-memorie-binarie.html" rel="nofollow">RSA notevoli - Memorie binarie</a></li></ul></li><li class="section-li "><a href="../reti-sequenziali-sincrone/caratteristiche-delle-rss.html" rel="nofollow">Reti sequenziali sincrone</a><ul><li class="subsection-li "><a href="../reti-sequenziali-sincrone/caratteristiche-delle-rss.html" rel="nofollow">Caratteristiche delle RSS</a></li><li class="subsection-li "><a href="../reti-sequenziali-sincrone/rss-notevoli.html" rel="nofollow">RSS notevoli</a></li></ul></li></ul>
            </div>
        </aside>
        <div class="sidebar-button" onclick="toggle_sidebar(this)" role="button" >
            keyboard_double_arrow_right
        </div>
        <section class="content-wrapper">
            <h1 class="section-title content-width">Aritmetica binaria e ALU</h1>
            <article class="content-container content-width">
                <div class="definition environment" id="def2-46"><h2 class="environment-title">Definizione - Aritmetica binaria tra numeri unsigned (senza segno)</h2><div class="environment-body">     Il procedimento per effettuare operazioni di somma e differenza tra numeri binari non è differente dalle operazioni in colonna con i numeri decimali.     <br/>     Si aggiunge tuttavia il concetto di <strong>overflow</strong>, dovuto al fatto che nei sistemi digitali si ha un <strong>numero fisso e finito di cifre disponibili</strong> (e quindi un numero massimo rappresentabile): ipotizzando infatti di dedicare <span class="math-span">\( 4\)</span> bit per la rappresentazione di un numero, si ha che il massimo numero rappresentabile è <span class="math-span">\( 15\)</span> (<span class="math-span">\( 2^{n} - 1\)</span>).      Sommando quindi (ad esempio) i numeri <span class="math-span">\( 11\)</span> e <span class="math-span">\( 10\)</span> (entrambi rappresentabili con <span class="math-span">\( 4\)</span> bit), si otterrebbe il valore <span class="math-span">\( 21\)</span> (che necessiterebbe di almeno <span class="math-span">\( 5\)</span> bit).     <div class="image-environment"><div class="image-wrapper spaced-40"><img alt="Immagine" src="../resources/generated-51.png"/></div></div>     Tale concetto è facilmente osservabile dalla presenza dell'ultimo bit di riporto (detto "carry out") a <span class="math-span">\( 1\)</span>. </div></div><div class="definition environment" id="def2-47"><h2 class="environment-title">Definizione - Adder</h2><div class="environment-body">     Un Adder è una rete combinatoria che realizza la somma.      <br/>     Invece di progettare una rete con <span class="math-span">\( 2 \cdot n\)</span> ingressi (<span class="math-span">\( n\)</span> per ogni numero), si può notare la possibilità di adottare un approccio modulare: ciò che è vero per due numeri fatti di un singolo bit, può essere ripetuto per <span class="math-span">\( n\)</span> volte (aggiungendo il riporto).     È quindi sufficiente creare una rete che somma tre bit (i due bit in ingresso <span class="math-span">\( a_{i}\)</span> e <span class="math-span">\( b_{i}\)</span> aggiunti del bit di riporto precedente <span class="math-span">\( r_{i}\)</span>) e che restituisce il bit somma <span class="math-span">\( s_{i}\)</span> e il bit di riporto successivo <span class="math-span">\( r_{i + 1}\)</span>.  </div></div><div class="definition environment" id="def2-48"><h2 class="environment-title">Definizione - Half Adder</h2><div class="environment-body">     L'Half Adder prevede la presenza di due soli bit di ingresso (<span class="math-span">\( a_{i}\)</span> e <span class="math-span">\( b_{i}\)</span>) e può essere realizzato semplicemente nel seguente modo:     <div class="image-environment"><div class="image-wrapper spaced-50"><img alt="Immagine" src="../resources/sintesi-half-adder.png"/></div></div>     Per quanto riguarda il bit somma <span class="math-span">\( s_{i}\)</span>, può essere ottenuto utilizzando un gate EXOR (che realizza proprio la somma logica), mentre per il riporto si utilizza un gate AND (che verifica la presenza di due bit a <span class="math-span">\( 1\)</span>).  </div></div><div class="definition environment" id="def2-49"><h2 class="environment-title">Definizione - Full Adder</h2><div class="environment-body">     Il Full Adder permette di sommare i due bit di ingresso <span class="math-span">\( a_{i}\)</span> e <span class="math-span">\( b_{i}\)</span> ed un terzo bit di riporto <span class="math-span">\( r_{i}\)</span>.      Esso può quindi essere così realizzato:     <div class="image-environment"><div class="image-wrapper spaced-75"><img alt="Immagine" src="../resources/sintesi-full-adder.png"/></div></div>      Esso è realizzato ponendo due Half Adder in serie: il bit somma <span class="math-span">\( s_{i}\)</span> è realizzato grazie agli EXOR, mentre il bit di riporto <span class="math-span">\( r_{i + 1}\)</span> si ottiene valutando la presenza di almeno un riporto dei due Half Adder (con un gate OR). </div></div><div class="definition environment" id="def2-50"><h2 class="environment-title">Definizione - Adder a <span class="math-span">\( n\)</span> bit</h2><div class="environment-body">     In base alle necessità, è possibile realizzare un Adder a <span class="math-span">\( n\)</span> bit in due diversi modi.     <br/>     Nel caso lo si realizzi ponendo in serie un Half Adder e <span class="math-span">\( n - 1\)</span> Full Adder si ottiene una rete a due ingressi (ognuno dei quali è un bus di <span class="math-span">\( n\)</span> bit) e in uscita ha un bus di <span class="math-span">\( n\)</span> bit che rappresenta la somma e un segnale ad un bit detto <span class="math-span">\( c_{out}\)</span> ("<i>carry out</i>", ovvero il riporto).     <br/>     Nel caso invece lo si realizzi ponendo in serie <span class="math-span">\( n\)</span> Full Adder, si ottiene una rete analoga alla precedente ma che prevede un bit in ingresso detto <span class="math-span">\( c_{in}\)</span> ("<i>carry in</i>" ovvero il riporto in ingresso).      In questo modo è possibile disporre in serie <span class="math-span">\( m\)</span> Full Adder per ottenere un Full Adder <span class="math-span">\( m \cdot n\)</span> bit. </div></div><div class="definition environment" id="def2-51"><h2 class="environment-title">Definizione - Complemento a <span class="math-span">\( \beta - 1\)</span></h2><div class="environment-body">     Considerando un numero <span class="math-span">\( a\)</span> di <span class="math-span">\( n\)</span> cifre in base <span class="math-span">\( \beta\)</span>, si dice che il complemento a <span class="math-span">\( \beta - 1\)</span> di tale numero è dato da     <span class="math-block">\[         (\beta^{n} - 1) - a        \]</span>     Da come si può dedurre da tale formula, il complemento a <span class="math-span">\( \beta - 1\)</span> di un numero indica la <strong>differenza tra il massimo numero rappresentabile con <span class="math-span">\( n\)</span> bit ed il numero stesso</strong>.     <br/>     Nell'aritmentica binaria, il complemento a <span class="math-span">\( \beta - 1\)</span> (detto anche "complemento a <span class="math-span">\( 1\)</span>") di un numero è ottenibile effettuando il not "bit a bit". </div></div><div class="myexample environment" id="example14"><h2 class="environment-title">Esempio - Complemento a <span class="math-span">\( 9\)</span> (<span class="math-span">\( \beta - 1\)</span>)</h2><div class="environment-body collapsed">     Considerando il numero <span class="math-span">\( 001234)_{10}\)</span>, si ha che il suo complemento a <span class="math-span">\( 9\)</span> (considerando che è di <span class="math-span">\( 6\)</span> cifre e che è in base <span class="math-span">\( 10\)</span>) è dato da     <span class="math-block">\[         (10^{6} - 1) - 1\,234 = 999\,999 - 1\,234 = 998\,765     \]</span> </div><div class="environment-tail"><span class="material-symbols-outlined body-visibility-icon" onclick="expand_environment(event)">expand_more</span></div></div><div class="myexample environment" id="example15"><h2 class="environment-title">Esempio - Complemento a <span class="math-span">\( 1\)</span> (<span class="math-span">\( \beta - 1\)</span>)</h2><div class="environment-body collapsed">     Considerando il numero <span class="math-span">\( 1010001)_{2}\)</span>, si ha che il suo complemento a <span class="math-span">\( 1\)</span> (considerando che ha <span class="math-span">\( 7\)</span> cifre e che è in base <span class="math-span">\( 2\)</span>) è dato da     <span class="math-block">\[         (2^{6} - 1) - 1010001 = 111111 - 1010001 = 0101110     \]</span>     che è anche calcolabile effettuando il not "bit a bit". </div><div class="environment-tail"><span class="material-symbols-outlined body-visibility-icon" onclick="expand_environment(event)">expand_more</span></div></div><div class="definition environment" id="def2-52"><h2 class="environment-title">Definizione - Complemento a <span class="math-span">\( \beta\)</span></h2><div class="environment-body">     Considerando un numero <span class="math-span">\( a\)</span> di <span class="math-span">\( n\)</span> cifre in base <span class="math-span">\( \beta\)</span>, si dice che il complemento a <span class="math-span">\( \beta\)</span> di tale numero è dato da     <span class="math-block">\[         \beta^{n} - a      \]</span>     Da come è possibile dedurre dalla formula, esso è anche calcolabile aggiungendo <span class="math-span">\( 1\)</span> al complemento <span class="math-span">\( \beta - 1\)</span>.     <br/>     Nell'aritmentica binaria, il complemento a <span class="math-span">\( \beta\)</span> (detto anche "complemento a <span class="math-span">\( 2\)</span>") di un numero è ottenibile sia effettuando il not "bit a bit" del numero e poi sommandogli <span class="math-span">\( 1\)</span> (ovvero sommando <span class="math-span">\( 1\)</span> al complemento a <span class="math-span">\( 1\)</span>), sia lasciando invariato il numero fino al primo <span class="math-span">\( 1\)</span> partendo da destra (esso incluso) e complementando i rimanenti. </div></div><div class="myexample environment" id="example16"><h2 class="environment-title">Esempio - Complemento a <span class="math-span">\( 2\)</span> (<span class="math-span">\( \beta\)</span>)</h2><div class="environment-body collapsed">     Considerando il numero <span class="math-span">\( 1010001)_{2}\)</span>, si ha che il suo complemento a <span class="math-span">\( 2\)</span> è dato da     <span class="math-block">\[         NOT(1010001) + 1 = 0101110 + 1 = 0101111     \]</span> </div><div class="environment-tail"><span class="material-symbols-outlined body-visibility-icon" onclick="expand_environment(event)">expand_more</span></div></div><div class="definition environment" id="def2-53"><h2 class="environment-title">Definizione - Sottrazione tra numeri unsigned (senza segno) utilizzando un Full Adder</h2><div class="environment-body">     Considerando due numeri binari unsigned <span class="math-span">\( a\)</span> e <span class="math-span">\( b\)</span> con <span class="math-span">\( a \geq b\)</span>, è possibile calcolare la differenza <span class="math-span">\( (a - b)\)</span> utilizzando la rappresentazione in complemento a <span class="math-span">\( 2\)</span> per <span class="math-span">\( b\)</span> (in quanto, sostituendo <span class="math-span">\( b\)</span> con l'equivalente <span class="math-span">\( (2^{n} - b)\)</span> si ottiene il valore <span class="math-span">\( (a - b + 2^{n})\)</span>).     <br/>     Per implementare la sottrazione utilizzando un Full Adder a <span class="math-span">\( n\)</span> bit è sufficiente complementare <span class="math-span">\( b\)</span>, impostare il bit <span class="math-span">\( c_{in} = 1\)</span> e considerare il <span class="math-span">\( c_{out}\)</span> come un flag di validità: nel caso sia <span class="math-span">\( 0\)</span> il risultato non è valido.     <div class="image-environment"><div class="image-wrapper spaced-75"><img alt="Immagine" src="../resources/sottrazione-unsigned-full-adder.png"/></div></div>     Di seguito lo schema logico per un generico adder/subtracter:     <div class="image-environment"><div class="image-wrapper spaced-75"><img alt="Immagine" src="../resources/full-adder-unsigned-generico.png"/></div></div>     L'ingresso <span class="mono">S / D'</span> dovrà avere valore <span class="mono">1</span> nel caso si voglia che il circuito esegua un'addizione, <span class="mono">0</span> nel caso si voglia calcolare una sottrazione.     L'uscita <span class="mono">CF</span> indica la validità dell'operazione (<span class="mono">1</span> se è valida, <span class="mono">0</span> se non lo è). </div></div><div class="definition environment" id="def2-54"><h2 class="environment-title">Definizione - Rappresentazione in base <span class="math-span">\( 2\)</span> di numeri signed (con segno)</h2><div class="environment-body">     È possibile rappresentare i numeri signed in diversi modi:     <ul class="list-container"><li class="list-item"><strong>rappresentazione modulo e segno</strong>, ovvero si dedica un bit (il più significativo) al segno e i restanti al valore assoluto. Con <span class="math-span">\( n\)</span> bit si rappresenta quindi l'intervallo         <span class="math-block">\[             [ -(2^{n - 1} - 1), 2^{n - 1} - 1 ]           \]</span>         Si rappresenta quindi un intervallo simmetrico con due rappresentazioni per lo <span class="math-span">\( 0\)</span> (<span class="math-span">\( -0\)</span> e <span class="math-span">\( +0\)</span>).         </li><li class="list-item"><strong>rappresentazione in complemento a <span class="math-span">\( 2\)</span></strong>, ovvero si rappresentano i numeri negativi in complemento a <span class="math-span">\( 2\)</span> (dedicando implicitamente un bit al segno, ovvero il bit più significativo ha valore <span class="math-span">\( -2^{n}\)</span>). Si ha quindi che con <span class="math-span">\( n\)</span> bit si può rappresentare il seguente intervallo:         <span class="math-block">\[             [ -2^{n - 1}, 2^{n - 1} - 1]         \]</span>     </li></ul>     Tra queste, la rappresentazione più usata è quella in complemento a <span class="math-span">\( 2\)</span>.     <div class="mynote environment"><h3 class="environment-title">Nota bene - Why "Complemento a <span class="math-span">\( 2\)</span>"?</h3><div class="environment-body">         Le motivazioni per cui si è scelta la rappresentazione in complemento a <span class="math-span">\( 2\)</span> si deve all'efficienza dei calcoli (che risulta essere molto più complesso nella rappresentazione modulo e segno).     </div></div> </div></div><div class="definition environment" id="def2-55"><h2 class="environment-title">Definizione - Operazioni tra numeri signed (con segno) utilizzando un Full Adder</h2><div class="environment-body">     Per gestire le operazioni con i numeri con segno, è necessario gestire l'overflow:      si ha infatti che nella rappresentazione in complemento a <span class="math-span">\( 2\)</span> esso non dipende dal solo bit di "carry out", bensì dipende dal fatto di sommare due numeri dello stesso segno e ottenerne uno con segno diverso.      Verificare ciò equivale a verificare che:     <span class="math-block">\[         overflow \ = \ (a_{n - 1} == b_{n - 1}) \quad and \quad (a_{n - 1} \neq s_{n - 1} )       \]</span>     Questo è però equivalente a verificare che i gli ultimi due bit di riporto siano diversi     <span class="math-block">\[         overflow \ = \ (c_{out} \neq r_{n - 1})        \]</span>     dove <span class="math-span">\( r_{n - 1}\)</span> è il penultimo riporto.     <br/>     Si ha infatti che se i due numeri hanno lo stesso segno, ovvero     <span class="math-block">\[         a_{n - 1} == b_{n - 1}       \]</span>     ciò implicherebbe che     <span class="math-block">\[         s_{n - 1} = r_{n - 1}     \]</span>     (in quanto se si sommano due bit uguali (ovvero <span class="math-span">\( a_{n -1}\)</span> e <span class="math-span">\( b_{n -1}\)</span>) ad un terzo bit (ovvero <span class="math-span">\( r_{n - 1}\)</span>), il risultato sarà il valore di tale bit).     <br/>     Si ha inoltre che il <span class="math-span">\( c_{out}\)</span> è sempre uguale a <span class="math-span">\( a_{n - 1}\)</span> (in quanto se i due bit di segno sono <span class="math-span">\( 0\)</span> non si potrà mai avere il riporto, altrimenti lo si ha obbligatoriamente).     Quindi il <strong>flag di overflow</strong> è dato dall'EXOR del carry out della rete (<span class="math-span">\( c_{out}\)</span>, ovvero <span class="math-span">\( r_{n}\)</span>) con quello del penultimo (<span class="math-span">\( r_{n - 1}\)</span>). </div></div><div class="definition environment" id="def2-56"><h2 class="environment-title">Definizione - Limiti del <span class="math-span">\( n\)</span>-bit Adder (ripple-carry Adder)</h2><div class="environment-body">     Tale realizzazione dell'<span class="math-span">\( n\)</span>-bit Adder (detta anche "<strong>ripple-carry Adder</strong>")  è molto lenta: ciò è dovuto al fatto che la disposizione in serie degli adder rende necessario che ognuno debba "aspettare" che il precedente abbia terminato in quanto deve conoscere il <span class="math-span">\( c_{out}\)</span> del precedente.     <br/>     Ipotizzando quindi che ogni Adder impieghi <span class="math-span">\( 2 \tau_{p}\)</span> per calcolare il riporto, si ha che per il calcolo della somma tra numeri di <span class="math-span">\( 64\)</span> bit si avrà un ritardo (ovvero un risultato aggiornato) di <span class="math-span">\( 128 \tau_{p}\)</span>. </div></div><div class="definition environment" id="def2-57"><h2 class="environment-title">Definizione - Carry lookahead Adder</h2><div class="environment-body">     Con la miniaturizzazione dei componenti, è stato possibile realizzare un altro Adder composto da più gate ma che non pone in cascata diverse reti.     <br/>     Tale realizzazione si basa sul principio che è possibile esprimere ogni bit risultato in funzione dei bit di ingresso. Si ha infatti che:     <ul class="list-container"><li class="list-item">l'<span class="math-span">\( i\)</span>-esimo bit di somma <span class="math-span">\( s_{i}\)</span> è calcolato come         <span class="math-block">\[             s_{i} = a_{i} \oplus b_{i} \oplus r_{i}             \]</span>         ovvero la somma logica dei segnali e dell'<span class="math-span">\( i\)</span>-esimo riporto;         </li><li class="list-item">l'<span class="math-span">\( (i + 1)\)</span>-esimo bit di riporto <span class="math-span">\( r_{i + 1}\)</span> può essere calcolato come         <span class="math-block">\[             r_{i + 1} = (r_{i} \cdot (a_{i} \oplus b_{i})) + (a_{i} \cdot b_{i})           \]</span>         (ovvero si ha riporto sia se i due bit da sommare sono entrambi a <span class="math-span">\( 1\)</span>, sia se la somma dei due e il <span class="math-span">\( c_in\)</span> in ingresso sono a <span class="math-span">\( 1\)</span>).         <br/>         Dato inoltre che <span class="math-span">\( r_{i}\)</span> può essere espresso in funzione dei segnali al bit <span class="math-span">\( (i - 1)\)</span>, ovvero         <span class="math-block">\[             r_{i} = (r_{i - 1} \cdot (a_{i - 1} \oplus b_{i - 1})) + (a_{i - 1} \cdot b_{i - 1})         \]</span>         fino a raggiungere la prima addizione in cui <span class="math-span">\( i = 0\)</span> (e <span class="math-span">\( r_{0}\)</span> è inizialmente fornito), si ha che l'<span class="math-span">\( (i + 1)\)</span>-esimo riporto è dato da         <span class="math-block">\[             r_{i + i} = \left( r_{0} \cdot \prod_{j = 0}^{i} \left( a_{j} \oplus b_{j} \right)  \right) + \left( \sum_{j = 0}^{i} \left( \left( \ a_{j} \cdot b_{j} \right) \cdot \prod_{k = j + 1}^{i} \left( a_{k} \cdot b_{k} \right) \right)  \right)         \]</span>         Si ottiene in questo modo che ogni riporto è disponibile dopo <span class="math-span">\( 3 \tau_{p}\)</span>, indipendentemente dal numero di bit che si sommano.     </li></ul> </div></div><div class="definition environment" id="def2-58"><h2 class="environment-title">Definizione - Arithmetic Logic Unit (ALU)</h2><div class="environment-body">     L'<strong>ALU</strong> ("<i>Arithmetic Logic Unit</i>") è una <strong>macchina combinatoria</strong> in grado di eseguire operazioni aritmetiche e logiche su due operandi.      Uno specifico segnale in ingresso, detto <strong>op-code</strong>, indica quale di queste operazioni eseguire. Oltre al risultato dell'operazione, forniscono in uscita anche una serie di flag che indicano il verificarsi di specifiche condizioni.     <br/>     Tale componente è fondamentalmente costruito sulla base di un Full Adder adeguatamente modificato per eseguire diverse operazioni aritmetiche e diverse operazioni logiche.     <br/>     Tra i flag aggiunti si ricordano:     <ul class="list-container"><li class="list-item">lo <strong>Zero Flag</strong>, che segnala se il risultato è <span class="math-span">\( 0\)</span>;         </li><li class="list-item">il <strong>Sign Flag</strong>, che segnala se il risultato è negativo (considerando sempre la rappresentazione in complemento a <span class="math-span">\( 2\)</span>).     </li></ul> </div></div>
            </article>
            <nav class="buttons-container content-width">
                <a class="navigation-button previous" href="reti-programmabili.html" rel="nofollow"><span>Reti programmabili</span></a>
                <a class="navigation-button next" href="comportamenti-in-transitorio.html" rel="nofollow"><span>Comportamenti in transitorio</span></a>
            </nav>
        </section>
        <div class="scroll-to-bottom-button" onclick="scroll_to_bottom()">
            <span class="material-symbols-outlined">
                keyboard_double_arrow_down
            </span>
        </div>
        <footer class="footer-wrapper">
            <div class="copyright-wrapper">
                <span> &copy; Copyright 2024</span> /
                <span>made by lorenzoarlo</span>
            </div>
            /
            <div class="privacy-wrapper">
                <span><a href="https://lorenzoarlo.github.io/privacy-and-cookies/" rel="nofollow">Pannello preferenze cookie</a></span> /
                <span><a href="https://lorenzoarlo.github.io/privacy-and-cookies/privacy-policy.html" rel="nofollow" target="_blank" >Privacy Policy</a></span>
            </div>
        </footer>
    </div>
</body>
</html>