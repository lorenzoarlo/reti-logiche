<!DOCTYPE html>
<html lang="IT">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="stylesheet" href="../styles/style.css" />
    <link rel="stylesheet" href="../styles/index-style.css" />
    <link rel="stylesheet" href="../styles/content-style.css" />
    <meta name="format-detection" content="telephone=no">
    <meta name="application-name" content="Reti logiche" />
    <meta name="apple-mobile-web-app-title" content="Reti logiche" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="#ff7f50" />
    <link rel="apple-touch-icon" sizes="144x144" href="../apple-icon-144x144.png">
    <link rel="icon" type="image/x-icon" href="../favicon.ico">
    <link rel="icon" type="image/png" sizes="192x192"  href="../android-icon-192x192.png">
    <link rel="icon" type="image/png" sizes="96x96" href="../favicon-96x96.png">
    <meta name="msapplication-TileColor" content="#ff7f50">
    <meta name="msapplication-TileImage" content="../ms-icon-144x144.png">
    <meta name="theme-color" content="#ff7f50">
    <link rel="manifest" href="../manifest.json">
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-78NHLXDQD8"></script>
    <script src="../scripts/script.js"></script>
    <style>:root { --bg-clr: #ff7f50; --fg-clr: #262626; }</style>
    <meta name="keywords" content="reti logiche, reti combinatorie, reti sequenziali" />
    <meta name="description" content="Il seguente sito contiene gli appunti e le definizioni del corso 'Reti logiche'.">
    <meta name="robots" content="index">
    <script defer async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <title>Reti logiche - Reti combinatorie - Circuiti con Decoder e Multiplexer</title>
</head>
<body>
    <div class="container">
        <header class="header-wrapper">
            <div class="title-wrapper">
                <span class="title">
                    Reti logiche
                </span>
                <span class="subtitle">
                    by lorenzoarlo
                </span>
            </div>
            <span class="page-title">
                Reti combinatorie
            </span>
        </header>
        <aside class="sidebar">
            <h2 class="sidebar-title">Reti logiche</h2>
            <div class="index-container">
                <ul class="parent-ul"><li class="section-li"><a href="../index.html" rel="nofollow">Indice</a></li><li class="section-li "><a href="../concetti-introduttivi/segnali-e-codifiche.html" rel="nofollow">Concetti introduttivi</a><ul><li class="subsection-li "><a href="../concetti-introduttivi/segnali-e-codifiche.html" rel="nofollow">Segnali e codifiche</a></li><li class="subsection-li "><a href="../concetti-introduttivi/gate-e-reti-logiche.html" rel="nofollow">Gate e reti logiche</a></li><li class="subsection-li "><a href="../concetti-introduttivi/reti-come-sistemi-matematici.html" rel="nofollow">Reti come sistemi matematici</a></li></ul></li><li class="section-li current">Reti combinatorie<ul><li class="subsection-li "><a href="sintesi-di-reti-combinatorie.html" rel="nofollow">Sintesi di reti combinatorie</a></li><li class="subsection-li current">Circuiti con Decoder e Multiplexer<ul><li class="definition-li"><a href="#def2-27" rel="nofollow">Circuiti MSI e LSI</a></li><li class="definition-li"><a href="#def2-28" rel="nofollow">Decoder \( n:2^{n}\)</a></li><li class="definition-li"><a href="#def2-29" rel="nofollow">Sintesi del decoder</a></li><li class="definition-li"><a href="#def2-30" rel="nofollow">Fan-out in componenti complessi</a></li><li class="definition-li"><a href="#def2-31" rel="nofollow">Decoder e OR per la sintesi di ogni espressione SP</a></li><li class="myexample-li"><a href="#example11" rel="nofollow">Sintesi del full-adder con decoder e OR</a></li><li class="definition-li"><a href="#def2-32" rel="nofollow">Decoder come circuito integrato</a></li><li class="definition-li"><a href="#def2-33" rel="nofollow">Decoder \( 4:16\) - Composizione di decoder</a></li><li class="definition-li"><a href="#def2-34" rel="nofollow">Multiplexer a \( 2\) vie</a></li><li class="definition-li"><a href="#def2-35" rel="nofollow">Multiplexer generico</a></li><li class="definition-li"><a href="#def2-36" rel="nofollow">Teorema di espansione di Shannon e espressioni generali</a></li><li class="definition-li"><a href="#def2-37" rel="nofollow">Multiplexer come rete programmabile</a></li><li class="myexample-li"><a href="#example12" rel="nofollow">Sintesi full-adder con LUT</a></li><li class="definition-li"><a href="#def2-38" rel="nofollow">Multiplexer con \( 4\) bit di selezione - Composizione di multiplexer</a></li></ul></li><li class="subsection-li "><a href="reti-programmabili.html" rel="nofollow">Reti programmabili</a></li><li class="subsection-li "><a href="aritmetica-binaria-e-alu.html" rel="nofollow">Aritmetica binaria e ALU</a></li><li class="subsection-li "><a href="comportamenti-in-transitorio.html" rel="nofollow">Comportamenti in transitorio</a></li></ul></li><li class="section-li "><a href="../reti-sequenziali-asincrone/sintesi-di-una-rsa.html" rel="nofollow">Reti sequenziali asincrone</a><ul><li class="subsection-li "><a href="../reti-sequenziali-asincrone/sintesi-di-una-rsa.html" rel="nofollow">Sintesi di una RSA</a></li><li class="subsection-li "><a href="../reti-sequenziali-asincrone/analisi-di-una-rsa.html" rel="nofollow">Analisi di una RSA</a></li><li class="subsection-li "><a href="../reti-sequenziali-asincrone/rsa-notevoli-memorie-binarie.html" rel="nofollow">RSA notevoli - Memorie binarie</a></li></ul></li><li class="section-li "><a href="../reti-sequenziali-sincrone/caratteristiche-delle-rss.html" rel="nofollow">Reti sequenziali sincrone</a><ul><li class="subsection-li "><a href="../reti-sequenziali-sincrone/caratteristiche-delle-rss.html" rel="nofollow">Caratteristiche delle RSS</a></li><li class="subsection-li "><a href="../reti-sequenziali-sincrone/rss-notevoli.html" rel="nofollow">RSS notevoli</a></li></ul></li></ul>
            </div>
        </aside>
        <div class="sidebar-button" onclick="toggle_sidebar(this)" role="button" >
            keyboard_double_arrow_right
        </div>
        <section class="content-wrapper">
            <h1 class="section-title content-width">Circuiti con Decoder e Multiplexer</h1>
            <article class="content-container content-width">
                <div class="definition environment" id="def2-27"><h2 class="environment-title">Definizione - Circuiti MSI e LSI</h2><div class="environment-body">     Grazie alla miniaturizzazione dei componenti e all'avvento della MSI e LSI (<i>Medium Scale Integration</i> e <i>Large Scale Integration</i>), è ora possibile progettare utilizzando componenti più complessi al fine di rendere più agevole la progettazione. </div></div><div class="definition environment" id="def2-28"><h2 class="environment-title">Definizione - Decoder <span class="math-span">\( n:2^{n}\)</span></h2><div class="environment-body">     Il decoder è una rete combinatoria che trascodifica codice a <span class="math-span">\( n\)</span> bit in codice "<span class="math-span">\( 1\)</span> su <span class="math-span">\( 2^{n}\)</span>".      <br/>     Un generico decoder è associato alla seguente figura     <div class="image-environment"><div class="image-wrapper spaced-35"><img alt="Immagine" src="../resources/dec-n-2n.png"/></div></div>     ed il suo comportamento è descritto dalla seguente tabella della verità     <div class="image-environment"><div class="image-wrapper spaced-60"><img alt="Immagine" src="../resources/generated-45.png"/></div></div>     Gli <span class="math-span">\( n\)</span> ingressi sono convenzionalmente indicati con <span class="math-span">\( A_{i}\)</span> (con <span class="math-span">\( A_{0}\)</span> che è l'indirizzo di minor peso), mentre le uscite sono indicate con <span class="math-span">\( U_{i}\)</span>, con <span class="math-span">\( i\)</span> che è il numero rappresentato dalla configurazione in ingresso.  </div></div><div class="definition environment" id="def2-29"><h2 class="environment-title">Definizione - Sintesi del decoder</h2><div class="environment-body">     Dato che ogni uscita è ad <span class="math-span">\( 1\)</span> per una sola configurazione di ingresso, si ha che la sintesi SP di ogni uscita è proprio il mintermine corrispondente all'ingresso che la attiva.     <br/>     Per sintetizzare ogni uscita del decoder, è quindi sufficiente utilizzare un solo gate AND a cui sono collegati propriamente i vari ingressi. Ad esempio, il decoder <span class="math-span">\( 2:4\)</span> è così sintetizzato     <div class="image-environment"><div class="image-wrapper spaced-50"><img alt="Immagine" src="../resources/sintesi-dec-2-4.png"/></div></div>     Da notare che il segnale <span class="math-span">\( A\)</span> è stato realizzato negando <span class="math-span">\( A'\)</span> per gestire il fan-out. </div></div><div class="definition environment" id="def2-30"><h2 class="environment-title">Definizione - Fan-out in componenti complessi</h2><div class="environment-body">     L'uscita di ogni componente è caratterizzata da un <strong>fan-out</strong>, ovvero un numero massimo di ingressi a cui può essere collegata.     <br/>     Quando si utilizzano componenti complessi di cui si ignora la struttura interna, non è possibile sapere a quanti ingressi sarà poi collegata all'interno: per ovviare a problemi, si utilizzano quindi due NOT in serie per ogni ingresso, i quali forniscono sia il negato del segnale che la rigenerazione del segnale stesso.     <br/>     Ogni ingresso di ogni componente "consumerà" quindi un solo ingresso. </div></div><div class="definition environment" id="def2-31"><h2 class="environment-title">Definizione - Decoder e OR per la sintesi di ogni espressione SP</h2><div class="environment-body">     Utilizzando propriamente un decoder ed un gate OR, è possibile sintetizzare qualsiasi espressione SP in breve tempo.     <br/>     Ogni decoder, infatti, fornisce in uscita ogni mintermine creabile con <span class="math-span">\( n\)</span> ingressi. È quindi sufficiente collegare ad un OR i mintermini opportuni per realizzare l'espressione. </div></div><div class="myexample environment" id="example11"><h2 class="environment-title">Esempio - Sintesi del full-adder con decoder e OR</h2><div class="environment-body collapsed">     Si vuole sintetizzare il full-adder utilizzando un decoder ed un gate OR.     <br/>     Consideriamo quindi la tabella della verità di questa rete     <div class="image-environment"><div class="image-wrapper spaced-40"><img alt="Immagine" src="../resources/generated-46.png"/></div></div>     Ora, otteniamo la sintesi SP dell'uscita <span class="math-span">\( S\)</span>     <span class="math-block">\[         S(a, b, r) = \sum_{3} m(1, 2, 4, 7)     \]</span>     e dell'uscita <span class="math-span">\( R\)</span>     <span class="math-block">\[         R(a, b, r) = \sum_{3} m(3, 5, 6, 7)     \]</span>     È sufficiente quindi collegare ad un OR a <span class="math-span">\( 4\)</span> ingressi esattamente le uscite corrispondenti a tali mintermini, ovvero     <div class="image-environment"><div class="image-wrapper spaced-75"><img alt="Immagine" src="../resources/sintesi-full-adder-dec-or.png"/></div></div> </div><div class="environment-tail"><span class="material-symbols-outlined body-visibility-icon" onclick="expand_environment(event)">expand_more</span></div></div><div class="definition environment" id="def2-32"><h2 class="environment-title">Definizione - Decoder come circuito integrato</h2><div class="environment-body">     Nella realtà esistono decoder sottoforma di circuito integrato con <span class="math-span">\( 2\)</span>, <span class="math-span">\( 3\)</span> o <span class="math-span">\( 4\)</span> bit di indirizzo.     <br/>     Essi implementano il comportamento del decoder ma aggiungono un ulteriore ingresso, l'<span class="math-span">\( ENABLE\)</span>: se tale ingresso ha valore <span class="math-span">\( 0\)</span>, il componente è disabilitato (ovvero tutte le uscite a <span class="math-span">\( 0\)</span>).     <div class="image-environment"><div class="image-wrapper spaced-30"><img alt="Immagine" src="../resources/dec-2-4-con-en.png"/></div></div> </div></div><div class="definition environment" id="def2-33"><h2 class="environment-title">Definizione - Decoder <span class="math-span">\( 4:16\)</span> - Composizione di decoder</h2><div class="environment-body">     Per realizzare decoder con più ingressi, può risultare utile comporre decoder con meno ingressi tra loro.     <br/>     Ad esempio, per realizzare un decoder <span class="math-span">\( 4:16\)</span> con solo decoder <span class="math-span">\( 2:4\)</span> si può utilizzare la seguente rete:     <div class="image-environment"><div class="image-wrapper spaced-90"><img alt="Immagine" src="../resources/sintesi-dec-16.png"/></div></div>     Il principio di funzionamento di questa rete è il seguente:     <ul class="list-container"><li class="list-item">abbiamo <span class="math-span">\( 4\)</span> bit significativi in ingresso del tipo <span class="math-span">\( DCBA\)</span> (quindi il bit <span class="math-span">\( A\)</span> è quello di minor valore);         </li><li class="list-item">si dividono le <span class="math-span">\( 16\)</span> uscite in quattro blocchi, in cui ogni blocco aggiunge un "offset" iniziale di <span class="math-span">\( +4\)</span> dal precedente;         </li><li class="list-item">i due bit più significativi (<span class="math-span">\( DC\)</span>) determineranno quale dei quattro blocchi sarà attivo (ovvero assegneranno un valore ai due bit);         </li><li class="list-item">una volta scelto il blocco, i due bit meno significativi (<span class="math-span">\( BA\)</span>) determineranno il risultato finale.     </li></ul> </div></div><div class="definition environment" id="def2-34"><h2 class="environment-title">Definizione - Multiplexer a <span class="math-span">\( 2\)</span> vie</h2><div class="environment-body">     Il multiplexer è una rete combinatoria che è l'equivalente hardware di un "if".      <div class="image-environment"><div class="image-wrapper spaced-35"><img alt="Immagine" src="../resources/mux-2.png"/></div></div>     Tale componente ha <span class="math-span">\( 3\)</span> ingressi:     <ul class="list-container"><li class="list-item">due bit di ingresso (dette "vie") <span class="math-span">\( I_{0}\)</span> e <span class="math-span">\( I_{1}\)</span>;         </li><li class="list-item">un bit di indirizzo <span class="math-span">\( A\)</span> dal cui valore dipende l'uscita. L'uscita sarà uguale ad <span class="math-span">\( I_{0}\)</span> se <span class="math-span">\( A = 0\)</span> mentre sarà uguale a <span class="math-span">\( I_{1}\)</span> se <span class="math-span">\( A = 1\)</span>.     </li></ul>     Si ha quindi che la tabella della verità è la seguente     <div class="image-environment"><div class="image-wrapper spaced-30"><img alt="Immagine" src="../resources/generated-47.png"/></div></div>     e l'espressione minima SP equivalente è     <span class="math-block">\[         Z = A' \cdot I_{0} + A \cdot I_{1}       \]</span>     da cui lo schema logico     <div class="image-environment"><div class="image-wrapper spaced-50"><img alt="Immagine" src="../resources/sintesi-mux-2.png"/></div></div> </div></div><div class="definition environment" id="def2-35"><h2 class="environment-title">Definizione - Multiplexer generico</h2><div class="environment-body">     È possibile generalizzare il componente multiplexer ad un componente in cui esistono <span class="math-span">\( n\)</span> ingressi selettori e <span class="math-span">\( 2^{n}\)</span> vie.     <div class="image-environment"><div class="image-wrapper spaced-30"><img alt="Immagine" src="../resources/mux-n.png"/></div></div>     L'espressione generica per realizzare un generico multiplexer è composta dalla somma dei seguenti prodotti:     <span class="math-block">\[         \sum_{n - 1}^{i} m(i) \cdot  I_{i}      \]</span>     dove <span class="math-span">\( m(i)\)</span> indica l'<span class="math-span">\( i\)</span>-esimo mintermine.     <div class="mynote environment"><h3 class="environment-title">Nota bene - Multiplexer a <span class="math-span">\( 4\)</span> vie</h3><div class="environment-body">         Il multiplexer a <span class="math-span">\( 4\)</span> vie         <div class="image-environment"><div class="image-wrapper spaced-30"><img alt="Immagine" src="../resources/mux-4.png"/></div></div>         sarà quindi realizzabile utilizzando la seguente espressione         <span class="math-block">\[             Z = B' \cdot A' \cdot I_{0} + B' \cdot A \cdot I_{1} + B \cdot A' \cdot I_{2} + B \cdot A \cdot I_{3}         \]</span>         che equivale al seguente schema logico         <div class="image-environment"><div class="image-wrapper spaced-75"><img alt="Immagine" src="../resources/sintesi-mux-4.png"/></div></div>     </div></div> </div></div><div class="definition environment" id="def2-36"><h2 class="environment-title">Definizione - Teorema di espansione di Shannon e espressioni generali</h2><div class="environment-body">     Considerando una funzione di <span class="math-span">\( n\)</span> variabili binarie, vale la relazione     <span class="math-block">\[         f(x_{0}, \ldots, x_{j}, \ldots, x_{n}) = x_{j} \cdot f(x_{0}, \ldots, 1, \ldots, x_{n}) + \overline{x_{j}} \cdot f(x_{0}, \ldots, 0, \ldots, x_{n})     \]</span>     Applicando (ad esempio) per tre volte tale teorema ad una funzione di tre variabili si ottiene     <span class="math-block">\begin{aligned}          f(x_{0}, x_{1}, x_{2}) &amp;= \overline{x_{0}} \cdot \overline{x_{1}} \cdot \overline{x_{2}} \cdot f(0, 0, 0) + \overline{x_{0}} \cdot \overline{x_{1}} \cdot x_{2} \cdot f(0, 0, 1) + \\         &amp;+ \overline{x_{0}} \cdot x_{1} \cdot \overline{x_{2}} \cdot f(0, 1, 0) + \overline{x_{0}} \cdot x_{1} \cdot x_{2} \cdot f(0, 1, 1) + \\         &amp;+ x_{0} \cdot \overline{x_{1}} \cdot \overline{x_{2}} \cdot f(1, 0, 0) + x_{0} \cdot \overline{x_{1}} \cdot x_{2} \cdot f(1, 0, 1) + \\         &amp;+ x_{0} \cdot x_{1} \cdot \overline{x_{2}} \cdot f(1, 1, 0) + x_{0} \cdot x_{1} \cdot x_{2} \cdot f(1, 1, 1)     \end{aligned}</span>     che equivale all'espressione descrittiva di un multiplexer.     <br/>     Tale espressione è detta <strong>espressione generale</strong> e permette di rappresentare ogni funzione attraverso un multiplexer.     <br/>     Tale teorema è valido anche nel caso PS. </div></div><div class="definition environment" id="def2-37"><h2 class="environment-title">Definizione - Multiplexer come rete programmabile</h2><div class="environment-body">     Utilizzando quindi le espressioni generali, è possibile utilizzare un multiplexer a <span class="math-span">\( n\)</span> vie come generatore di funzioni a <span class="math-span">\( n\)</span> variabili.     <br/>     Il multiplexer (in questo caso anche detto <strong>LUT</strong> (<i>Look-Up Table</i>)) è quindi un generatore di funzioni, ovvero un componente programmabile a cui è sufficiente fornire la tabella della verità di una funzione sulle vie per fargli realizzare il comportamento. </div></div><div class="myexample environment" id="example12"><h2 class="environment-title">Esempio - Sintesi full-adder con LUT</h2><div class="environment-body collapsed">     Si vuole sintetizzare il full-adder utilizzando un multiplexer usato come LUT.     <br/>     Consideriamo quindi la tabella della verità di questa rete     <div class="image-environment"><div class="image-wrapper spaced-40"><img alt="Immagine" src="../resources/generated-48.png"/></div></div>     È quindi sufficiente collegare i valori di uscita alla giusta "via", ovvero     <div class="image-environment"><div class="image-wrapper spaced-75"><img alt="Immagine" src="../resources/sintesi-full-adder-lut.png"/></div></div> </div><div class="environment-tail"><span class="material-symbols-outlined body-visibility-icon" onclick="expand_environment(event)">expand_more</span></div></div><div class="definition environment" id="def2-38"><h2 class="environment-title">Definizione - Multiplexer con <span class="math-span">\( 4\)</span> bit di selezione - Composizione di multiplexer</h2><div class="environment-body">     Per realizzare multiplexer che gesticono più bit di selezione, può risultare utile comporre multiplexer "meno complessi".     <br/>     Ad esempio, per realizzare un multiplexer a <span class="math-span">\( 16\)</span> vie con solo multiplexer a <span class="math-span">\( 8\)</span> e <span class="math-span">\( 2\)</span> vie si può utilizzare la seguente rete:     <div class="image-environment"><div class="image-wrapper spaced-75"><img alt="Immagine" src="../resources/composizione-mux-lut.png"/></div></div>     Il principio di funzionamento di questa rete è il seguente:     <ul class="list-container"><li class="list-item">abbiamo <span class="math-span">\( 4\)</span> bit significativi in ingresso del tipo <span class="mono">Q<sub>3</sub> Q<sub>2</sub> Q<sub>1</sub> Q<sub>0</sub></span> (quindi il bit <span class="mono">Q<sub>3</sub></span> è quello di maggior valore);         </li><li class="list-item">si dividono le <span class="math-span">\( 16\)</span> possibili configurazioni di ingresso in due blocchi da <span class="math-span">\( 8\)</span> vie, il primo comprenderà le configurazioni con il bit <span class="mono">Q<sub>3</sub> = 0</span> mentre il secondo le configurazioni con il bit <span class="mono">Q<sub>3</sub> = 1</span>;         </li><li class="list-item">a questo punto si discrimina il risultato sulla base del bit <span class="mono">Q<sub>3</sub></span>.     </li></ul> </div></div>
            </article>
            <nav class="buttons-container content-width">
                <a class="navigation-button previous" href="sintesi-di-reti-combinatorie.html" rel="nofollow"><span>Sintesi di reti combinatorie</span></a>
                <a class="navigation-button next" href="reti-programmabili.html" rel="nofollow"><span>Reti programmabili</span></a>
            </nav>
        </section>
        <div class="scroll-to-bottom-button" onclick="scroll_to_bottom()">
            <span class="material-symbols-outlined">
                keyboard_double_arrow_down
            </span>
        </div>
        <footer class="footer-wrapper">
            <div class="copyright-wrapper">
                <span> &copy; Copyright 2024</span> /
                <span>made by lorenzoarlo</span>
            </div>
            /
            <div class="privacy-wrapper">
                <span><a href="https://lorenzoarlo.github.io/privacy-and-cookies/" rel="nofollow">Pannello preferenze cookie</a></span> /
                <span><a href="https://lorenzoarlo.github.io/privacy-and-cookies/privacy-policy.html" rel="nofollow" target="_blank" >Privacy Policy</a></span>
            </div>
        </footer>
    </div>
</body>
</html>