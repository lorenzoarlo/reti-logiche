<!DOCTYPE html>
<html lang="IT">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="stylesheet" href="../styles/style.css" />
    <link rel="stylesheet" href="../styles/index-style.css" />
    <link rel="stylesheet" href="../styles/content-style.css" />
    <link rel="icon" type="image/x-icon" href="../resources/favicon.ico">
    <meta name="application-name" content="Reti logiche" />
    <meta name="apple-mobile-web-app-title" content="Reti logiche" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="#ff7f50" />
    <link rel="apple-touch-icon" href="../resources/favicon.png" />
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-78NHLXDQD8"></script>
    <script src="../scripts/script.js"></script>
    <style>:root { --bg-clr: #ff7f50; --fg-clr: #262626; }</style>
    <meta name="theme-color" content="#ff7f50" />
    <meta name="keywords" content="reti logiche, reti combinatorie, reti sequenziali" />
    <meta name="description" content="Il seguente sito contiene gli appunti e le definizioni del corso 'Reti logiche'.">
    <meta name="robots" content="index">
    <script defer async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <title>Reti logiche - Reti sequenziali asincrone - RSA notevoli - Memorie binarie</title>
</head>
<body>
    <div class="container">
        <header class="header-wrapper">
            <div class="title-wrapper">
                <span class="title">
                    Reti logiche
                </span>
                <span class="subtitle">
                    by lorenzoarlo
                </span>
            </div>
            <span class="page-title">
                Reti sequenziali asincrone
            </span>
        </header>
        <section class="content-wrapper">
            <h1 class="section-title content-width">RSA notevoli - Memorie binarie</h1>
            <article class="content-container content-width">
                <div class="definition environment" id="def3-21"><h2 class="environment-title">Definizione - Memoria binaria</h2><div class="environment-body">     Una <strong>memoria binaria</strong> è un circuito in grado di <strong>memorizzare il valore di un bit</strong>.     <br/>     Esse sono realizzate utilizzando delle RSA e sono uno dei componenti primitivi più importanti, in quanto sono utilizzate per realizzare reti sincrone e, ad esempio, circuiti come le RAM.     <br/>     In base alla sequenza di ingressi e alla temporizzazione dei comandi di modifica, si hanno tre tipi di memorie:     <ul class="list-container"><li class="list-item">Latch SR;         </li><li class="list-item">Latch CD;         </li><li class="list-item">Flip-flop D.     </li></ul></div></div><div class="definition environment" id="def3-22"><h2 class="environment-title">Definizione - Latch SR</h2><div class="environment-body">     Il Latch SR     <div class="image-environment"><div class="image-wrapper spaced-50"><img alt="Immagine" src="../resources/latch-sr.png"/></div></div>     è la memoria binaria più semplice ed è caratterizzata da:     <ul class="list-container"><li class="list-item">un <strong>ingresso di set</strong> <span class="math-span">\( S\)</span>;         </li><li class="list-item">un <strong>ingresso di reset</strong> <span class="math-span">\( R\)</span>;         </li><li class="list-item"><strong>due uscite</strong> che rendono disponibile il valore del bit memorizzato (<span class="math-span">\( Q\)</span>) ed il suo complemento (<span class="math-span">\( Q'\)</span>).     </li></ul>     Il comportamento della rete è il seguente:     <div class="image-environment"><div class="image-wrapper spaced-80"><img alt="Immagine" src="../resources/generated-106.png"/></div></div>     Si ha quindi che alla configurazione <span class="math-span">\( 00\)</span> possono corrispondere due uscite differenti mentre non è previsto l'utilizzo della configurazione <span class="math-span">\( 11\)</span>.      <br/>     Il grafo degli stati che descrive questo componente è il seguente     <div class="image-environment"><div class="image-wrapper spaced-40"><img alt="Immagine" src="../resources/generated-107.png"/></div></div>     dove gli stati <span class="math-span">\( A\)</span> e <span class="math-span">\( B\)</span> indicano     <div class="image-environment"><div class="image-wrapper spaced-30"><img alt="Immagine" src="../resources/generated-108.png"/></div></div>      Dal grafo degli stati è quindi facile derivare la tabella di flusso     <div class="image-environment"><div class="image-wrapper spaced-50"><img alt="Immagine" src="../resources/generated-109.png"/></div></div>     da cui è semplice derivare la tabella delle transizioni     <div class="image-environment"><div class="image-wrapper spaced-50"><img alt="Immagine" src="../resources/generated-110.png"/></div></div>     da cui è facile ottenere la sintesi combinatoria:     <ul class="list-container"><li class="list-item">l'uscita <span class="math-span">\( Q\)</span> è uguale alla sola variabile di stato <span class="math-span">\( y\)</span>;         </li><li class="list-item">lo stato futuro <span class="math-span">\( Y\)</span> può essere sintetizzato in diversi modi (che saranno trattati in seguito).     </li></ul></div></div><div class="definition environment" id="def3-23"><h2 class="environment-title">Definizione - Latch SR - Sintesi PS e a NOR dello stato futuro</h2><div class="environment-body">     Data la tabella della verità dello stato futuro del Latch SR     <div class="image-environment"><div class="image-wrapper spaced-40"><img alt="Immagine" src="../resources/generated-111.png"/></div></div>     è semplice ottenere la sintesi PS, ovvero     <div class="image-environment"><div class="image-wrapper spaced-40"><img alt="Immagine" src="../resources/generated-112.png"/></div></div>     che equivale all'espressione <span class="math-span">\( Y = \overline{R} \cdot (y + S)\)</span> e al circuito     <div class="image-environment"><div class="image-wrapper spaced-50"><img alt="Immagine" src="../resources/latch-sr-PS.png"/></div></div>     Per ottenere quindi l'uscita complementata <span class="math-span">\( Q'\)</span> sarebbe necessario utilizzare anche un NOT: è invece possibile utilizzare una sintesi a NOR, da cui si ottiene l'espressione     <span class="math-block">\[         Y = R \downarrow (y \downarrow S)         \]</span>     che equivale al seguente circuito     <div class="image-environment"><div class="image-wrapper spaced-50"><img alt="Immagine" src="../resources/latch-sr-nor.png"/></div></div>     dove è già fornita l'uscita complementata.     <div class="mynote environment"><h3 class="environment-title">Osservazioni personali - Uscita complementata e configurazione vietata <span class="math-span">\( 11\)</span></h3><div class="environment-body">         Per verificare che il circuito fornisca l'uscita complementata è necessario verificare che la tabella della verità delle due uscite sia coerente, ovvero che         <span class="math-block">\[             S \downarrow y =_{?} \overline{R \downarrow (y \downarrow S)}         \]</span>         Costruendo la tabella della verità si ottiene         <div class="image-environment"><div class="image-wrapper spaced-40"><img alt="Immagine" src="../resources/generated-113.png"/></div></div>         Come si può notare, le due uscite sono coerenti per le diverse configurazioni ad eccezione di tre casi:         <ul class="list-container"><li class="list-item">con la configurazione degli ingressi <span class="math-span">\( 11\)</span>, che non risulta essere un problema in quanto la configurazione è vietata nell'uso corretto della rete;             </li><li class="list-item">con lo stato corrente <span class="math-span">\( 1\)</span> (ovvero lo stato "Memorizzo <span class="math-span">\( 1\)</span>") e la configurazione di ingressi <span class="math-span">\( 01\)</span> (che equivalgono all'azione "Scrivi <span class="math-span">\( 0\)</span>"), che non risulta essere un problema in quanto cambiando un bit di ingresso alla volta risulta impossibile trovarsi in questa situazione (in quanto la configurazione di ingressi <span class="math-span">\( 01\)</span> porterebbe ad essere nello stato <span class="math-span">\( y = 0\)</span>).         </li></ul></div></div></div></div><div class="definition environment" id="def3-24"><h2 class="environment-title">Definizione - Latch SR - Sintesi SP e a NAND dello stato futuro</h2><div class="environment-body">     In modo analogo alla sintesi PS, è facile ottenere dalla tabella della verità dello stato futuro del Latch SR     <div class="image-environment"><div class="image-wrapper spaced-40"><img alt="Immagine" src="../resources/generated-114.png"/></div></div>     la sintesi SP     <div class="image-environment"><div class="image-wrapper spaced-40"><img alt="Immagine" src="../resources/generated-115.png"/></div></div>     equivalente all'espressione <span class="math-span">\( Y = S \cdot (y + \overline{R})\)</span> e al circuito     <div class="image-environment"><div class="image-wrapper spaced-50"><img alt="Immagine" src="../resources/latch-sr-SP.png"/></div></div>     Anche in questo caso è conveniente effettuare la sintesi a NAND per ottenere l'uscita complementata, da cui si ottiene l'espressione     <span class="math-block">\[         Y = \overline{S} \uparrow (y + \overline{R})         \]</span>     e il circuito     <div class="image-environment"><div class="image-wrapper spaced-50"><img alt="Immagine" src="../resources/latch-sr-nand.png"/></div></div><div class="mynote environment"><h3 class="environment-title">Osservazioni personali - Latch <span class="math-span">\( \bar{S}\bar{R}\)</span></h3><div class="environment-body">         Nel caso il Latch sia realizzato con la sintesi a NAND, esso è anche chiamato Latch <span class="math-span">\( \bar{S}\bar{R}\)</span> in quanto richiede gli ingressi complementati.     </div></div></div></div><div class="definition environment" id="def3-25"><h2 class="environment-title">Definizione - Stato iniziale nei Latch SR</h2><div class="environment-body">     Essendo il Latch SR una rete sequenziale, "soffre" della casualità dello stato iniziale:      se in casi come le RAM ciò non risulta essere un problema, in altri è necessario che tali valori possano essere predeterminati.     <br/>     Esistono per questo motivo delle varianti di questo componente che introducono degli ingressi con priorità maggiore rispetto agli ingressi <span class="math-span">\( S\)</span> e <span class="math-span">\( R\)</span>:     <div class="image-environment"><div class="image-wrapper spaced-50"><img alt="Immagine" src="../resources/latch-sr-init.png"/></div></div><ul class="list-container"><li class="list-item">l'<strong>ingresso di preset</strong> (indicato con <span class="math-span">\( PRE'\)</span> dato che l'ingresso è attivo basso) che forza il latch a memorizzare il bit <span class="math-span">\( 1\)</span>;         </li><li class="list-item">l'<strong>ingresso di clear</strong> (indicato con <span class="math-span">\( CLR'\)</span> dato che l'ingresso è attivo basso) che forza il latch a memorizzare il bit <span class="math-span">\( 0\)</span>.     </li></ul>     Anche questi ingressi non possono essere chiaramente attivi in contemporanea.     <br/>     L'idea è quindi quella di creare una rete di combinatoria di inizializzazione che "piloti" il latch durante durante l'inizializzazione e il cui comportamento è il seguente (con <span class="math-span">\( S_{2}\)</span>, <span class="math-span">\( R_{2}\)</span> che sono le uscite della rete combinatoria che andranno poi a pilotare il "vero" latch)     <div class="image-environment"><div class="image-wrapper spaced-50"><img alt="Immagine" src="../resources/generated-116.png"/></div></div>     da cui è possibile ottenere le seguenti espressioni:     <span class="math-block">\begin{aligned}         &amp; S_{2} = PRE + (\overline{CLR} \cdot S)         &amp; R_{2} = CLR + (\overline{PRE} \cdot R)     \end{aligned}</span>     equivalenti alla seguente rete:     <div class="image-environment"><div class="image-wrapper spaced-75"><img alt="Immagine" src="../resources/latch-sr-init-circuit.png"/></div></div>     Tale circuito potrebbe essere inoltre ulteriormente semplificato conoscendo la struttura interna del Latch SR (unendo l'OR ed il NOR ad esempio) oppure realizzando la rete combinatoria più adatta a "pilotare" un Latch <span class="math-span">\( \overline{S}\overline{R}\)</span>.     <br/>     Per memorizzare inizialmente il bit <span class="math-span">\( 0\)</span> si può utilizzare la seguente rete      <div class="image-environment"><div class="image-wrapper spaced-50"><img alt="Immagine" src="../resources/latch-init-0.png"/></div></div>     mentre per memorizzare <span class="math-span">\( 1\)</span><div class="image-environment"><div class="image-wrapper spaced-50"><img alt="Immagine" src="../resources/latch-init-1.png"/></div></div></div></div><div class="definition environment" id="def3-26"><h2 class="environment-title">Definizione - Durata minima degli ingressi e metastabilità</h2><div class="environment-body">     La <strong>durata minima degli ingressi</strong> di un latch è di <span class="math-span">\( 2 \cdot \tau_{p}\)</span> ed è solitamente indicata dal costruttore con la dicitura "<strong>pulse duration</strong>".     <br/>     Nel caso non si rispetti questa durata minima, si ha che il latch può andare in <strong>metastabilità</strong>.     <div class="mynote environment"><h3 class="environment-title">Osservazioni personali - Un po' di elettronica</h3><div class="environment-body">         Considerando il segnale di stato del Latch, esso può essere "diviso idealmente in due", ovvero in stato presente <span class="math-span">\( q\)</span> e stato futuro <span class="math-span">\( Q\)</span> (il valore dello stato che si avrà tra <span class="math-span">\( 2\tau_{p}\)</span>).         <br/>         Idealmente tale bit assume solo due valori ("<i>High</i>" e "<i>Low</i>"), invece nella realtà <strong>è un segnale analogico</strong> che assume un numero infinito di valori e che si considera <i>H</i> o <i>L</i> in base alla vicinanza rispetto ad un valore predefinito.         <div class="image-environment"><div class="image-wrapper spaced-70"><img alt="Immagine" src="../resources/grafico-h-l.png"/></div></div>         Il segnale è tuttavia soggetto a rumore (a causa di fenomeni fisici inevitabili) e per rendere il circuito il più robusto possibile si decide di modificare la pendenza della retta che descrive il rapporto <span class="math-span">\( Q = q\)</span> nel seguente modo          <div class="image-environment"><div class="image-wrapper spaced-70"><img alt="Immagine" src="../resources/grafico-h-l-pendenze.png"/></div></div>         In questo modo si ottengono due effetti:         <ul class="list-container"><li class="list-item">nelle zone in cui la pendenza è minore di <span class="math-span">\( 1\)</span> si rende il circuito più incline alla stabilità;             </li><li class="list-item">nelle zone in cui la pendenza è maggiore di <span class="math-span">\( 1\)</span> si rende il circuito meno stabile;         </li></ul>         Infatti, ipotizzando di avere un segnale al margine della zona di tolleranza <span class="math-span">\( H\)</span>, esso (ricordando che stiamo trattando segnali in retroazione) seguirà il seguente percorso         <div class="image-environment"><div class="image-wrapper spaced-70"><img alt="Immagine" src="../resources/metastabilita-pendenza-minore-1.png"/></div></div>         ovvero tenderà alla stabilità. Nel caso si avesse una pendenza maggiore di <span class="math-span">\( 1\)</span>, ciò porterebbe invece all'effetto contrario.         <br/>         Tuttavia per poter ottenere le pendenze corrette nelle zone di campionamento, è necessario "inserire" una zona con pendenza maggiore di <span class="math-span">\( 1\)</span> e ciò porta alla creazione di un terzo "<strong>punto focale M</strong>" (oltre ai "punti focali H e L"). Tale punto è detto di metastabilità in quanto non si può assumere per esso un valore preciso.          Si ha inoltre che al primo disturbo assumerà un valore indeterminabile.         <br/>         È quindi necessario rispettare il vincolo di "pulse-duration" affinchè la rete funzioni correttamente.     </div></div></div></div><div class="definition environment" id="def3-27"><h2 class="environment-title">Definizione - Latch CD</h2><div class="environment-body">     Il Latch CD     <div class="image-environment"><div class="image-wrapper spaced-50"><img alt="Immagine" src="../resources/latch-cd.png"/></div></div>     ha lo stesso scopo del Latch SR ed è caratterizzato da:     <ul class="list-container"><li class="list-item">un <strong>ingresso di campionamento</strong> <span class="math-span">\( C\)</span>, che indica se il latch deve memorizzare i dati (con <span class="math-span">\( C = 1\)</span> permette la memorizzazione, con <span class="math-span">\( C=0\)</span> mantiene il bit memorizzato);         </li><li class="list-item">un <strong>ingresso di dati</strong> <span class="math-span">\( D\)</span>, che indica il dato da memorizzare;         </li><li class="list-item"><strong>due uscite</strong> che rendono disponibile il valore del bit memorizzato (<span class="math-span">\( Q\)</span>) ed il suo complemento (<span class="math-span">\( Q'\)</span>).     </li></ul>     Il comportamento della rete è il seguente:     <div class="image-environment"><div class="image-wrapper spaced-80"><img alt="Immagine" src="../resources/generated-117.png"/></div></div>     Il grafo degli stati che descrive questo componente è il seguente     <div class="image-environment"><div class="image-wrapper spaced-40"><img alt="Immagine" src="../resources/generated-118.png"/></div></div>     dove gli stati <span class="math-span">\( A\)</span> e <span class="math-span">\( B\)</span> indicano     <div class="image-environment"><div class="image-wrapper spaced-30"><img alt="Immagine" src="../resources/generated-119.png"/></div></div>      Dal grafo degli stati è quindi facile derivare la tabella di flusso     <div class="image-environment"><div class="image-wrapper spaced-50"><img alt="Immagine" src="../resources/generated-120.png"/></div></div>     da cui è semplice derivare la tabella delle transizioni     <div class="image-environment"><div class="image-wrapper spaced-50"><img alt="Immagine" src="../resources/generated-121.png"/></div></div>     da cui è facile ottenere la sintesi combinatoria:     <ul class="list-container"><li class="list-item">l'uscita <span class="math-span">\( Q\)</span> è uguale alla sola variabile di stato <span class="math-span">\( y\)</span>;         </li><li class="list-item">lo stato futuro <span class="math-span">\( Y\)</span> può essere sintetizzata sia in configurazione PS che SP, ricordando di includere i termini ridondanti per evitare le alee statiche.      </li></ul>     È possibile inoltre utilizzare i Latch SR per eseguire una sintesi diretta (che sarà trattata in seguito).     <div class="mynote environment"><h3 class="environment-title">Osservazioni personali - Latch ED</h3><div class="environment-body">         Il Latch CD è anche conosciuto come Latch ED (dove E sta per ENABLE).     </div></div></div></div><div class="definition environment" id="def3-28"><h2 class="environment-title">Definizione - Sintesi del Latch CD sfruttando i Latch SR</h2><div class="environment-body">     Nel caso si sintetizzasse il Latch in forma SP o PS, si dovrebbero aggiungere componenti per fornire l'uscita complementata e si dovrebbe gestire la rete di inizializzazione.     <br/>     È possibile evitare ciò utilizzando il Latch SR con inizializzazione e pilotandolo attraverso una rete combinatoria che "<i>traduce il codice CD in codice SR</i>".     <br/>     Per ottenere tale codificatore è sufficiente ragionare sulle configurazioni di ingresso dei due latch:     <ul class="list-container"><li class="list-item">il Latch SR memorizza <span class="math-span">\( 0\)</span> quando ha in ingresso i valori <span class="math-span">\( S = 0\)</span> e <span class="math-span">\( R = 1\)</span> mentre il Latch CD memorizza <span class="math-span">\( 0\)</span> con gli ingressi <span class="math-span">\( C = 1\)</span> e <span class="math-span">\( D = 0\)</span>;         </li><li class="list-item">il Latch SR memorizza <span class="math-span">\( 1\)</span> quando ha in ingresso i valori <span class="math-span">\( S = 1\)</span> e <span class="math-span">\( R = 0\)</span> mentre il Latch CD memorizza <span class="math-span">\( 1\)</span> con gli ingressi <span class="math-span">\( C = 1\)</span> e <span class="math-span">\( D = 1\)</span>.     </li></ul>        Si ottiene quindi che     <ul class="list-container"><li class="list-item">l'uscita <span class="math-span">\( S\)</span> è attiva quando si ha <span class="math-span">\( C = 1\)</span> e <span class="math-span">\( D = 0\)</span>, il mintermine sarà quindi <span class="math-span">\( S = C \cdot D\)</span>;         </li><li class="list-item">l'uscita <span class="math-span">\( R\)</span> è attiva quando si ha <span class="math-span">\( C = 1\)</span> e <span class="math-span">\( D = 1\)</span>, il mintermine sarà quindi <span class="math-span">\( R = C \cdot \overline{D}\)</span>.     </li></ul>     Si ha quindi che la struttura di un Latch CD sintetizzato con un Latch SR è la seguente     <div class="image-environment"><div class="image-wrapper spaced-70"><img alt="Immagine" src="../resources/latch-cd-init-sintesi-diretta.png"/></div></div>     Dato che il Latch CD sintetizzato in questo modo ha più componenti in cascata, si ha che il suo transitorio è maggiore rispetto a quello del Latch SR (considerando inoltre un ulteriore tempo per evitare che i due ingressi "pilotati" cambino contemporaneamente). </div></div><div class="definition environment" id="def3-29"><h2 class="environment-title">Definizione - Pulse duration, tempo di set-up, di hold e di risposta nel Latch CD</h2><div class="environment-body">     Come per il Latch SR, anche nel Latch CD, esiste una durata minima degli ingressi.     <br/>     In questo caso, la "<strong>pulse-duration</strong>" (<span class="math-span">\( t_{w}\)</span>) è la <strong>durata minima per cui il comando di campionamento </strong>(<span class="math-span">\( C = 1\)</span>) <strong>deve essere valido</strong> (altrimenti si incorre nella metastabilità).     <br/>     Nel caso del Latch CD è possibile caratterizzare meglio i tempi da rispettare:     <ul class="list-container"><li class="list-item">una volta iniziato il campionamento (<span class="math-span">\( C\)</span> diventa <span class="math-span">\( 1\)</span>) è necessario aspettare un "<strong>set-up time</strong>" (<span class="math-span">\( t_{su}\)</span>) per la propagazione del segnale attraverso i gate. Si ha quindi che la "pulse-duration" deve essere almeno più grande del "set-up time";         </li><li class="list-item">una volta terminato il campionamento (<span class="math-span">\( C\)</span> diventa <span class="math-span">\( 0\)</span>) è necessario aspettare un "<strong>hold time</strong>" (<span class="math-span">\( t_{h}\)</span>) prima di modificare l'ingresso <span class="math-span">\( D\)</span> affinchè la retroazione si inneschi.     </li></ul>     L'ingresso <span class="math-span">\( D\)</span> deve quindi rimanere costante anche per il tempo di hold (oltre che per la "pulse-duration") in modo da evitare che due ingressi cambino contemporaneamente (dato che il circuito combinatorio che pilota il Latch SR passa da <span class="math-span">\( SR=10\)</span> a <span class="math-span">\( SR=01\)</span> (ovvero cambiano entrambi gli ingressi) direttamente).     <br/>     L'uscita della rete sarà aggiornata solo dopo un <strong>tempo di risposta</strong> <span class="math-span">\( t_{r}\)</span>.   </div></div><div class="definition environment" id="def3-30"><h2 class="environment-title">Definizione - Uscita trasparente nel Latch CD</h2><div class="environment-body">     Quando <span class="math-span">\( C = 1\)</span>, si ha che ogni cambiamento di <span class="math-span">\( D\)</span> (se tenuto costante per un adeguato tempo) si riflette (dopo il relativo tempo di risposta) direttamente sull'uscita <span class="math-span">\( Q\)</span>, provocando il fenomeno di <strong>uscita trasparente </strong>(ciò che entra, esce).     <br/>     Qualora si collegasse l'uscita <span class="math-span">\( Q\)</span> in retroazione diretta con l'ingresso <span class="math-span">\( D\)</span> si avrebbe una continua oscillazione di valori (in quanto il tempo di hold non è rispettato) rendendo impossibile questo montaggio.  </div></div><div class="definition environment" id="def3-31"><h2 class="environment-title">Definizione - Flip-flop D</h2><div class="environment-body">     Il Flip-flop D     <div class="image-environment"><div class="image-wrapper spaced-50"><img alt="Immagine" src="../resources/flip-flop-d.png"/></div></div>     è una rete sequenziale asincrona caratterizzata da:     <ul class="list-container"><li class="list-item">un ingresso <span class="math-span">\( D\)</span>, che indica il dato da memorizzare;         </li><li class="list-item">un ingresso <span class="math-span">\( CLK\)</span>, che svolge il ruolo di segnale di campionamento;         </li><li class="list-item">due uscite che rendono disponibile il valore del bit memorizzato (<span class="math-span">\( Q\)</span>) ed il suo complemento (<span class="math-span">\( Q'\)</span>).     </li></ul>     A differenza del Latch CD (dove il periodo di campionamento poteva durare potenzialmente all'infinito) il Flip Flop D "campiona" solo per un istante il segnale <span class="math-span">\( D\)</span>, ovvero durante il fronte di salita di <span class="math-span">\( CLK\)</span> (nel caso di <strong>Flip-flop positive edge triggered</strong>).      A seguito del campionamento, l'uscita <span class="math-span">\( Q\)</span> riflette il valore campionato con un ritardo che permette il montaggio in retroazione.     <br/>     I tempi caratteristici di un Flip-flop D hanno gli stessi nomi di quelli del Latch CD, ma con significati leggermente diversi in quanto sono tutti riferiti al fronte di salita del clock (dato che è l'unico evento che può modificare lo stato).      In particolare si ha che:     <ul class="list-container"><li class="list-item">il <strong>tempo di set-up</strong> indica il tempo minimo per cui <span class="math-span">\( D\)</span> deve <strong>rimanere costante prima</strong> del fronte;         </li><li class="list-item">il <strong>tempo di hold</strong> indica il tempo minimo per cui D deve <strong>rimanere costante dopo</strong> al fronte;         </li><li class="list-item">il <strong>tempo di risposta</strong> indica il <strong>tempo massimo del transitorio</strong> delle uscite <span class="math-span">\( Q\)</span> e <span class="math-span">\( Q'\)</span>.     </li></ul>     Un modo per realizzare questa rete è utilizzare due Latch CD in cascata nel seguente modo (realizzazione <strong>Master-Slave</strong>):     <div class="image-environment"><div class="image-wrapper spaced-70"><img alt="Immagine" src="../resources/flipflop-master-slave.png"/></div></div>     Per comprendere il funzionamento, può essere utile immaginare i due ingressi in uno stato di quiete, entrambi a <span class="math-span">\( 0\)</span>.     <br/>     In questa situazione si ha che il "<strong>Latch Master</strong>" è in fase di campionamento (grazie al NOT che trasforma il segnale in <span class="math-span">\( 1\)</span>) mentre l'altro è stabile.      Nel momento in cui <span class="math-span">\( CLK\)</span> passa da <span class="math-span">\( 0\)</span> a <span class="math-span">\( 1\)</span>, si ha che il "<strong>Latch Slave</strong>" inizia il campionamento e, in questo momento assume il valore "memorizzato" nel Master (che ha continuato a memorizzare il valore di <span class="math-span">\( D\)</span>). Fino a che <span class="math-span">\( CLK\)</span> non vedrà un altro fronte di salita, la rete non riaggiornerà le sue uscite dato che:     <ul class="list-container"><li class="list-item">fino a che <span class="math-span">\( CLK\)</span> rimane a <span class="math-span">\( 1\)</span> si avrà che il Master non è in campionamento (e continua a memorizzare il segnale "attuale per la rete" di <span class="math-span">\( D\)</span>);         </li><li class="list-item">quando <span class="math-span">\( CLK\)</span> passa a <span class="math-span">\( 1\)</span> a <span class="math-span">\( 0\)</span>, sarà lo Slave a terminare il campionamento (e a non riaggiornarsi).     </li></ul>       Il problema di tale implementazione è dovuto alla presenza del NOT: esso introduce un ritardo che potrebbe disallineare i segnali <span class="math-span">\( C\)</span> dei Latch. Per ovviare a ciò è possibile utilizzare due segnali di clock (clock a due fasi) che garantiscono un periodo di memorizzazione ad ogni latch prima di portarne uno in trasparenza.     <br/>     Un'altra sintesi possibile è quella "<strong>Edge-Triggered</strong>": essa contiene scelte progettuali non intuitive (come l'utilizzo di tre variabili di stato) ma utilizza meno gate rispetto a quella "Master-Slave". Essa utilizza infatti solo 6 NAND (invece di 8) e prevede che i comandi <span class="math-span">\( PRE'\)</span> e <span class="math-span">\( CLR'\)</span> siano prioritari rispetto al segnale CLK.  </div></div><div class="definition environment" id="def3-32"><h2 class="environment-title">Definizione - Flip-flop D come elemento di ritardo</h2><div class="environment-body">     Se l'ingresso <span class="math-span">\( CLK\)</span> è pilotato da un <strong>segnale periodico</strong> (detto di clock) il Flip-flop ritarda il segnale di uscita <span class="math-span">\( Q\)</span> (rispetto al segnale di ingresso <span class="math-span">\( D\)</span>) di un tempo pari al periodo di clock.      Si ha quindi che il clock <strong>divide il tempo in intervalli discreti</strong> in cui vale la relazione     <span class="math-block">\[         Q^{n + 1} = D^{n}         \]</span>     ovvero si ha che l'uscita <span class="math-span">\( Q\)</span> all'istante <span class="math-span">\( n + 1\)</span> è uguale all'ingresso <span class="math-span">\( D\)</span> all'istante precedente <span class="math-span">\( n\)</span>. </div></div>
            </article>
            <nav class="buttons-container content-width">
                <a class="navigation-button previous" href="analisi-di-una-rsa.html" rel="nofollow"><span>Analisi di una RSA</span></a>
                <a class="navigation-button next" href="../reti-sequenziali-sincrone/index.html" rel="nofollow"><span>Reti sequenziali sincrone</span></a>
            </nav>
        </section>
        <div class="scroll-to-bottom-button" onclick="scroll_to_bottom()">
            <span class="material-symbols-outlined">
                keyboard_double_arrow_down
            </span>
        </div>
        <footer class="footer-wrapper">
            <div class="copyright-wrapper">
                <span> &copy; Copyright 2023</span> /
                <span>made by lorenzoarlo</span>
            </div>
            /
            <div class="privacy-wrapper">
                <span><a href="https://lorenzoarlo.github.io/privacy-and-cookies/" rel="nofollow">Pannello preferenze cookie</a></span> /
                <span><a href="https://lorenzoarlo.github.io/privacy-and-cookies/privacy-policy.html" rel="nofollow" target="_blank" >Privacy Policy</a></span>
            </div>
        </footer>
    </div>
</body>
</html>