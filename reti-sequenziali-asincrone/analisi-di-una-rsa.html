<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="stylesheet" href="../styles/style.css" />
    <link rel="stylesheet" href="../styles/index-style.css" />
    <link rel="stylesheet" href="../styles/content-style.css" />
    <link rel="icon" type="image/x-icon" href="../resources/favicon.ico">
    <link rel="apple-touch-icon" href="../resources/favicon.png" />
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-78NHLXDQD8"></script>
    <script src="../scripts/script.js"></script>
    <style>:root { --bg-clr: #ff7f50; --fg-clr: #262626; }</style>
    <meta name="theme-color" content="#ff7f50" />
    <meta name="keywords" content="reti logiche, reti combinatorie, reti sequenziali" />
    <meta name="description" content="Il seguente sito contiene gli appunti e le definizioni del corso 'Reti logiche'.">
    <meta name="robots" content="index">
    <script defer async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <title>Reti logiche - Reti sequenziali asincrone - Analisi di una RSA</title>
</head>
<body>
    <div class="container">
        <header class="header-wrapper">
            <div class="title-wrapper">
                <span class="title">
                    Reti logiche
                </span>
                <span class="subtitle">
                    by lorenzoarlo
                </span>
            </div>
            <span class="page-title">
                Reti sequenziali asincrone
            </span>
        </header>
        <section class="content-wrapper">
            <h1 class="section-title content-width">Analisi di una RSA</h1>
            <article class="content-container content-width">
                <div class="definition environment" id="def3-20"><h2 class="environment-title">Definizione - Analisi di una RSA</h2><div class="environment-body">     Considerando una rete sequenziale asincrona data, per effettuare l'analisi (ovvero risalire al grafo degli stati) è necessario:     <ul class="list-container"><li class="list-item">riconoscere variabili in ingresso, in uscita e di stato;         </li><li class="list-item">per ogni uscita e ogni stato futuro, <strong>si analizza il circuito combinatorio ad esso correlato</strong>, ricordando anche di considerare come ingressi le variabili di stato presente;         </li><li class="list-item">una volta ottenute le varie espressioni combinatorie, si cerca di <strong>ricondursi ad una configurazione SP o PS</strong> in modo da essere agevoli nel passaggio successivo;         </li><li class="list-item">per ogni espressione si <strong>ricostruisce la tabella della verità</strong> (utilizzando ad esempio le mappe di Karnaugh "riempite" adeguatamente considerando mintermini e maxtermini). In questo passaggio <strong>si verifica anche se sono state eliminate a priori le alee statiche</strong> con la configurazione ridondante;         </li><li class="list-item">unendo le tabelle della verità si ottiene una tabella delle transizioni completamente specificata (anche se non tutte sono significativamente utili). Ogni cella che ha come destinazione il proprio stato, la si considera una cella stabile.         </li><li class="list-item">per risalire al comportamento della rete è necessario modificare la tabella per ottenere la tabella di flusso originaria. Per farlo si deve:         <ul class="list-container"><li class="list-item">nelle <strong>colonne prive di stati</strong> stabili <strong>porre tutte le celle ad indifferenze</strong> in quanto sono ingressi non disponibili per la rete (in quanto se lo fossero, si avrebbero solo transizioni multiple inutili);             </li><li class="list-item"><strong>per ogni riga</strong> (ovvero per ogni stato), si pongono ad indifferenza le celle <strong>non adiacenti a celle stabili</strong> (sulla riga) in quanto non si potrebbe raggiungerle modificando un solo bit di ingresso alla volta;             </li><li class="list-item">si <strong>evidenzia ogni riga</strong> (ovvero ogni stato) <strong>che non contiene alcuna cella stabile</strong> (in quanto non presente nel grafo iniziale). Tali righe saranno poi da eliminare;             </li><li class="list-item">si analizza ogni coppia <i>(stato presente, stato futuro)</i> dove la cella di "partenza" non è da eliminare. In questo momento è necessario verificare <strong>eventuali errori di progetto</strong> dovuti al non trattamento di corse critiche (è quindi necessario verificare se una corsa è critica o meno). È anche necessario <strong>sostituire eventuali transizioni multiple</strong> con lo stato di destinazione.             </li><li class="list-item">nel caso si stia trattando un automa di Mealy (evidente dal fatto che su una stessa riga si hanno uscite differenti), si pone l'indifferenza sulle uscite delle celle delle transizioni in cui l'uscita varia.         </li></ul></li><li class="list-item">si cerca di creare una descrizione testuale che descrive il comportamento della rete.     </li></ul></div></div><div class="myexample environment" id="example18"><h2 class="environment-title">Esempio - Analisi di una RSA</h2><div class="environment-body">     Considerando la rete descritta dalle seguenti espressioni     <span class="math-block">\[         \begin{array}{ccl}             Z_{1} &amp; = &amp; (x_{1} \cdot y_{2}) + (x_{1} \cdot y_{1}) \\             Z_{2} &amp; = &amp; (x_{2} \cdot \overline{y_{1}}) + ( y_{0} \cdot \overline{y_{2}}) \\             Y_{0} &amp; = &amp; (x_{1} \cdot \overline{x_{2}}) + (\overline{x_{1}} \cdot y_{0} \cdot y_{1}) + (x_{1} \cdot \overline{y_{1}}) \\             Y_{1} &amp; = &amp; (y_{0} \cdot y_{1}) + (x_{1} \cdot y_{1}) + (x_{1} \cdot \overline{x_{2}} \cdot y_{0} \cdot \overline{y_{2}}) \\             Y_{2} &amp; = &amp; (x_{1} \cdot \overline{x_{2}} \cdot y_{2}) + (\overline{x_{2}} \cdot y_{1}) + (x_{1} \cdot \overline{x_{2}} \cdot \overline{y_{0}})         \end{array}     \]</span>     dove le variabili <span class="math-span">\( x_{?}\)</span> indicano gli ingressi della rete, le variabili <span class="math-span">\( Z_{?}\)</span> indicano le uscite della rete, le variabili <span class="math-span">\( y_{?}\)</span> indicano le variabili di stato presente e le variabili <span class="math-span">\( Y_{?}\)</span> indicano le variabili di stato futuro.     <br/>     Considerando queste espressioni, risaliamo alle tabelle della verità utilizzando le mappe di Karnaugh. Si ha quindi:     <ul class="list-container"><li class="list-item">la mappa relativa all'uscita <span class="math-span">\( Z_{1}\)</span> (<span class="math-span">\( = x_{1} \cdot y_{2} + x_{1} \cdot y_{1}\)</span>), ovvero         <div class="image-environment"><div class="image-wrapper spaced-40"><img alt="Immagine" src="../resources/generated-92.png"/></div></div></li><li class="list-item">la mappa relativa all'uscita <span class="math-span">\( Z_{2}\)</span> (<span class="math-span">\( = x_{2} \cdot \overline{y_{1}} + y_{0} \cdot \overline{y_{2}}\)</span>), ovvero         <div class="image-environment"><div class="image-wrapper spaced-40"><img alt="Immagine" src="../resources/generated-93.png"/></div></div></li><li class="list-item">la mappa relativa all'uscita <span class="math-span">\( Y_{0}\)</span> (<span class="math-span">\( = x_{1} \cdot \overline{x_{2}} + \overline{x_{1}} \cdot y_{0} \cdot y_{1} + x_{1} \cdot \overline{y_{1}}\)</span>), ovvero         <div class="image-environment"><div class="image-wrapper spaced-40"><img alt="Immagine" src="../resources/generated-94.png"/></div></div>         in questo caso si può notare che non sono presenti tutti gli implicanti primi e si è quindi violato un vincolo di progetto.         </li><li class="list-item">la mappa relativa all'uscita <span class="math-span">\( Y_{1}\)</span> (<span class="math-span">\( = y_{0} \cdot y_{1} + x_{1} \cdot y_{1} + x_{1} \cdot \overline{x_{2}} \cdot y_{0} \cdot \overline{y_{2}}\)</span>), ovvero         <div class="image-environment"><div class="image-wrapper spaced-40"><img alt="Immagine" src="../resources/generated-95.png"/></div></div></li><li class="list-item">la mappa relativa all'uscita <span class="math-span">\( Y_{2}\)</span> (<span class="math-span">\( = x_{1} \cdot \overline{x_{2}} \cdot y_{2} + \overline{x_{2}} \cdot y_{1} + x_{1} \cdot \overline{x_{2}} \cdot \overline{y_{0}}\)</span>), ovvero         <div class="image-environment"><div class="image-wrapper spaced-40"><img alt="Immagine" src="../resources/generated-96.png"/></div></div></li></ul>     Dalle mappe è possibile quindi costruire la tabella delle transizioni (che è possibile costruire con le righe che seguono la codifica delle mappe (che non è totalmente di Gray) per semplificare la copiatura dei dati). Guardando inoltre le espressioni per il calcolo dei bit di uscita, è possibile anche verificare se è un automa di Mealy o di Moore, costruendo la giusta tabella.     In questo caso si ha che è un automa di Mealy, in quanto le uscite dipendono anche dagli ingressi.     <div class="image-environment"><div class="image-wrapper spaced-60"><img alt="Immagine" src="../resources/generated-97.png"/></div></div>     Una volta costruita la tabella delle transizioni, è possibile evidenziare tutte le celle di stabilità.     <div class="image-environment"><div class="image-wrapper spaced-60"><img alt="Immagine" src="../resources/generated-98.png"/></div></div>     Una volta fatto ciò, si deve controllare se tutti gli ingressi hanno almeno una cella stabile (altrimenti si può porre indifferenza su tutte le uscite e stati della colonna): in questo caso non è possibile farlo per alcuna colonna.     <br/>     Evidenziamo ora ogni riga (in verde) che non contiene alcuna cella stabile e in rosso ogni cella non adiacente ad una cella stabile     <div class="image-environment"><div class="image-wrapper spaced-60"><img alt="Immagine" src="../resources/generated-99.png"/></div></div>     Ora, analizzando ogni coppia <i>(stato presente, stato futuro)</i>, segnaliamo eventuali corse (evidenziate in arancione) ed eventuali transizioni multiple (in cui cancelliamo la transizione mettendo direttamente lo stato di destinazione).      <div class="image-environment"><div class="image-wrapper spaced-60"><img alt="Immagine" src="../resources/generated-100.png"/></div></div>     Sono quindi presenti quattro corse:     <ul class="list-container"><li class="list-item">la corsa <span class="math-span">\( 000 \to 101\)</span>. Tale corsa può risolversi nei seguenti modi:         <ul class="list-container"><li class="list-item">cambia prima il bit più significativo (<span class="math-span">\( 000 \to 100\)</span>) e si arriva nello stato <span class="math-span">\( 100\)</span> (che porterebbe allo stato <span class="math-span">\( 101\)</span>). Sarebbe quindi corretto se non fosse per il glith sull'uscita. Questo è un <strong>errore di progettazione</strong>.             </li><li class="list-item">cambia prima il bit meno significativo (<span class="math-span">\( 000 \to 001\)</span>) e si arriva nello stato <span class="math-span">\( 001\)</span> (che porterebbe allo stato <span class="math-span">\( 111\)</span>). Questa è una <strong>corsa critica.</strong></li></ul></li><li class="list-item">la corsa <span class="math-span">\( 010 \to 111\)</span>. Tale corsa può risolversi nei seguenti modi:         <ul class="list-container"><li class="list-item">cambia prima il bit più significativo (<span class="math-span">\( 010 \to 110\)</span>) e si arriva nello stato <span class="math-span">\( 100\)</span> (che porterebbe allo stato <span class="math-span">\( 111\)</span>). È quindi una <strong>corsa non critica</strong> e anche le uscite (che rimangono costanti) non provocano alcun glitch.             </li><li class="list-item">cambia prima il bit meno significativo (<span class="math-span">\( 010 \to 011\)</span>) e si arriva nello stato <span class="math-span">\( 011\)</span> (che porterebbe allo stato <span class="math-span">\( 111\)</span>). È quindi una corsa non critica ma le uscite provocano un glitch. Questo è un <strong>errore di progettazione</strong>.         </li></ul></li><li class="list-item">la corsa <span class="math-span">\( 101 \to 000\)</span>. Tale corsa può risolversi nei seguenti modi:         <ul class="list-container"><li class="list-item">cambia prima il bit più significativo (<span class="math-span">\( 101 \to 001\)</span>) e si arriva nello stato <span class="math-span">\( 001\)</span> (che porterebbe allo stato <span class="math-span">\( 000\)</span>). È quindi una <strong>corsa non critica</strong> ma le uscite provocano un glitch. Questo è un <strong>errore di progettaazione</strong>.             </li><li class="list-item">cambia prima il bit meno significativo (<span class="math-span">\( 101 \to 100\)</span>) e si arriva nello stato <span class="math-span">\( 100\)</span> (che porterebbe allo stato <span class="math-span">\( 000\)</span>). È quindi una <strong>corsa non critica</strong> e anche le uscite (che rimangono costanti) non provocano alcun glitch.         </li></ul></li><li class="list-item">la corsa <span class="math-span">\( 111 \to 010\)</span>. Tale corsa può risolversi nei seguenti modi:         <ul class="list-container"><li class="list-item">cambia prima il bit più significativo (<span class="math-span">\( 111 \to 011\)</span>) e si arriva nello stato <span class="math-span">\( 011\)</span> (che porterebbe allo stato <span class="math-span">\( 010\)</span>). È quindi una <strong>corsa non critica</strong> ma le uscite provocano un glitch. Questo è un <strong>errore di progettaazione</strong>.             </li><li class="list-item">cambia prima il bit meno significativo (<span class="math-span">\( 111 \to 110\)</span>) e si arriva nello stato <span class="math-span">\( 110\)</span> (che porterebbe allo stato <span class="math-span">\( 010\)</span>). È quindi una <strong>corsa non critica</strong> e anche le uscite (che rimangono costanti) non provocano alcun glitch.         </li></ul></li></ul>     A questo punto è possibile eliminare gli stati instabili e porre ad indifferenza le celle irragiungibili a causa di ingressi non adiacenti, ottenendo quindi la tabella     <div class="image-environment"><div class="image-wrapper spaced-60"><img alt="Immagine" src="../resources/generated-101.png"/></div></div>     Ora sarebbe il momento per porre le indifferenze sull'uscita quando tra due stati non è costante. Risulta però più semplice farlo guardando il grafo.     <br/>     Sostituiamo quindi le codifiche degli stati con dei simboli:     <div class="image-environment"><div class="image-wrapper spaced-60"><img alt="Immagine" src="../resources/generated-102.png"/></div></div>     Ora è sufficiente disegnare il grafo degli stati     <div class="image-environment"><div class="image-wrapper spaced-60"><img alt="Immagine" src="../resources/generated-103.png"/></div></div>     A questo punto, poniamo i "<i>don't care</i>" nelle transizioni in cui un bit dell'uscita varia, ottenendo il seguente grafo     <div class="image-environment"><div class="image-wrapper spaced-60"><img alt="Immagine" src="../resources/generated-104.png"/></div></div>     ed è ora possibile aggiungere tali indifferenze anche nella tabella di flusso     <div class="image-environment"><div class="image-wrapper spaced-60"><img alt="Immagine" src="../resources/generated-105.png"/></div></div>     L'analisi è quindi completa. </div></div>
            </article>
            <nav class="buttons-container content-width">
                <a class="navigation-button previous" href="sintesi-di-una-rsa.html" rel="nofollow"><span>Sintesi di una RSA</span></a>
                <a class="navigation-button next" href="../memorie-binarie/index.html" rel="nofollow"><span>Memorie binarie</span></a>
            </nav>
        </section>
        <div class="scroll-to-bottom-button" onclick="scroll_to_bottom()">
            <span class="material-symbols-outlined">
                keyboard_double_arrow_down
            </span>
        </div>
        <footer class="footer-wrapper">
            <div class="copyright-wrapper">
                <span> &copy; Copyright 2023</span> /
                <span>made by lorenzoarlo</span>
            </div>
            /
            <div class="privacy-wrapper">
                <span><a href="https://lorenzoarlo.github.io/privacy-and-cookies/" rel="nofollow">Pannello preferenze cookie</a></span> /
                <span><a href="https://lorenzoarlo.github.io/privacy-and-cookies/privacy-policy.html" rel="nofollow" target="_blank" >Privacy Policy</a></span>
            </div>
        </footer>
    </div>
</body>
</html>