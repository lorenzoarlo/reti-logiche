<!DOCTYPE html>
<html lang="IT">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="stylesheet" href="../styles/style.css" />
    <link rel="stylesheet" href="../styles/index-style.css" />
    <link rel="stylesheet" href="../styles/content-style.css" />
    <link rel="icon" type="image/x-icon" href="../resources/favicon.ico">
    <link rel="apple-touch-icon" href="../resources/favicon.png" />
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-78NHLXDQD8"></script>
    <script src="../scripts/script.js"></script>
    <style>:root { --bg-clr: #ff7f50; --fg-clr: #262626; }</style>
    <meta name="theme-color" content="#ff7f50" />
    <meta name="keywords" content="reti logiche, reti combinatorie, reti sequenziali" />
    <meta name="description" content="Il seguente sito contiene gli appunti e le definizioni del corso 'Reti logiche'.">
    <meta name="robots" content="index">
    <script defer async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <title>Reti logiche - Reti sequenziali asincrone - Sintesi di una RSA</title>
</head>
<body>
    <div class="container">
        <header class="header-wrapper">
            <div class="title-wrapper">
                <span class="title">
                    Reti logiche
                </span>
                <span class="subtitle">
                    by lorenzoarlo
                </span>
            </div>
            <span class="page-title">
                Reti sequenziali asincrone
            </span>
        </header>
        <section class="content-wrapper">
            <h1 class="section-title content-width">Sintesi di una RSA</h1>
            <article class="content-container content-width">
                <div class="definition environment" id="def3-1"><h2 class="environment-title">Definizione - Rete sequenziale</h2><div class="environment-body">     Una rete logica si definisce <strong>sequenziale</strong> se l'uscita non dipende unicamente dagli ingressi correnti, ma dipende anche dalla storia passata e/o dallo scorrere del tempo.     Ciò significa che in presenza di una <strong>stessa configurazione di ingressi</strong> si possono avere più <strong>uscite differenti</strong>.     <br/>     Dato che l'uscita non dipende solo dagli ingressi, è necessario tener conto di un'altra informazione: lo "stato interno".      Per questo, ogni volta che cambiano gli ingressi, la rete, oltre a determinare il valore dell'uscita, dovrà calcolare anche lo stato interno (deve calcolare lo "stato futuro" e sovrascriverlo allo stato presente).     <br/>     Per tenere traccia di questa informazione è necessario utilizzare una memoria. </div></div><div class="definition environment" id="def3-2"><h2 class="environment-title">Definizione - Rete sequenziale asincrona (RSA)</h2><div class="environment-body">     Una <strong>rete sequenziale asincrona</strong> è una rete sequenziale in cui lo <strong>stato presente</strong> è <strong>sovrascritto non appena lo stato futuro è calcolato</strong>.     <br/>     In una RSA quindi, ad ogni istante, sono calcolati:     <ul class="list-container"><li class="list-item"><span class="math-span">\( m\)</span> segnali di uscita della rete;         </li><li class="list-item"><span class="math-span">\( k\)</span> segnali di stato futuro.     </li></ul>     avendo in ingresso     <ul class="list-container"><li class="list-item"><span class="math-span">\( n\)</span> segnali di ingresso;         </li><li class="list-item"><span class="math-span">\( k\)</span> segnali di stato presente.     </li></ul>     Si può quindi considerare una RSA come una rete composta da <span class="math-span">\( m + k\)</span> reti combinatorie, ognuna con <span class="math-span">\( n + k\)</span> ingressi.      Per convenzione si indicano con <span class="math-span">\( F\)</span> le <strong>funzioni che calcolano i bit di uscita</strong> e con <span class="math-span">\( G\)</span> le <strong>funzioni che calcolano i bit di stato futuro</strong>. </div></div><div class="definition environment" id="def3-3"><h2 class="environment-title">Definizione - Memoria in una RSA</h2><div class="environment-body">     Sappiamo che ogni gate reale ha un ritardo di propagazione <span class="math-span">\( \tau_{p}\)</span>: ogni rete è quindi caratterizzata da un segnale ideale che cambia istantaneamente al variare degli ingressi, ed un segnale reale, soggetto al ritardo.     <br/>     Tale ritardo può tuttavia essere visto come memoria del passato e può essere sfruttato collegando i gate in retroazione.     <div class="image-environment"><div class="image-wrapper spaced-50"><img alt="Immagine" src="../resources/circuito-retroazione.png"/></div></div>     Si ha quindi che ogni anello di retroazione fornisce un bit di memoria e, per questo motivo, si ha che una rete con <span class="math-span">\( k\)</span> bit di stato ha <span class="math-span">\( k\)</span> anelli di retroazione. </div></div><div class="definition environment" id="def3-4"><h2 class="environment-title">Definizione - RSA come Finite State Machine (FSM)</h2><div class="environment-body">     Una RSA è quindi un caso particolare di automa (o <strong>macchina a stati finiti</strong>), ovvero un sistema matematico caratterizzato da:     <ul class="list-container"><li class="list-item">un insieme <span class="math-span">\( I\)</span> detto alfabeto di ingresso;         </li><li class="list-item">un insieme <span class="math-span">\( U\)</span> detto alfabeto di uscita;         </li><li class="list-item">un insieme <span class="math-span">\( S\)</span> degli stati;         </li><li class="list-item">una funzione <span class="math-span">\( F: S \times I \to U\)</span> di uscita;         </li><li class="list-item">una funzione <span class="math-span">\( G: S \times I \to S\)</span> di aggiornamento dello stato interno.     </li></ul>     In base alle caratteristiche della funzione <span class="math-span">\( F\)</span> si distingue     <ul class="list-container"><li class="list-item">l'<strong>automa di Mealy</strong>, in cui l'<strong>uscita dipende dallo stato interno e dagli ingressi</strong></li><li class="list-item">l'<strong>automa di Moore</strong>, in cui l'<strong>uscita dipende solo dallo stato interno</strong>.     </li></ul></div></div><div class="definition environment" id="def3-5"><h2 class="environment-title">Definizione - Comportamento di una RSA</h2><div class="environment-body">     Per poter descrivere il comportamento di una RSA non è sufficiente utilizzare una tabella della verità, ma è necessario ricorrere a formalismi come:     <ul class="list-container"><li class="list-item">il <strong>grafo degli stati</strong>;         </li><li class="list-item">la <strong>tabella di flusso</strong>.     </li></ul></div></div><div class="definition environment" id="def3-6"><h2 class="environment-title">Definizione - Grafo degli stati - Automa di Mealy</h2><div class="environment-body">     Il grafo degli stati è un <strong>grafo ad archi orientato</strong> dove:     <ul class="list-container"><li class="list-item">ogni <strong>nodo rappresenta uno stato</strong>;         </li><li class="list-item">ogni <strong>arco rappresenta una transizione</strong> da stato presente a stato futuro in corrispondenza di una o più configurazioni di ingresso;     </li></ul><div class="image-environment"><div class="image-wrapper spaced-40"><img alt="Immagine" src="../resources/generated-55.png"/></div></div>     Per rendere più comprensibili tali grafi, si utilizza anche una tabella in cui sono associati gli identificatori degli stati (<span class="math-span">\( A, B, C, D\)</span>) a delle descrizioni, ovvero     <div class="image-environment"><div class="image-wrapper spaced-30"><img alt="Immagine" src="../resources/generated-56.png"/></div></div>     Un grafo, per essere <strong>completo</strong>, deve prevedere che da ogni nodo escano tanti rami quante sono le configurazioni binarie possibili degli ingressi.     <br/>     Un nodo che prevede almeno un arco che ritorna su di esso è definito <strong>stato stabile</strong>.     <br/>     Un arco proveniente da uno stato in cui l'uscita è diversa da quella dello stato di arrivo (ovvero quando l'uscita cambia) può prevedere come uscita anche il valore di indifferenza ("<span class="math-span">\( -\)</span>") in quanto non è importante che il valore si modifichi qualche istante prima o dopo.      Ciò non può tuttavia avvenire se l'uscita rimane invariata, in quanto causerebbe un "<strong>glitch</strong>".     <br/>     Affinchè una RSA funzioni con continuità, il grafo degli stati deve:     <ul class="list-container"><li class="list-item"><strong>essere strettamente connesso</strong>, ovvero deve esistere sempre almeno un percorso per passare da un qualsiasi nodo all'altro.         </li><li class="list-item"><strong>non contenere nodi irraggiungibili</strong> (o parti di grafo), ovvero dotati di sole frecce uscenti;         </li><li class="list-item"><strong>non contenere nodi assorbenti</strong> (o parti di grafo), ovvero dotati di sole frecce entranti.     </li></ul></div></div><div class="definition environment" id="def3-7"><h2 class="environment-title">Definizione - Grafo degli stati - Automa di Moore</h2><div class="environment-body">     Nel caso si stia descrivendo un automa di Moore (ovvero una macchina a stati a finiti in cui la funzione di uscita dipende solo dallo stato presente e non dagli ingressi),      il grafo degli stati prevede che <strong>in ogni nodo sia riportata anche l'uscita</strong> (e non sopra agli archi), ovvero     <div class="image-environment"><div class="image-wrapper spaced-40"><img alt="Immagine" src="../resources/generated-57.png"/></div></div></div></div><div class="myexample environment" id="example17"><h2 class="environment-title">Esempio - Descrivere il comportamento di una RSA con un grafo a stati - Lampada da tavolo</h2><div class="environment-body">     Una lampada da tavolo (del tipo in cui la lampadina si accende al rilascio di un pulsante se è accesa e si spegne nel caso sia spenta) è una rete sequenziale asincrona.     <br/>     Per disegnare il grafo degli stati teniamo presente che:     <ul class="list-container"><li class="list-item">si ha un ingresso <span class="math-span">\( x\)</span> associato al pulsante: se tale pulsante è premuto l'uscita assume valore <span class="math-span">\( 1\)</span>, altrimenti ha valore <span class="math-span">\( 0\)</span>;         </li><li class="list-item">si ha un'uscita <span class="math-span">\( z\)</span> associata allo stato della lampadina: al valore <span class="math-span">\( 0\)</span> corrisponde la luce spenta, al valore <span class="math-span">\( 1\)</span> la luce accesa.     </li></ul>     Iniziamo quindi considerando lo stato iniziale, ovvero quello in cui la luce è spenta e il pulsante è "in quiete".     <div class="image-environment"><div class="image-wrapper spaced-50"><img alt="Immagine" src="../resources/generated-58.png"/></div></div>     In questa situazione, l'unica cosa che è possibile fare è premere il pulsante, andando in un nuovo stato, ovvero     <div class="image-environment"><div class="image-wrapper spaced-50"><img alt="Immagine" src="../resources/generated-59.png"/></div></div>     Nello stato "A" si possono quindi verificare due eventi:     <ul class="list-container"><li class="list-item">il pulsante rimane non premuto (ovvero si ha "stabilità");         </li><li class="list-item">il pulsante viene premuto (ovvero si transita verso lo stato successivo).     </li></ul>     È possibile quindi descrivere ciò disegnando i seguenti nodi:     <div class="image-environment"><div class="image-wrapper spaced-40"><img alt="Immagine" src="../resources/generated-60.png"/></div></div>     A questo punto è possibile che:     <ul class="list-container"><li class="list-item">il pulsante rimanga premuto (ovvero si ha "stabilità");         </li><li class="list-item">il pulsante viene rilasciato (ovvero si transita verso lo stato successivo) e la luce si accende.     </li></ul>      Nel caso il pulsante venga rilasciato, si verificherebbe una nuova situazione (associata ad un nuovo stato), ovvero     <div class="image-environment"><div class="image-wrapper spaced-50"><img alt="Immagine" src="../resources/generated-61.png"/></div></div>     che può essere rappresentato come     <div class="image-environment"><div class="image-wrapper spaced-40"><img alt="Immagine" src="../resources/generated-62.png"/></div></div>     Iterando questo processo, si può arrivare ad ottenere il seguente grafo     <div class="image-environment"><div class="image-wrapper spaced-50"><img alt="Immagine" src="../resources/generated-63.png"/></div></div><div class="image-environment"><div class="image-wrapper spaced-40"><img alt="Immagine" src="../resources/generated-64.png"/></div></div>     È possibile però notare che lo stato "E" e lo stato "A" coincidono, ed è quindi possibile eliminare lo stato "E" ottenendo il seguente grafo degli stati:     <div class="image-environment"><div class="image-wrapper spaced-50"><img alt="Immagine" src="../resources/generated-65.png"/></div></div><div class="image-environment"><div class="image-wrapper spaced-40"><img alt="Immagine" src="../resources/generated-66.png"/></div></div>     Infine, è possibile notare che nei collegamenti "B-C" e "D-A" l'uscita cambia ed è quindi possibile aggiungere un'indifferenza sull'uscita     <div class="image-environment"><div class="image-wrapper spaced-40"><img alt="Immagine" src="../resources/generated-67.png"/></div></div></div></div><div class="definition environment" id="def3-8"><h2 class="environment-title">Definizione - Stato iniziale (o reset)</h2><div class="environment-body">     Nelle macchine elettroniche non è possibile prevedere il valore dei segnali in retroazione all'accensione: non è possibile quindi avere certezza sullo stato iniziale (e ciò potrebbe determinare un problema).     <br/>     Tipicamente si utilizza quindi un ingresso aggiuntivo per la rete (detto <strong>ingresso di reset</strong>) che segnala quando la macchina si sta accendendo.      Esso, infatti, assume il valore <span class="math-span">\( 1\)</span> solo nei primi istanti di funzionamento (e <span class="math-span">\( 0\)</span> per il tempo restante).     <br/>     Per ottenere quindi un bit di stato iniziale con valore <span class="math-span">\( 0\)</span>, lo si collega (con l'ingresso di reset negato) nel seguente modo:     <div class="image-environment"><div class="image-wrapper spaced-40"><img alt="Immagine" src="../resources/circuito-reset-0.png"/></div></div>     in questo modo si ha che per i primi istanti di funzionamento esso assumerà valore <span class="math-span">\( 0\)</span> andando a "bloccare" l'AND che sarà costretto all'uscita <span class="math-span">\( 0\)</span>. Successivamente, l'ingresso di reset avrà valore <span class="math-span">\( 1\)</span> diventando quindi neutro per l'AND.     <br/>     Similmente, è possibile ottenere come bit di stato iniziale il valore <span class="math-span">\( 1\)</span> collegando l'ingresso di reset (questa volta non negato) nel seguente modo:     <div class="image-environment"><div class="image-wrapper spaced-40"><img alt="Immagine" src="../resources/circuito-reset-1.png"/></div></div>     si ottiene quindi che per i primi istanti il gate OR è costretto all'uscita <span class="math-span">\( 1\)</span> mentre successivamente assume un comportamento di trasparenza. </div></div><div class="definition environment" id="def3-9"><h2 class="environment-title">Definizione - Tabella di flusso - Automa di Mealy</h2><div class="environment-body">     In aggiunta al grafo degli stati, è possibile descrivere il comportamento di una RSA attraverso una tabella di flusso:     <div class="image-environment"><div class="image-wrapper spaced-50"><img alt="Immagine" src="../resources/generated-68.png"/></div></div>     dove <span class="math-span">\( s^{*}\)</span> è lo stato futuro e <span class="math-span">\( z\)</span> è l'uscita.     <br/>     Un esempio reale potrebbe essere il seguente:     <div class="image-environment"><div class="image-wrapper spaced-30"><img alt="Immagine" src="../resources/generated-69.png"/></div></div>     Nelle tabelle di flusso, le <strong>celle cerchiate</strong> indicano <strong>condizioni di stabilità</strong>.     <br/>     È possibile controllare la correttezza formale della rete analizzando la tabella.      Si deve avere infatti che:     <ul class="list-container"><li class="list-item"><strong>ogni riga</strong> deve avere <strong>almeno una condizione di stabilità</strong>;         </li><li class="list-item">ogni <strong>cella instabile</strong> deve "puntare" ad uno <strong>stato stabile</strong> (al fine di evitare transizioni multiple).     </li></ul></div></div><div class="definition environment" id="def3-10"><h2 class="environment-title">Definizione - Tabella di flusso - Automa di Moore</h2><div class="environment-body">     Nel caso si stia descrivendo un automa di Moore, la tabella di flusso prevede delle colonne in più contenenti l'uscita, in quanto si ha che essa dipende solo dallo stato e non dalla configurazione di ingresso.     <div class="image-environment"><div class="image-wrapper spaced-70"><img alt="Immagine" src="../resources/generated-70.png"/></div></div>     Un esempio reale potrebbe essere:     <div class="image-environment"><div class="image-wrapper spaced-40"><img alt="Immagine" src="../resources/generated-71.png"/></div></div></div></div><div class="definition environment" id="def3-11"><h2 class="environment-title">Definizione - Tabella delle transizioni</h2><div class="environment-body">     Codificando i simboli degli stati in codice binario e sostituendoli alla tabella di flusso, si ottiene la <strong>tabella delle transizioni</strong>.     <br/>     Quindi, data la tabella di flusso     <div class="image-environment"><div class="image-wrapper spaced-30"><img alt="Immagine" src="../resources/generated-72.png"/></div></div>     e la codifica degli stati     <div class="image-environment"><div class="image-wrapper spaced-30"><img alt="Immagine" src="../resources/generated-73.png"/></div></div>     si può sostituire al simbolo dello stato la sua codifica e ottenendo la seguente tabella delle transizioni     <div class="image-environment"><div class="image-wrapper spaced-30"><img alt="Immagine" src="../resources/generated-74.png"/></div></div></div></div><div class="definition environment" id="def3-12"><h2 class="environment-title">Definizione - Da tabella delle transizioni a espressioni combinatorie</h2><div class="environment-body">     La tabella delle transizioni può essere anche vista come la <strong>composizione di diverse tabelle della verità</strong>.     <br/>     Ad esempio, alla seguente tabella     <div class="image-environment"><div class="image-wrapper spaced-30"><img alt="Immagine" src="../resources/generated-75.png"/></div></div>     corrispondono le seguenti tabelle della verità (o mappe di Karnaugh):     <ul class="list-container"><li class="list-item">per lo stato futuro <span class="math-span">\( Y_{1}\)</span><div class="image-environment"><div class="image-wrapper spaced-40"><img alt="Immagine" src="../resources/generated-76.png"/></div></div></li><li class="list-item">per lo stato futuro <span class="math-span">\( Y_{0}\)</span><div class="image-environment"><div class="image-wrapper spaced-40"><img alt="Immagine" src="../resources/generated-77.png"/></div></div></li><li class="list-item">per l'uscita <span class="math-span">\( z\)</span><div class="image-environment"><div class="image-wrapper spaced-40"><img alt="Immagine" src="../resources/generated-78.png"/></div></div></li></ul></div></div><div class="definition environment" id="def3-13"><h2 class="environment-title">Definizione - Funzionamento generale di una RSA</h2><div class="environment-body">     Le reti sequenziali asincrone funzionano "<strong>ad inseguimento degli ingressi</strong>" (esattamente come le reti combinatorie), si ha infatti che l'<strong>uscita</strong> e lo <strong>stato interno</strong> si <strong>modificano solo quando cambiano i segnali di ingresso</strong> (e non dipendono dalla durata degli ingressi).      Per questo motivo esse sono soggette ad alee statiche e dinamiche che possono causare diversi problemi, in quanto potrebbero influenzare il calcolo dello stato futuro.     <br/>     Affinchè una RSA funzioni correttamente nel passaggio da una condizione di stabilità all'altra (ovvero nel "funzionamento in modo fondamentale"), è necessario rispettare una serie di condizioni. </div></div><div class="definition environment" id="def3-14"><h2 class="environment-title">Definizione - Vincolo di funzionamento di una RSA - Durata degli ingressi</h2><div class="environment-body">     Come nelle reti combinatorie, anche nelle RSA esiste un <strong>limite alla velocità di funzionamento</strong>.      <br/>     Considerando un tempo <span class="math-span">\( T_{G}\)</span> di ritardo (calcolato come il ritardo massimo dei singoli bit in retroazione), si ha che ogni configurazione deve permanere almeno per      <span class="math-block">\[         (1 + t) \cdot T_{G}         \]</span>     dove <span class="math-span">\( t\)</span> è il numero massimo di transizioni multiple necessarie per raggiungere uno stato stabile.     <br/>     Nel caso quindi che <strong>non si abbiano transizioni multiple</strong>, si ha un caso base di <span class="math-span">\( 2 \cdot T_{G}\)</span> (con <span class="math-span">\( t = 1\)</span>). </div></div><div class="definition environment" id="def3-15"><h2 class="environment-title">Definizione - Vincolo di funzionamento di una RSA - Codifica degli ingressi</h2><div class="environment-body">     Dato che le RSA funzionano ad inseguimento degli ingressi, si pongono i problemi legati alle alee statiche.     <br/>     C<strong>ondizione necessaria per evitare alee statiche</strong> è <strong>non variare più di un bit alla volta da una configurazione di ingressi ad un'altra</strong>.      <br/>     Per questo motivo, si decide di "vietare" nell'uso (e quindi ignorare nella progettazione) tutte le configurazioni di ingresso che differiscono di più di un bit dalla condizione di stabilità.     <br/>     Prendiamo per esempio il seguente grafo degli stati:     <div class="image-environment"><div class="image-wrapper spaced-50"><img alt="Immagine" src="../resources/generated-79.png"/></div></div>     Considerando i vincoli sulle configurazioni degli ingressi, si ottiene il seguente grafo     <div class="image-environment"><div class="image-wrapper spaced-50"><img alt="Immagine" src="../resources/generated-80.png"/></div></div>     ovvero si sono eliminate tutte le configurazioni che differiscono di più di un bit dalla "configurazione di stabilità". </div></div><div class="definition environment" id="def3-16"><h2 class="environment-title">Definizione - Vincolo di funzionamento di una RSA - Evitare le alee statiche negli anelli di retroazione</h2><div class="environment-body">     Mentre per le reti combinatorie le alee statiche non risultano essere molto dannose, per le RSA sono invece un punto critico in quanto potrebbero portare a stati che "rompono" il "giusto flusso".     <br/>     Si ha quindi che, oltre a rispettare il vincolo di variare un bit alla volta nelle configurazioni di ingresso, è necessario effettuare la sintesi delle reti che calcolano lo stato futuro raggruppando tutte le celle adiacenti (con lo stesso valore) in almeno un raggruppamento (sempre di dimensione massima), ovvero si devono considerare tutti gli implicanti (o implicati) primi. </div></div><div class="definition environment" id="def3-17"><h2 class="environment-title">Definizione - Vincolo di funzionamento di una RSA - Codifica degli stati</h2><div class="environment-body">     Dato che i bit di stato presente risultano essere a tutti gli effetti degli ingressi per la rete, è necessario adottare vincoli simili a quelli adottati per le configurazioni di ingresso.     <br/>     È necessario infatti che le configurazioni binarie associate ad ogni coppia <i>(stato presente, stato futuro)</i> siano adiacenti (ovvero devono variare di massimo un bit).      Non è tuttavia sempre necessario adottare tale accorgimento (anche perchè sarebbe eccessivamente esoso in termini di bit utilizzati) ma solo per evitare le cosiddette "corse critiche".  </div></div><div class="definition environment" id="def3-18"><h2 class="environment-title">Definizione - Grafo delle adiacenze</h2><div class="environment-body">     Il <strong>grafo delle adiacenze</strong> è un <strong>formalismo grafico utile per codificare correttamente gli stati di una rete</strong>.      Esso non è altro che una griglia con ai margini il codice di Gray (utile per evitare transizioni da uno stato all'altro in cui variano più di un bit) dove:     <ul class="list-container"><li class="list-item">ogni cella identificata da un codice è uno stato;         </li><li class="list-item">da un nodo all'altro sono presenti degli archi orientati che indicano relazioni <i>(stato presente, stato futuro)</i>.     </li></ul>     Affinchè la codifica possa considerarsi corretta si ha che gli archi orientati devono "collegare" solo nodi adiacenti (con le stesse regole di adiacenza delle mappe di Karnaugh).      <br/>     Ad esempio, un grafo che codifica <span class="math-span">\( 3\)</span> bit di stato potrà essere così composto:     <div class="image-environment"><div class="image-wrapper spaced-40"><img alt="Immagine" src="../resources/generated-81.png"/></div></div></div></div><div class="definition environment" id="def3-19"><h2 class="environment-title">Definizione - Corse critiche e non critiche</h2><div class="environment-body">     Quando si prevede che due segnali in retroazione devono <strong>modificarsi contemporaneamente</strong> (ovvero le due configurazioni non sono adiacenti) si dice che sono in "<strong>corsa</strong>".     <br/>     Una <strong>corsa</strong> si definisce <strong>critica</strong> se è possibile <strong>raggiungere stati di stabilità diverse</strong> (in base a quale bit cambia per primo).     Se ciò non avviene e la rete attraversa transizioni multiple fino a raggiungere la giusta stabilità, la <strong>corsa</strong> si definisce <strong>non critica</strong>.     <br/>     Una <strong>corsa non critica</strong> non risulta essere un problema se:     <ul class="list-container"><li class="list-item">durante la transizione l'<strong>uscita non varia</strong>;         </li><li class="list-item">gli <strong>ingressi rimangono invariati fino</strong> al raggiungimento della <strong>stabilità</strong>.     </li></ul><div class="mynote environment"><h3 class="environment-title">Osservazioni personali - Ad esempio</h3><div class="environment-body">         Consideriamo ad esempio la seguente tabella delle transizioni in cui non si considera (per semplicità) l'uscita         <div class="image-environment"><div class="image-wrapper spaced-50"><img alt="Immagine" src="../resources/generated-82.png"/></div></div>         Ipotizziamo di trovarci nello stato <span class="math-span">\( B=01\)</span> con la configurazione di ingressi <span class="math-span">\( 01\)</span>.          Nel caso fosse inserita la configurazione <span class="math-span">\( 11\)</span> si avrebbe come stato futuro previsto <span class="math-span">\( D=10\)</span> in cui variano entrambi i bit.         Dato che si è detto che è impossibile che due bit cambino contemporaneamente, si potrebbero generare le seguenti situazioni:         <ul class="list-container"><li class="list-item">varia prima il primo bit, ovvero si avrebbe come stato futuro lo stato <span class="math-span">\( C=11\)</span> che prevede, con la configurazione di ingresso <span class="math-span">\( 11\)</span> una stabilità nello stato <span class="math-span">\( C=11\)</span>;             </li><li class="list-item">varia prima il secondo bit, ovvero si avrebbe come stato futuro lo stato <span class="math-span">\( A=00\)</span> che prevede, con la configurazione di ingresso <span class="math-span">\( 11\)</span> una stabilità nello stato <span class="math-span">\( A=00\)</span>.         </li></ul>         Si avrebbero quindi due stati non previsti e si otterrebbe un comportamento indesiderato. Questo è un <strong>esempio di corsa critica</strong>.         <br/>         Ipotizzando invece di trovarci nello stato <span class="math-span">\( C=11\)</span> con la configurazione di ingressi <span class="math-span">\( 01\)</span>. Nel caso fosse inserita la configurazione <span class="math-span">\( 00\)</span> si avrebbe come stato futuro previsto <span class="math-span">\( A=00\)</span> in cui variano entrambi i bit.         Dato che si è detto che è impossibile che due bit cambino contemporaneamente, si potrebbero generare le seguenti situazioni:         <ul class="list-container"><li class="list-item">varia prima il primo bit, ovvero si avrebbe come stato futuro lo stato <span class="math-span">\( B=01\)</span> che prevede, con la configurazione di ingresso <span class="math-span">\( 00\)</span> una transizione verso lo stato <span class="math-span">\( A=00\)</span> (ovvero lo stato previsto);             </li><li class="list-item">varia prima il secondo bit, ovvero si avrebbe come stato futuro lo stato <span class="math-span">\( D=10\)</span> che prevede, con la configurazione di ingresso <span class="math-span">\( 00\)</span> una transizione verso lo stato <span class="math-span">\( A=00\)</span> (ovvero lo stato previsto).         </li></ul>         In entrambe le strade quindi si ottiene un comportamento accettabile. Questo è un esempio di <strong>corsa non critica</strong>.     </div></div>     Si hanno corse critiche solo nei casi in cui una colonna della tabella di flusso contenga più di uno stato stabile (con un solo stato stabile, infatti, si avrebbero una serie di transizioni multiple che raggiungerebbero prima o poi lo stato stabile, in quanto non cambiano gli ingressi).     Si può quindi procedere nel seguente modo per progettare correttamente le reti sequenziali.      Data la tabella di flusso:     <ul class="list-container"><li class="list-item">nelle colonne che presentano una sola stabilità e presentano delle indifferenze, si <strong>sostituiscono tutte le indifferenze con lo stato stabile per quella colonna</strong>. Ipotizzando quindi di avere la seguente tabella         <div class="image-environment"><div class="image-wrapper spaced-50"><img alt="Immagine" src="../resources/generated-83.png"/></div></div>         si sostituiscono le indifferenze con lo stato stabile per la colonna, ovvero         <div class="image-environment"><div class="image-wrapper spaced-50"><img alt="Immagine" src="../resources/generated-84.png"/></div></div></li><li class="list-item">per le colonne che presentano più di una stabilità si <strong>traccia un grafo delle adiacenze</strong> composto da <span class="math-span">\( 2^{n}\)</span> celle, dove <span class="math-span">\( n\)</span> è il numero minimo di bit per rappresentare gli stati, nel caso della precedente tabelle transizioni si avrebbe il seguente grafo         <div class="image-environment"><div class="image-wrapper spaced-30"><img alt="Immagine" src="../resources/generated-85.png"/></div></div></li><li class="list-item">nel caso esistano relazioni tra celle non adiacenti, è possibile <strong>spostare le celle fino a raggiungere un grafo corretto</strong><div class="image-environment"><div class="image-wrapper spaced-30"><img alt="Immagine" src="../resources/generated-86.png"/></div></div></li><li class="list-item"><strong>nel caso esistano "celle vuote"</strong> nel grafo delle adiacenze, è possibile sfruttarle per realizzare transizioni multiple;         </li><li class="list-item"><strong>si verifica che le corse presenti siano "critiche"</strong>: nel caso non lo siano la codifica è corretta, altrimenti si cerca di modificare la tabella di flusso sfruttando la stessa colonna del "collegamento" che crea problemi.          Nel caso nella stessa colonna esiste uno stato che porta allo stato futuro desiderato (con gli stessi ingressi dato che ci stiamo concentrando sulla stessa colonna) si cerca di passare per questo stato.          Ad esempio, ipotizzando di avere la seguente tabella di flusso:         <div class="image-environment"><div class="image-wrapper spaced-50"><img alt="Immagine" src="../resources/generated-87.png"/></div></div>         che equivale al seguente grafo         <div class="image-environment"><div class="image-wrapper spaced-30"><img alt="Immagine" src="../resources/generated-88.png"/></div></div>         si ha che nella colonna della cella che indica la transizione critica, ovvero         <div class="image-environment"><div class="image-wrapper spaced-50"><img alt="Immagine" src="../resources/generated-89.png"/></div></div>         vi è anche lo stato <span class="math-span">\( A\)</span> (che è adiacente allo stato <span class="math-span">\( B\)</span>) che con la configurazione <span class="math-span">\( 11\)</span> si "dirige" verso lo stato <span class="math-span">\( C\)</span>.          È quindi possibile modificare la tabella di flusso ed il grafo delle adiacenze nel seguente modo:         <div class="image-environment"><div class="image-wrapper spaced-50"><img alt="Immagine" src="../resources/generated-90.png"/></div></div>         che equivale a         <div class="image-environment"><div class="image-wrapper spaced-30"><img alt="Immagine" src="../resources/generated-91.png"/></div></div></li><li class="list-item">nel caso il grafo non sia ancora corretto, <strong>si aggiunge un bit per codificare lo stato</strong>.     </li></ul></div></div>
            </article>
            <nav class="buttons-container content-width">
                <a class="navigation-button previous" href="index.html" rel="nofollow"><span>Reti sequenziali asincrone</span></a>
                <a class="navigation-button next" href="analisi-di-una-rsa.html" rel="nofollow"><span>Analisi di una RSA</span></a>
            </nav>
        </section>
        <div class="scroll-to-bottom-button" onclick="scroll_to_bottom()">
            <span class="material-symbols-outlined">
                keyboard_double_arrow_down
            </span>
        </div>
        <footer class="footer-wrapper">
            <div class="copyright-wrapper">
                <span> &copy; Copyright 2023</span> /
                <span>made by lorenzoarlo</span>
            </div>
            /
            <div class="privacy-wrapper">
                <span><a href="https://lorenzoarlo.github.io/privacy-and-cookies/" rel="nofollow">Pannello preferenze cookie</a></span> /
                <span><a href="https://lorenzoarlo.github.io/privacy-and-cookies/privacy-policy.html" rel="nofollow" target="_blank" >Privacy Policy</a></span>
            </div>
        </footer>
    </div>
</body>
</html>