<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="stylesheet" href="../styles/style.css" />
    <link rel="stylesheet" href="../styles/index-style.css" />
    <link rel="stylesheet" href="../styles/content-style.css" />
    <link rel="icon" type="image/x-icon" href="../resources/favicon.ico">
    <link rel=”apple-touch-icon” href=”../resources/favicon.ico” />
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-78NHLXDQD8"></script>
    <script src="../scripts/script.js"></script>
    <style>:root { --bg-clr: #ff7f50; --fg-clr: #262626; }</style>
    <meta name="theme-color" content="#ff7f50" />
    <meta name="keywords" content="reti logiche, reti combinatorie, reti sequenziali" />
    <meta name="description" content="Il seguente sito contiene gli appunti e le definizioni del corso 'Reti logiche'.">
    <meta name="robots" content="index">
    <script defer async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <title>Reti logiche - Reti sequenziali asincrone - Vincoli per il corretto funzionamento di una RSA</title>
</head>
<body>
    <div class="container">
        <header class="header-wrapper">
            <div class="title-wrapper">
                <span class="title">
                    Reti logiche
                </span>
                <span class="subtitle">
                    by lorenzoarlo
                </span>
            </div>
            <span class="page-title">
                Reti sequenziali asincrone
            </span>
        </header>
        <section class="content-wrapper">
            <h1 class="section-title content-width">Vincoli per il corretto funzionamento di una RSA</h1>
            <article class="content-container content-width">
                <div class="definition environment" id="def4-18"><h2 class="environment-title">Definizione - Funzionamento generale di una RSA</h2><div class="environment-body">     Le reti sequenziali asincrone funzionano "ad inseguimento degli ingressi" (esattamente come le reti combinatorie ), si ha infatti che l'uscita e lo stato interno si modificano solo quando cambiano i segnali di ingresso (e non dipendono dalla durata degli ingressi).      Per questo motivo esse sono soggette ad alee statiche e dinamiche.     <br/>     Affinchè una RSA funzioni correttamente nel passaggio da una condizione di stabilità all'altra (ovvero nel "funzionamento in modo fondamentale"), è necessario rispettare una serie di condizioni. </div></div><div class="definition environment" id="def4-19"><h2 class="environment-title">Definizione - Vincolo di funzionamento di una RSA - Durata degli ingressi</h2><div class="environment-body">     Come nelle reti combinatorie, anche nelle RSA esiste un limite alla velocità di funzionamento di una RSA.      <br/>     Considerando un tempo <span class="math-span">\( T_{G}\)</span> di ritardo (calcolato come il ritardo massimo dei singoli bit in retroazione), si ha che ogni configurazione deve permanere almeno per      <span class="math-block">\[         (1 + t) \cdot T_{G}         \]</span>     dove <span class="math-span">\( t\)</span> è il numero massimo di transizioni multiple necessarie per raggiungere uno stato stabile.     <br/>     Nel caso quindi che non si abbiano transizioni multiple, si ha un caso base di <span class="math-span">\( 2 \cdot T_{G}\)</span> (con <span class="math-span">\( t = 1\)</span>).      </div></div><div class="definition environment" id="def4-20"><h2 class="environment-title">Definizione - Vincolo di funzionamento di una RSA - Codifica degli ingressi</h2><div class="environment-body">     Dato che le RSA funzionano ad inseguimento degli ingressi, si pongono i problemi legati alle alee statiche.     <br/>     Condizione necessaria per evitare alee statiche è non variare più di un bit alla volta da una configurazione di ingressi ad un'altra.      <br/>     Per questo motivo, si decide di "vietare" tutte le configurazioni di ingresso che differiscono di più di un bit dalla condizione di stabilità.     <br/>     Prendiamo per esempio il seguente grafo degli stati:     <div class="image-environment"><div class="image-wrapper spaced-50"><img alt="Immagine" src="../resources/generated-77.png"/></div></div>     Considerando i vincoli sulle configurazioni degli ingressi, si ottiene il seguente grafo     <div class="image-environment"><div class="image-wrapper spaced-50"><img alt="Immagine" src="../resources/generated-78.png"/></div></div>     ovvero si sono eliminate tutte le configurazioni che differiscono di più di un bit dalla "configurazione di stabilità". </div></div><div class="definition environment" id="def4-21"><h2 class="environment-title">Definizione - Vincolo di funzionamento di una RSA - Evitare le alee statiche negli anelli di retroazione</h2><div class="environment-body">     Mentre per le reti combinatorie le alee statiche non risultano essere molto dannose, per le RSA sono invece un punto critico per le RSA in quanto potrebbero portare a stati che "rompono" il "giusto flusso".     <br/>     Si ha quindi che, oltre a rispettare il vincolo di variare un bit alla volta nelle configurazioni di ingresso, è necessario effettuare la sintesi delle reti che calcolano lo stato futuro raggruppando tutte le celle adiacenti (con lo stesso valore) in almeno un raggruppamento (sempre di dimensione massima). </div></div><div class="definition environment" id="def4-22"><h2 class="environment-title">Definizione - Vincolo di funzionamento di una RSA - Codifica degli stati</h2><div class="environment-body">     Dato che i bit di stato presente risultano essere a tutti gli effetti degli ingressi per la rete, è necessario adottare vincoli simili a quelli adottati per le configurazioni di ingresso.     <br/>     Sarebbe necessario infatti che le configurazioni binarie associate ad ogni coppia <i>(stato presente, stato futuro)</i> devono essere adiacenti (ovvero devono variare di massimo un bit). Non è tuttavia sempre necessario adottare tale accorgimento (anche perchè sarebbe eccessivamente esoso in termini di bit utilizzati) ma solo per evitare le cosiddette "corse critiche".  </div></div><div class="definition environment" id="def4-23"><h2 class="environment-title">Definizione - Grafo delle adiacenze</h2><div class="environment-body">     Il grafo delle adiacenze è un formalismo grafico utile per codificare correttamente gli stati di una rete. Esso non è altro che una griglia con ai margini il codice di Gray (utile per evitare transizioni da uno stato all'altro in cui variano più di un bit) dove:     <ul class="list-container"><li class="list-item">ogni cella identificata da un codice è uno stato;         </li><li class="list-item">da un nodo all'altro sono presenti degli archi orientati che indicano relazioni <i>(stato presente, stato futuro)</i>.     </li></ul>     Affinchè la codifica possa considerarsi corretta si ha che gli archi orientati possono "collegare" solo nodi adiacenti (con le stesse regole di adiacenza delle mappe di Karnaugh).      <br/>     Ad esempio, un grafo che codifica <span class="math-span">\( 3\)</span> bit di stato potrà essere così composto:     <div class="image-environment"><div class="image-wrapper spaced-40"><img alt="Immagine" src="../resources/generated-79.png"/></div></div></div></div><div class="definition environment" id="def4-24"><h2 class="environment-title">Definizione - Corse critiche e non critiche</h2><div class="environment-body">     Quando si prevede che due segnali in retroazione devono modificarsi contemporaneamente (ovvero le due configurazioni non sono adiacenti) si dice che sono in "corsa".     <br/>     Una corsa si definisce critica se è possibile raggiungere stati di stabilità diverse (in base a quale bit cambia per primo). Se ciò non avviene e la rete attraversa transizioni multiple fino a raggiungere la giusta stabilità, la corsa si definisce non critica.     <br/>     Una corsa non critica non risulta essere un problema se:     <ul class="list-container"><li class="list-item">durante la transizione l'uscita non varia;         </li><li class="list-item">gli ingressi rimangono invariati fino al raggiungimento della stabilità.     </li></ul><div class="mynote environment"><h3 class="environment-title">Osservazioni personali - Ad esempio</h3><div class="environment-body">         Consideriamo ad esempio la seguente tabella delle transizioni in cui non si considera (per semplicità) l'uscita         <div class="image-environment"><div class="image-wrapper spaced-50"><img alt="Immagine" src="../resources/generated-80.png"/></div></div>         Ipotizziamo di trovarci nello stato <span class="math-span">\( B=01\)</span> con la configurazione di ingressi <span class="math-span">\( 01\)</span>. Nel caso fosse inserita la configurazione <span class="math-span">\( 11\)</span> si avrebbe come stato futuro previsto <span class="math-span">\( D=10\)</span> in cui variano entrambi i bit.         Dato che si è detto che è impossibile che due bit cambino contemporaneamente, si potrebbero generare le seguenti situazioni:         <ul class="list-container"><li class="list-item">varia prima il primo bit, ovvero si avrebbe come stato futuro lo stato <span class="math-span">\( C=11\)</span> che prevede, con la configurazione di ingresso <span class="math-span">\( 11\)</span> una stabilità nello stato <span class="math-span">\( C=11\)</span>;             </li><li class="list-item">varia prima il secondo bit, ovvero si avrebbe come stato futuro lo stato <span class="math-span">\( A=00\)</span> che prevede, con la configurazione di ingresso <span class="math-span">\( 11\)</span> una stabilità nello stato <span class="math-span">\( A=00\)</span>.         </li></ul>         Si avrebbero quindi due stati non previsti e si otterrebbe un comportamento indesiderato. Questo è un esempio di corsa critica.         <br/>         Ipotizzando invece di trovarci nello stato <span class="math-span">\( C=11\)</span> con la configurazione di ingressi <span class="math-span">\( 01\)</span>. Nel caso fosse inserita la configurazione <span class="math-span">\( 00\)</span> si avrebbe come stato futuro previsto <span class="math-span">\( A=00\)</span> in cui variano entrambi i bit.         Dato che si è detto che è impossibile che due bit cambino contemporaneamente, si potrebbero generare le seguenti situazioni:         <ul class="list-container"><li class="list-item">varia prima il primo bit, ovvero si avrebbe come stato futuro lo stato <span class="math-span">\( B=01\)</span> che prevede, con la configurazione di ingresso <span class="math-span">\( 00\)</span> una transizione verso lo stato <span class="math-span">\( A=00\)</span> (ovvero lo stato previsto);             </li><li class="list-item">varia prima il secondo bit, ovvero si avrebbe come stato futuro lo stato <span class="math-span">\( D=10\)</span> che prevede, con la configurazione di ingresso <span class="math-span">\( 00\)</span> una transizione verso lo stato <span class="math-span">\( A=00\)</span> (ovvero lo stato previsto).         </li></ul>         In entrambe le strade quindi si ottiene un comportamento accettabile. Questo è un esempio di corsa non critica.     </div></div>     Si hanno corse critiche solo nei casi in cui una colonna della tabella di flusso contengano più di uno stato stabile (con un solo stato stabile, infatti, si avrebbero una serie di transizioni multiple che raggiungerebbero prima o poi lo stato stabile, in quanto non cambiano gli ingressi).     Si può quindi procedere nel seguente modo per progettare correttamente le reti sequenziali. Data la tabella di flusso:     <ul class="list-container"><li class="list-item">nelle colonne che presentano una sola stabilità e presentano delle indifferenze, si sostituiscono tutte le indifferenze con lo stato stabile per quella colonna. Ipotizzando quindi di avere la seguente tabella         <div class="image-environment"><div class="image-wrapper spaced-50"><img alt="Immagine" src="../resources/generated-81.png"/></div></div>         si sostituiscono le indifferenze con lo stato stabile per la colonna, ovvero         <div class="image-environment"><div class="image-wrapper spaced-50"><img alt="Immagine" src="../resources/generated-82.png"/></div></div></li><li class="list-item">per le colonne che presentano più di una stabilità si traccia un grafo delle adiacenze composto da <span class="math-span">\( 2^{n}\)</span> celle, dove <span class="math-span">\( n\)</span> è il numero minimo di bit per rappresentare gli stati, nel caso della precedente tabelle transizioni si avrebbe il seguente grafo         <div class="image-environment"><div class="image-wrapper spaced-30"><img alt="Immagine" src="../resources/generated-83.png"/></div></div></li><li class="list-item">nel caso esistano relazioni tra celle non adiacenti, è possibile spostare le celle fino a raggiungere un grafo corretto         <div class="image-environment"><div class="image-wrapper spaced-30"><img alt="Immagine" src="../resources/generated-84.png"/></div></div></li><li class="list-item">nel caso esistano "celle vuote" nel grafo delle adiacenze, è possibile sfruttarle per realizzare transizioni multiple;         </li><li class="list-item">si verifica che le corse presenti siano "critiche", nel caso non lo siano la codifica è corretta, altrimenti si cerca di modificare la tabella di flusso sfruttando la stessa colonna del "collegamento" che crea problemi: nel caso nella stessa colonna esiste uno stato che porta allo stato futuro desiderato (con gli stessi ingressi dato che ci stiamo concentrando nella stessa colonna) si cerca di passare per questo stato. Ad esempio, ipotizzando di avere la seguente tabella di flusso:         <div class="image-environment"><div class="image-wrapper spaced-50"><img alt="Immagine" src="../resources/generated-85.png"/></div></div>         che equivale al seguente grafo         <div class="image-environment"><div class="image-wrapper spaced-30"><img alt="Immagine" src="../resources/generated-86.png"/></div></div>         si ha che nella colonna della cella che indica la transizione critica, ovvero         <div class="image-environment"><div class="image-wrapper spaced-50"><img alt="Immagine" src="../resources/generated-87.png"/></div></div>         vi è anche lo stato <span class="math-span">\( A\)</span> (che è adiacente allo stato <span class="math-span">\( B\)</span>) che con la configurazione <span class="math-span">\( 11\)</span> si "dirige" verso lo stato <span class="math-span">\( C\)</span>. È quindi possibile modificare la tabella di flusso ed il grafo delle adiacenze nel seguente modo:         <div class="image-environment"><div class="image-wrapper spaced-50"><img alt="Immagine" src="../resources/generated-88.png"/></div></div>         che equivale a         <div class="image-environment"><div class="image-wrapper spaced-30"><img alt="Immagine" src="../resources/generated-89.png"/></div></div></li><li class="list-item">nel caso il grafo non sia ancora corretto, si aggiunge un bit per codificare lo stato.     </li></ul></div></div>
            </article>
            <nav class="buttons-container content-width">
                <a class="navigation-button previous" href="comportamenti-in-transitorio.html" rel="nofollow"><span>Comportamenti in transitorio</span></a>
                <a class="navigation-button next" href="analisi-di-una-rsa.html" rel="nofollow"><span>Analisi di una RSA</span></a>
            </nav>
        </section>
        <div class="scroll-to-bottom-button" onclick="scroll_to_bottom()">
            <span class="material-symbols-outlined">
                keyboard_double_arrow_down
            </span>
        </div>
        <footer class="footer-wrapper">
            <div class="copyright-wrapper">
                <span> &copy; Copyright 2023</span> /
                <span>made by lorenzoarlo</span>
            </div>
            /
            <div class="privacy-wrapper">
                <span><a href="https://lorenzoarlo.github.io/privacy-and-cookies/" rel="nofollow">Pannello preferenze cookie</a></span> /
                <span><a href="https://lorenzoarlo.github.io/privacy-and-cookies/privacy-policy.html" rel="nofollow" target="_blank" >Privacy Policy</a></span>
            </div>
        </footer>
    </div>
</body>
</html>