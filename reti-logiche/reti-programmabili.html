<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="stylesheet" href="../styles/style.css" />
    <link rel="stylesheet" href="../styles/index-style.css" />
    <link rel="stylesheet" href="../styles/content-style.css" />
    <link rel="icon" type="image/x-icon" href="../resources/favicon.ico">
    <script src="../scripts/script.js"></script>
    <style>:root { --bg-clr: #ff7f50; --fg-clr: #262626; }</style>
    <meta name="theme-color" content="#ff7f50" />
    <meta name="keywords" content="reti logiche, reti combinatorie, reti sequenziali" />
    <meta name="description" content="Il seguente sito contiene gli appunti e le definizioni del corso 'Reti logiche'.">
    <meta name="robots" content="index">
    <script defer async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <title>Reti logiche - Reti logiche - Reti programmabili</title>
</head>
<body>
    <div class="container">
        <header class="header-wrapper">
            <div class="title-wrapper">
                <span class="title">
                    Reti logiche
                </span>
                <span class="subtitle">
                    by lorenzoarlo
                </span>
            </div>
            <span class="page-title">
                Reti logiche
            </span>
        </header>
        <section class="content-wrapper">
            <h1 class="section-title">Reti programmabili</h1>
            <article class="content-container content-width">
                <div class="definition environment" id="def2-44">
 <h2 class="environment-title">
  Definizione -
  Perchè nascono le reti programmabili?
 </h2>
 <div class="environment-body">
  Con l'avvento della VLSI ("
  <i>
   Very Large Scale Integration
  </i>
  ") (che comprende milioni di gate all'interno dello stesso chip e quindi costi alti per la progettazione), si rende necessaria la possibilità di programmazione per permettere di ammortizzare i costi.
 </div>
</div>
<div class="definition environment" id="def2-45">
 <h2 class="environment-title">
  Definizione -
  Memoria
 </h2>
 <div class="environment-body">
  Una memoria non è altro che la realizzazione circuitale di un array: è, infatti, una lista di dati indicizzabile con un intero (l'indirizzo).
  <br/>
  Anche una tabella della verità può essere vista (logicamente) come una memoria immutabile: in base al valore degli
  <span class="math-span">
   \( n\)
  </span>
  bit d'ingresso, essa restituisce una delle
  <span class="math-span">
   \( 2^{n}\)
  </span>
  possibili uscite.
 </div>
</div>
<div class="definition environment" id="def2-46">
 <h2 class="environment-title">
  Definizione -
  Rete combinatoria programmabile
 </h2>
 <div class="environment-body">
  Una rete combinatoria programmabile è una rete in grado di presentare diverse relazioni ingresso/uscita selezionabili tramite la configurazione di segnali interni detti bit di programmazione (una memoria immutabile).
  <br/>
  <div class="image-environment">
   <div class="image-wrapper spaced-50">
    <img alt="Immagine" src="../resources/rete-comb-prog.png"/>
   </div>
  </div>
  Si ha quindi che
  <span class="math-block">
   \[         z_{i} = F(p_{1}, \ldots, p_{y}, x_{1}, \ldots, x_{n})       \]
  </span>
  o, più sinteticamente
  <span class="math-block">
   \[         z_{i} = F_{p}(x_{1}, \ldots, x_{n})       \]
  </span>
  <div class="mynote environment">
   <h3 class="environment-title">
    Osservazioni personali -
    E il multiplexer?
   </h3>
   <div class="environment-body">
    Il principio di funzionamento è analogo a quello del multiplexer: in esso, tuttavia, i bit di programmazione provengono da segnali
    <strong>
     esterni
    </strong>
    .
   </div>
  </div>
 </div>
</div>
<div class="definition environment" id="def2-47">
 <h2 class="environment-title">
  Definizione -
  Memorie ROM
 </h2>
 <div class="environment-body">
  Le memorie ROM ("Read Only Memory") sono memorie non modificabili, ovvero circuiti in cui ad ogni indirizzo corrisponde un dato fissato.
  <br/>
  Consideriamo ad esempio la seguente memoria
  <div class="image-environment">
   <div class="image-wrapper spaced-30">
    <img alt="Immagine" src="../resources/generated-46.png"/>
   </div>
  </div>
  in cui sono memorizzati
  <span class="math-span">
   \( 4\)
  </span>
  Byte, indirizzati da
  <span class="math-span">
   \( 2\)
  </span>
  bit di indirizzi.
  <br/>
  La stessa tabella può però essere vista anche nel seguente modo
  <div class="image-environment">
   <div class="image-wrapper spaced-60">
    <img alt="Immagine" src="../resources/generated-47.png"/>
   </div>
  </div>
  ovvero un generatore di funzioni combinatorie.
 </div>
</div>
<div class="definition environment" id="def2-48">
 <h2 class="environment-title">
  Definizione -
  Realizzazione di memorie ROM
 </h2>
 <div class="environment-body">
  Per realizzare una ROM si considera ogni uscita come una funzione diversa: ognuna sarà quindi idealmente realizzata nel seguente modo:
  <ul class="list-container">
   <li class="list-item">
    si utilizza un decoder per avere a disposizione ogni possibile mintermine;
   </li>
   <li class="list-item">
    si utilizza un gate OR che può essere collegato ad ognuno di questi mintermini;
   </li>
   <li class="list-item">
    in base alla funzione che si vuole realizzare, si collegherà o meno ogni mintermine (fisicamente equivale a chiudere o lasciare aperto un contatto).
   </li>
  </ul>
  Si ha quindi una rete programmabile in grado di realizzare una qualsiasi funzione combinatoria.
  <br/>
  La programmazione è quindi realizzata internamente (segnali interni) e non tramite degli ingressi (si evita quindi di avere un numero sempre maggiore di ingressi).
  <br/>
  Proprio per questo motivo si ha che lo stato di tali contatti sono "decisi" dal costruttore su ordine dell'acquirente. Proprio per questa caratteristica (essere OTP ("
  <i>
   One Time Programmable
  </i>
  ")) sono utili per la memorizzazione di informazioni che non cambiano durante il funzionamento (come il BIOS del PC)
 </div>
</div>
<div class="definition environment" id="def2-49">
 <h2 class="environment-title">
  Definizione -
  Descrizione di una ROM
 </h2>
 <div class="environment-body">
  Si dice quindi che una ROM
  <span class="math-span">
   \( 2^{n} \times k\)
  </span>
  è una ROM che:
  <ul class="list-container">
   <li class="list-item">
    che può memorizzare
    <span class="math-span">
     \( 2^{n}\)
    </span>
    dati;
   </li>
   <li class="list-item">
    ogni dato è grande
    <span class="math-span">
     \( k\)
    </span>
    bit;
   </li>
   <li class="list-item">
    è indirizzata tramite
    <span class="math-span">
     \( n\)
    </span>
    bit (ovvero l'indirizzo è fatto di
    <span class="math-span">
     \( n\)
    </span>
    bit).
   </li>
  </ul>
 </div>
</div>
<div class="myexample environment" id="example13">
 <h2 class="environment-title">
  Esempio -
  Esercizio ROM - Autovelox
 </h2>
 <div class="environment-body">
  Si vuole progettare una rete combinatoria che realizza una parte del comportamento di un autovelox a due fotocellule. Tale rete è così caratterizzata:
  <ul class="list-container">
   <li class="list-item">
    un bus in ingresso che riceve il tempo (in millisecondi) trascorso tra l'attivazione della prima e della seconda fotocellula;
   </li>
   <li class="list-item">
    un segnale AUTO in ingresso che indica se il veicolo è un automobile o un TIR;
   </li>
   <li class="list-item">
    un'uscita FOTO;
   </li>
   <li class="list-item">
    una ROM da
    <span class="math-span">
     \( 4 \ KB\)
    </span>
    che realizza una funzione che trasforma i millisecondi in una velocità in
    <span class="math-span">
     \( km/h\)
    </span>
    e attiva l'uscita FOTO se:
    <ul class="list-container">
     <li class="list-item">
      la velocità è maggiore o uguale di
      <span class="math-span">
       \( 128 \ km/h\)
      </span>
      ed è un auto;
     </li>
     <li class="list-item">
      la velocità è maggiore o uguale di
      <span class="math-span">
       \( 64 \ km/h\)
      </span>
      ed è un TIR.
     </li>
    </ul>
   </li>
  </ul>
  Indicare la dimensione in bit del bus ed indicare il valore massimo di millisecondi che il bus può rappresentare.
  <br/>
  Per trovare tale valore, consideriamo la dimensione della ROM, ovvero
  <span class="math-span">
   \( 4 \ KB\)
  </span>
  . È quindi una ROM
  <span class="math-span">
   \( 4k \times 8\)
  </span>
  in quanto ogni byte è uguale ad
  <span class="math-span">
   \( 8\)
  </span>
  bit.
  <br/>
  Ora è necessario trovare i bit di indirizzo della memoria e, dato che:
  <ul class="list-container">
   <li class="list-item">
    <span class="math-span">
     \( 1 \ Kb = 2^{10}\)
    </span>
    bit;
   </li>
   <li class="list-item">
    <span class="math-span">
     \( 4 \ b = 2^{2}\)
    </span>
    bit;
   </li>
  </ul>
  si ha che:
  <ul class="list-container">
   <li class="list-item">
    il numero di informazioni memorizzate espresso come potenza di
    <span class="math-span">
     \( 2\)
    </span>
    è uguale a
    <span class="math-span">
     \( 2^{10} \cdot 2^{2} = 2^{12}\)
    </span>
    ;
   </li>
   <li class="list-item">
    il numero di bit necessari per indirizzare questo numero di informazioni è dato da
    <span class="math-span">
     \( \log_{2}(2^{12}) = 12\)
    </span>
    .
   </li>
  </ul>
  Si ha quindi che la dimensione del bus è di
  <span class="math-span">
   \( 12\)
  </span>
  bit e, da questo dato è possibili ricavare il valore massimo di millisecondi rappresentabile, ovvero
  <span class="math-block">
   \[         2^{12} - 1 = 4095       \]
  </span>
  ovvero
  <span class="math-span">
   \( 4095\)
  </span>
  millisecondi.
 </div>
</div>
<div class="definition environment" id="def2-50">
 <h2 class="environment-title">
  Definizione -
  Diversi tipi di ROM
 </h2>
 <div class="environment-body">
  Proprio per venire incontro alle diverse necessità di "programmazione" nel tempo sono nate:
  <ul class="list-container">
   <li class="list-item">
    le PROM ("
    <i>
     Programmable ROM
    </i>
    "), ovvero memorie programmabili direttamente dall'utente, ma solo una volta;
   </li>
   <li class="list-item">
    le EPROM ("
    <i>
     Erasable PROM
    </i>
    "), ovvero memorie riprogrammabili: per farlo, è però necessario rimuoverle dal circuito;
   </li>
   <li class="list-item">
    le EEPROM ("
    <i>
     Electrically EPROM
    </i>
    "), ovvero memorie riprogrammabili elettricamente: è quindi possibile farlo senza rimuoverle dal circuito.
   </li>
  </ul>
 </div>
</div>
            </article>
            <nav class="buttons-container content-width">
                <a class="navigation-button previous" href="decoder-e-multiplexer.html" rel="nofollow"><span>Decoder e Multiplexer</span></a>
                <a class="navigation-button next" href="../alu/index.html" rel="nofollow"><span>ALU</span></a>
            </nav>
        </section>
        <div class="scroll-to-bottom-button" onclick="scroll_to_bottom()">
            <span class="material-symbols-outlined">
                keyboard_double_arrow_down
            </span>
        </div>
        <footer class="footer-wrapper">
            <div class="copyright-wrapper">
                <span> &copy; Copyright 2023</span> /
                <span>made by lorenzoarlo</span>
            </div>
            /
            <div class="privacy-wrapper">
                <span><a href="https://lorenzoarlo.github.io/privacy-and-cookies/" rel="nofollow">Pannello preferenze cookie</a></span> /
                <span><a href="https://lorenzoarlo.github.io/privacy-and-cookies/privacy-policy.html" rel="nofollow" target="_blank" >Privacy Policy</a></span>
            </div>
        </footer>
    </div>
</body>
</html>