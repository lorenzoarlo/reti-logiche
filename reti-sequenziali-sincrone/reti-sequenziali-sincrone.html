<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="stylesheet" href="../styles/style.css" />
    <link rel="stylesheet" href="../styles/index-style.css" />
    <link rel="stylesheet" href="../styles/content-style.css" />
    <link rel="icon" type="image/x-icon" href="../resources/favicon.ico">
    <script src="../scripts/script.js"></script>
    <style>:root { --bg-clr: #ff7f50; --fg-clr: #262626; }</style>
    <meta name="theme-color" content="#ff7f50" />
    <meta name="keywords" content="reti logiche, reti combinatorie, reti sequenziali" />
    <meta name="description" content="Il seguente sito contiene gli appunti e le definizioni del corso 'Reti logiche'.">
    <meta name="robots" content="index">
    <script defer async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <title>Reti logiche - Reti sequenziali sincrone - Reti sequenziali sincrone</title>
</head>
<body>
    <div class="container">
        <header class="header-wrapper">
            <div class="title-wrapper">
                <span class="title">
                    Reti logiche
                </span>
                <span class="subtitle">
                    by lorenzoarlo
                </span>
            </div>
            <span class="page-title">
                Reti sequenziali sincrone
            </span>
        </header>
        <section class="content-wrapper">
            <h1 class="section-title">Reti sequenziali sincrone</h1>
            <article class="content-container content-width">
                <div class="definition environment" id="def6-1">
 <h2 class="environment-title">
  Definizione -
  Rete sequenziale sincrona (RSS)
 </h2>
 <div class="environment-body">
  Una rete sequenziale asincrona è una rete sequenziale in cui lo stato presente è sovrascritto dal valore dello stato futuro ad intervalli regolari (dettati dal segnale di clock).
  <br/>
  Ad ogni intervallo la rete campiona e memorizza i valori calcolati nell'intervallo precedente (all'
  <span class="math-span">
   \( n\)
  </span>
  -esimo intervallo lo stato presente avrà il valore dello stato futuro calcolato nell'intervallo
  <span class="math-span">
   \( n - 1\)
  </span>
  ).     In questo modo, scegliendo intervalli sufficientemente lunghi, grazie al campionamento in tempi discreti, si ha che:
  <ul class="list-container">
   <li class="list-item">
    non è necessario preoccuparsi delle alee statiche, potendo quindi effettuare la sintesi minima;
   </li>
   <li class="list-item">
    è possibile considerare configurazioni di ingresso consecutive non adiacenti;
   </li>
   <li class="list-item">
    non è necessario preoccuparsi delle corse critiche, potendo quindi scegliere qualsiasi codifica per lo stato.
   </li>
  </ul>
  Per effettuare il campionamento periodico è possibile inserire dei Flip-flop D (al cui ingresso CLK è collegato un segnale periodico di clock) negli anelli di retroazione (un Flip-flop per ogni anello) che agiscono da memoria e forniscono un ritardo costante.
  <br/>
  L'iter di lavoro di una RSS è quindi il seguente:
  <ul class="list-container">
   <li class="list-item">
    al fronte di salita del segnale di clock sono campionati i bit di stato futuro (calcolati nell'intervallo precedente) dai Flip-flop D;
   </li>
   <li class="list-item">
    dopo il tempo di risposta dei Flip-flop, lo stato campionato diventa lo stato presente della rete;
   </li>
   <li class="list-item">
    nel caso lo stato sia cambiato (o siano cambiati gli ingressi) la rete calcola un nuovo stato futuro e una nuova uscita;
   </li>
   <li class="list-item">
    i segnali di stato futuro arrivano a regime con un anticipo pari al tempo di set-up dei flip-flop, pronti per essere campionati nuovamente.
   </li>
  </ul>
  Le RSS, oltre ai vantaggi progettuali elencati in precedenza, hanno anche il vantaggio di poter calcolare l'uscita tenendo conto del trascorrere del tempo (e non solo degli ingressi).
 </div>
</div>
<div class="definition environment" id="def6-2">
 <h2 class="environment-title">
  Definizione -
  Temporizzazione di una RSS
 </h2>
 <div class="environment-body">
  A differenza delle reti combinatorie e delle RSA, le RSS non funzionano ad inseguimento degli ingressi: a scandire qualsiasi cambiamento è il fronte di salita del segnale di clock.     Per questo motivo non esiste il concetto di stato stabile: ogni stato è infatti stabile per almeno un periodo di clock.
  <br/>
  Il valore del periodo di clock diventa quindi un vincolo fondamentale. Si ha infatti che deve essere almeno maggiore della somma tra:
  <ul class="list-container">
   <li class="list-item">
    il massimo tra il tempo di risposta del flip-flop e la durata del transitorio degli ingressi;
   </li>
   <li class="list-item">
    la durata del transitorio della rete che deve calcolare lo stato futuro;
   </li>
   <li class="list-item">
    il tempo di set-up dei flip-flop.
   </li>
  </ul>
  Si ha inoltre che i bit di stato futuro devono rimanere stabili, oltre che per il tempo di set-up, anche per il tempo di hold dei flip-flop.
 </div>
</div>
<div class="definition environment" id="def6-3">
 <h2 class="environment-title">
  Definizione -
  RSS come Finite State Machine (FSM)
 </h2>
 <div class="environment-body">
  Anche le RSS sono un caso particolare di automa (o macchina a stati finiti). Sono infatti caratterizzate anch'esse da:
  <ul class="list-container">
   <li class="list-item">
    un insieme
    <span class="math-span">
     \( I\)
    </span>
    detto alfabeto di ingresso;
   </li>
   <li class="list-item">
    un insieme
    <span class="math-span">
     \( U\)
    </span>
    detto alfabeto di uscita;
   </li>
   <li class="list-item">
    un insieme
    <span class="math-span">
     \( S\)
    </span>
    degli stati;
   </li>
   <li class="list-item">
    una funzione
    <span class="math-span">
     \( F: S \times I \to U\)
    </span>
    di uscita;
   </li>
   <li class="list-item">
    una funzione
    <span class="math-span">
     \( G: S \times I \to S\)
    </span>
    di aggiornamento dello stato interno.
   </li>
  </ul>
  In base alle caratteristiche della funzione
  <span class="math-span">
   \( F\)
  </span>
  si distingue
  <ul class="list-container">
   <li class="list-item">
    l'automa di Moore, in cui l'uscita dipende solo dallo stato interno.
   </li>
   <li class="list-item">
    l'automa di Mealy, in cui l'uscita dipende dallo stato interno e dagli ingressi, ovvero
   </li>
  </ul>
 </div>
</div>
<div class="definition environment" id="def6-4">
 <h2 class="environment-title">
  Definizione -
  Reti sequenziali sincrone - Automa di Moore
 </h2>
 <div class="environment-body">
  Nell'automa di Moore si ha che l'uscita dipende solo dallo stato presente, rendendo quindi separati ingressi e uscite.
  <br/>
  L'uscita è quindi soggetta al ritardo del flip-flop, rispondendo sempre con un periodo di clock di ritardo rispetto agli ingressi. Inoltre, qualora gli ingressi variassero in modo asincrono (rispettando però i tempi di set-up e di hold) l'uscita continuerebbe a variare in modo sincrono.
 </div>
</div>
<div class="definition environment" id="def6-5">
 <h2 class="environment-title">
  Definizione -
  Reti sequenziali sincrone - Automa di Mealy
 </h2>
 <div class="environment-body">
  Nell'automa di Mealy si ha che l'uscita dipende anche dal valore degli ingressi: per questo motivo l'uscita potrebbe variare in modo asincrono e non solo in corrispodenza dei fronti di salita del clock (ma nel momento in cui gli ingressi variano).
 </div>
</div>
<div class="definition environment" id="def6-6">
 <h2 class="environment-title">
  Definizione -
  Sincronizzazione di segnali asincroni
 </h2>
 <div class="environment-body">
  Il modello delle RSS assume che gli ingressi siano sincroni (ovvero ingressi che variano una sola volta per ciclo di clock nel momento del fronte del clock).
  <br/>
  Tuttavia gli ingressi (nella maggior parte dei casi) sono segnali asincroni. È possibile, però, sincronizzare segnali che variano a frequenza minore della frequenza di clock: una rete che svolge questo compito è detta sincronizzatore.
  <br/>
  Il Flip-flop D è sicuramente il più semplice dei sincronizzatori: non riesce tuttavia a svolgere il suo compito nel caso il segnale vari durante il tempo di set-up e di hold (andando in metastabilità).     Per evitare ciò è possibile porre in cascata due flip-flop: nel caso non si rispettassero i tempi, il primo flip-flop andrebbe in metastabilità ma, per come sono progettati questi componenti, è molto probabile (ma non certo) che si risolva. A questo punto, i due flip-flop campioneranno il valore corretto.
 </div>
</div>
<div class="definition environment" id="def6-7">
 <h2 class="environment-title">
  Definizione -
  Sintesi formale di una RSS
 </h2>
 <div class="environment-body">
  Per sintetizzare una RSS il procedimento è analogo a quello per le RSA. Tuttavia, è necessario tenere conto che:
  <ul class="list-container">
   <li class="list-item">
    dato che stiamo lavorando con una RSS, non è necessario rispettare i diversi vincoli precedentemente elencati;
   </li>
   <li class="list-item">
    la rete "rimane" su ogni arco per un periodo di clock. Ciò significa che gli stati non devono essere necessariamente stabili per gli archi che li raggiungono e che non si hanno più indifferenze sull'uscita quando essa cambia valore.
   </li>
  </ul>
  Nonostante sia più semplice il progetto rispetto a quello per una RSA, esso risulta non particolarmente flessibile. Inoltre, considerando reti che comunicano con umani, al fine di scandire il tempo sarebbe necessario creare un numero elevatissimo di stati oppure di diminuire la frequenza di clock (rendendo la rete non reattiva).
  <br/>
  Per questi motivi si preferisce una sintesi diretta che si "appoggia" su altre RSS.
 </div>
</div>
            </article>
            <nav class="buttons-container content-width">
                <a class="navigation-button previous" href="index.html" rel="nofollow"><span>Reti sequenziali sincrone</span></a>
                <a class="navigation-button next" href="registri.html" rel="nofollow"><span>Registri</span></a>
            </nav>
        </section>
        <div class="scroll-to-bottom-button" onclick="scroll_to_bottom()">
            <span class="material-symbols-outlined">
                keyboard_double_arrow_down
            </span>
        </div>
        <footer class="footer-wrapper">
            <div class="copyright-wrapper">
                <span> &copy; Copyright 2023</span> /
                <span>made by lorenzoarlo</span>
            </div>
            /
            <div class="privacy-wrapper">
                <span><a href="https://lorenzoarlo.github.io/privacy-and-cookies/" rel="nofollow">Pannello preferenze cookie</a></span> /
                <span><a href="https://lorenzoarlo.github.io/privacy-and-cookies/privacy-policy.html" rel="nofollow" target="_blank" >Privacy Policy</a></span>
            </div>
        </footer>
    </div>
</body>
</html>