<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="stylesheet" href="../styles/style.css" />
    <link rel="stylesheet" href="../styles/index-style.css" />
    <link rel="stylesheet" href="../styles/content-style.css" />
    <link rel="icon" type="image/x-icon" href="../resources/favicon.ico">
    <link rel=”apple-touch-icon” href=”../resources/favicon.ico” />
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-78NHLXDQD8"></script>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5785471996225878" crossorigin="anonymous"></script>
    <script src="../scripts/script.js"></script>
    <style>:root { --bg-clr: #ff7f50; --fg-clr: #262626; }</style>
    <meta name="theme-color" content="#ff7f50" />
    <meta name="keywords" content="reti logiche, reti combinatorie, reti sequenziali" />
    <meta name="description" content="Il seguente sito contiene gli appunti e le definizioni del corso 'Reti logiche'.">
    <meta name="robots" content="index">
    <script defer async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <title>Reti logiche - Reti sequenziali sincrone - Contatori</title>
</head>
<body>
    <div class="container">
        <header class="header-wrapper">
            <div class="title-wrapper">
                <span class="title">
                    Reti logiche
                </span>
                <span class="subtitle">
                    by lorenzoarlo
                </span>
            </div>
            <span class="page-title">
                Reti sequenziali sincrone
            </span>
        </header>
        <section class="content-wrapper">
            <h1 class="section-title">Contatori</h1>
            <article class="content-container content-width">
                <div class="definition environment" id="def6-17">
 <h2 class="environment-title">
  Definizione -
  Contatore binario senza ingressi x
  <span class="math-span">
   \( 4\)
  </span>
 </h2>
 <div class="environment-body">
  Per realizzare un contatore binario senza ingressi x
  <span class="math-span">
   \( 4\)
  </span>
  (ovvero che memorizza
  <span class="math-span">
   \( 4\)
  </span>
  stati) sono necessari
  <span class="math-span">
   \( 2\)
  </span>
  bit di stato (ovvero due flip-flop).
  <br/>
  Per realizzare la logica di "incremento" è possibile utilizzare un
  <span class="math-span">
   \( n\)
  </span>
  bit adder a cui è costantemente aggiunto il numero
  <span class="math-span">
   \( 1\)
  </span>
  . Tale realizzazione è però inefficiente, in quanto utilizza un numero elevato di componenti.     Un adder, infatti, oltre alla logica di incremento implementa ulteriori funzionalità (come la gestione dell'ingresso riporto e di calcolarlo) mentre, in questo caso, non deve realizzarli.
  <br/>
  Osservando la sequenza degli stati (dove con
  <span class="math-span">
   \( n\)
  </span>
  si intende l'istante attuale e con
  <span class="math-span">
   \( n + 1\)
  </span>
  l'istante successivo)
  <div class="image-environment">
   <div class="image-wrapper spaced-30">
    <img alt="Immagine" src="../resources/generated-112.png"/>
   </div>
  </div>
  è possibile notare che il bit
  <span class="math-span">
   \( (Q_{0})^{n + 1}\)
  </span>
  non è altro che il NOT del bit
  <span class="math-span">
   \( (Q_{0})^{n}\)
  </span>
  , mentre il bit
  <span class="math-span">
   \( (Q_{1})^{n + 1}\)
  </span>
  è dato dallo XOR tra
  <span class="math-span">
   \( (Q_{1})^{n}\)
  </span>
  e
  <span class="math-span">
   \( (Q_{0})^{n}\)
  </span>
  .
  <br/>
  Si ha quindi che la migliore realizzazione è la seguente:
  <div class="image-environment">
   <div class="image-wrapper spaced-70">
    <img alt="Immagine" src="../resources/contatore-x4-noinputs.png"/>
   </div>
  </div>
  Esistono diverse realizzazioni di contatori binari, differenti in base alla codifica di memorizzazione utilizzata (ad esempio la codifica Gray) ma anche in base al numero (e al tipo) di ingressi.
 </div>
</div>
<div class="definition environment" id="def6-18">
 <h2 class="environment-title">
  Definizione -
  Contatore binario con ingresso sincrono
  <span class="math-span">
   \( ENABLE\)
  </span>
 </h2>
 <div class="environment-body">
  Un contatore con ingresso sincrono
  <span class="math-span">
   \( ENABLE\)
  </span>
  è un contatore che:
  <ul class="list-container">
   <li class="list-item">
    con
    <span class="math-span">
     \( ENABLE = 1\)
    </span>
    svolge il regolare funzionamento (contando normalmente);
   </li>
   <li class="list-item">
    con
    <span class="math-span">
     \( ENABLE = 0\)
    </span>
    rimane costante al valore memorizzato;
   </li>
  </ul>
  Realizzarlo con dei multiplexer è semplice, si ha infatti:
  <div class="image-environment">
   <div class="image-wrapper spaced-70">
    <img alt="Immagine" src="../resources/contatore-x4-en.png"/>
   </div>
  </div>
  Utilizzare tali componenti risulta però inefficiente, in quanto è possibile ottimizzarli:
  <ul class="list-container">
   <li class="list-item">
    per il bit
    <span class="math-span">
     \( (Q_{0})^{n + 1}\)
    </span>
    si ha che può essere così ottimizzato
    <div class="image-environment">
     <div class="image-wrapper spaced-70">
      <img alt="Immagine" src="../resources/contatore-en-optimiz-1.png"/>
     </div>
    </div>
    ovvero è possibile sostituirlo con un gate EXOR che con un ingresso a
    <span class="math-span">
     \( 0\)
    </span>
    si comporta come identità rispetto all'altro ingresso mentre, con un bit a
    <span class="math-span">
     \( 1\)
    </span>
    si comporta come un NOT.
   </li>
   <li class="list-item">
    per il bit
    <span class="math-span">
     \( (Q_{1})^{n + 1}\)
    </span>
    si ha che può essere così ottimizzato
    <div class="image-environment">
     <div class="image-wrapper spaced-70">
      <img alt="Immagine" src="../resources/contatore-en-optimiz-2.png"/>
     </div>
    </div>
    ovvero è possibile aggiungere un gate AND in ingresso. Con
    <span class="math-span">
     \( EN = 1\)
    </span>
    esso porta in uscita l'ingresso
    <span class="math-span">
     \( Q_0\)
    </span>
    (ovvero si ha il regolare funzionamento) mentre con
    <span class="math-span">
     \( EN = 0\)
    </span>
    si ha come uscita dell'AND
    <span class="math-span">
     \( 0\)
    </span>
    e il gate EXOR porta in uscita l'altro ingresso (che sarebbe il bit in uscita all'istante precedente).
   </li>
  </ul>
  Si ha quindi che il circuito ottimizzato è il seguente:
  <div class="image-environment">
   <div class="image-wrapper spaced-70">
    <img alt="Immagine" src="../resources/contatore-x4-en-opt.png"/>
   </div>
  </div>
 </div>
</div>
<div class="definition environment" id="def6-19">
 <h2 class="environment-title">
  Definizione -
  Contatore binario con ingresso sincrono
  <span class="math-span">
   \( RESET\)
  </span>
 </h2>
 <div class="environment-body">
  Un contatore con ingresso sincrono
  <span class="math-span">
   \( RESET\)
  </span>
  è un contatore che:
  <ul class="list-container">
   <li class="list-item">
    con
    <span class="math-span">
     \( RESET = 0\)
    </span>
    svolge il regolare funzionamento (contando normalmente);
   </li>
   <li class="list-item">
    con
    <span class="math-span">
     \( RESET = 1\)
    </span>
    memorizza il valore
    <span class="math-span">
     \( 0\)
    </span>
    .
   </li>
  </ul>
  Tipicamente è prioritario rispetto all'ingresso
  <span class="math-span">
   \( ENABLE\)
  </span>
  e, per questo motivo, è "l'ultimo" ad agire sul calcolo dello stato futuro, ovvero
  <div class="image-environment">
   <div class="image-wrapper spaced-70">
    <img alt="Immagine" src="../resources/contatore-x4-res.png"/>
   </div>
  </div>
 </div>
</div>
<div class="definition environment" id="def6-20">
 <h2 class="environment-title">
  Definizione -
  Contatore binario con ingresso sincrono
  <span class="math-span">
   \( LOAD\)
  </span>
 </h2>
 <div class="environment-body">
  Un contatore con ingresso sincrono
  <span class="math-span">
   \( LOAD\)
  </span>
  è un contatore che:
  <ul class="list-container">
   <li class="list-item">
    con
    <span class="math-span">
     \( LOAD = 0\)
    </span>
    svolge il regolare funzionamento (contando normalmente);
   </li>
   <li class="list-item">
    con
    <span class="math-span">
     \( LOAD = 1\)
    </span>
    memorizza i bit forniti sull'ingresso
    <span class="math-span">
     \( I[\ldots]\)
    </span>
    .
   </li>
  </ul>
  Tipicamente è prioritario rispetto all'ingresso
  <span class="math-span">
   \( ENABLE\)
  </span>
  e
  <span class="math-span">
   \( RESET\)
  </span>
  , quindi sarà posizionato successivamente nel calcolo dello stato futuro.
  <div class="image-environment">
   <div class="image-wrapper spaced-70">
    <img alt="Immagine" src="../resources/contatore-x4-load.png"/>
   </div>
  </div>
 </div>
</div>
<div class="definition environment" id="def6-21">
 <h2 class="environment-title">
  Definizione -
  Contatore binario con ingresso sincrono
  <span class="math-span">
   \( UP/DOWN'\)
  </span>
 </h2>
 <div class="environment-body">
  Un contatore con ingresso sincrono
  <span class="math-span">
   \( UP/DOWN'\)
  </span>
  è un contatore che:
  <ul class="list-container">
   <li class="list-item">
    con
    <span class="math-span">
     \( U/D' = 1\)
    </span>
    svolge il regolare funzionamento (incrementando il proprio stato interno);
   </li>
   <li class="list-item">
    con
    <span class="math-span">
     \( U/D' = 0\)
    </span>
    decrementa il proprio stato interno.
   </li>
  </ul>
  Chiaramente questo ingresso dipende dal valore di
  <span class="math-span">
   \( ENABLE\)
  </span>
  (non avrebbe senso infatti decrementare con
  <span class="math-span">
   \( ENABLE = 0\)
  </span>
  ).
  <br/>
  Per realizzarlo è possibile considerare che il bit
  <span class="math-span">
   \( (Q_0)^{n + 1}\)
  </span>
  commuta in ogni caso (indipendentemente se incrementa o decrementa) mentre si ha che il bit
  <span class="math-span">
   \( (Q_1)^{n + 1}\)
  </span>
  assume il seguente comportamento:
  <ul class="list-container">
   <li class="list-item">
    nel caso dell'incremento, diventa
    <span class="math-span">
     \( 1\)
    </span>
    quando il bit
    <span class="math-span">
     \( (Q_{0})^n = 1\)
    </span>
    (in quanto incrementando aggiunge un bit di peso maggiore);
   </li>
   <li class="list-item">
    nel caso del decremento, diventa
    <span class="math-span">
     \( 1\)
    </span>
    quando il bit
    <span class="math-span">
     \( (Q_{0})^n = 0\)
    </span>
    (in quanto decrementando è necessario diminuire il bit di peso maggiore);
   </li>
  </ul>
  Detto ciò, quando si decrementa è sufficiente sostituire a
  <span class="math-span">
   \( (Q_0)^n\)
  </span>
  in ingresso all'EXOR, il bit
  <span class="math-span">
   \( \overline{(Q_0)^n}\)
  </span>
  , ovvero
  <div class="image-environment">
   <div class="image-wrapper spaced-70">
    <img alt="Immagine" src="../resources/contatore-x4-ud.png"/>
   </div>
  </div>
 </div>
</div>
<div class="definition environment" id="def6-22">
 <h2 class="environment-title">
  Definizione -
  Contatore binario senza ingressi x
  <span class="math-span">
   \( 8\)
  </span>
 </h2>
 <div class="environment-body">
  Per realizzare un contatore binario senza ingressi x
  <span class="math-span">
   \( 8\)
  </span>
  (ovvero che memorizza
  <span class="math-span">
   \( 8\)
  </span>
  stati) è sufficiente calcolare il bit
  <span class="math-span">
   \( (Q_2)^{n+1}\)
  </span>
  . Tale bit commuterà solo quando
  <span class="math-span">
   \( (Q_0)^n = 1\)
  </span>
  e
  <span class="math-span">
   \( (Q_1)^n = 1\)
  </span>
  , ovvero quando
  <span class="math-span">
   \( (Q_0)^n \cdot (Q_1)^n\)
  </span>
  .
  <br/>
  È quindi sufficiente replicare la logica utilizzata per il bit
  <span class="math-span">
   \( (Q_1)^{n + 1}\)
  </span>
  (ovvero si ha che uno EXOR con ingresso
  <span class="math-span">
   \( 1\)
  </span>
  commuta l'altro ingresso) fornendo in input ad un EXOR gli ingressi
  <span class="math-span">
   \( ((Q_0)^n \cdot (Q_1)^n)\)
  </span>
  e
  <span class="math-span">
   \( (Q_2)^n\)
  </span>
  , ovvero
  <div class="image-environment">
   <div class="image-wrapper spaced-70">
    <img alt="Immagine" src="../resources/contatore-x8-noinputs.png"/>
   </div>
  </div>
 </div>
</div>
<div class="definition environment" id="def6-23">
 <h2 class="environment-title">
  Definizione -
  Contatore binario
 </h2>
 <div class="environment-body">
  Un Contatore x
  <span class="math-span">
   \( (2^{k})\)
  </span>
  è una rete logica sincrona in grado di contare ad ogni ciclo di clock fino a raggiungere il valore
  <span class="math-span">
   \( 2^{k} - 1\)
  </span>
  (o
  <span class="math-span">
   \( 0\)
  </span>
  nel caso lo si utilizzi con
  <span class="math-span">
   \( U/D' = 0\)
  </span>
  ).
  <div class="image-environment">
   <div class="image-wrapper spaced-50">
    <img alt="Immagine" src="../resources/contatore.png"/>
   </div>
  </div>
  I possibili ingressi di questo componente sono:
  <ul class="list-container">
   <li class="list-item">
    un ingresso
    <span class="math-span">
     \( CLK\)
    </span>
    per il segnale di clock;
   </li>
   <li class="list-item">
    un ingresso sincrono
    <span class="math-span">
     \( LD\)
    </span>
    che permette di caricare tutti i
    <span class="math-span">
     \( k\)
    </span>
    bit forniti nell'ingresso
    <span class="math-span">
     \( I[\ldots]\)
    </span>
    ;
   </li>
   <li class="list-item">
    un bus di
    <span class="math-span">
     \( k\)
    </span>
    segnali sincroni in ingresso
    <span class="math-span">
     \( I[k - 1, \ldots, 0]\)
    </span>
    ;
   </li>
   <li class="list-item">
    un ingresso sicrono
    <span class="math-span">
     \( RESET\)
    </span>
    che forza lo stato
    <span class="math-span">
     \( 0\)
    </span>
    ;
   </li>
   <li class="list-item">
    un ingresso sincrono
    <span class="math-span">
     \( EN\)
    </span>
    che attiva/disattiva il contatore;
   </li>
   <li class="list-item">
    un ingresso sincrono
    <span class="math-span">
     \( U/D'\)
    </span>
    ("Up / Down'") che consente di scegliere tra incrementare e decrementare lo stato;
   </li>
   <li class="list-item">
    un bus di
    <span class="math-span">
     \( k\)
    </span>
    segnali sincroni in uscita
    <span class="math-span">
     \( Q[...]\)
    </span>
    che forniscono lo stato corrente;
   </li>
   <li class="list-item">
    un segnale sincrono
    <span class="math-span">
     \( COUT\)
    </span>
    che indica se il contatore ha raggiunto lo stato limite (quindi
    <span class="math-span">
     \( 2^k - 1\)
    </span>
    se
    <span class="math-span">
     \( U/D'=1\)
    </span>
    o
    <span class="math-span">
     \( 0\)
    </span>
    se
    <span class="math-span">
     \( U/D'=0\)
    </span>
    ).
   </li>
  </ul>
  Per realizzare contatori con base di conteggio maggiore (utilizzando contatori x
  <span class="math-span">
   \( 2\)
  </span>
  , x
  <span class="math-span">
   \( 4\)
  </span>
  e x
  <span class="math-span">
   \( 8\)
  </span>
  ), è sufficiente collegare due contatori in serie. Si può infatti considerare il ragionamento fatto per estendere a
  <span class="math-span">
   \( 3\)
  </span>
  bit il contatore x
  <span class="math-span">
   \( 2\)
  </span>
  in quanto ogni contatore "di peso maggiore" deve contare solo quando il contatore precedente ha raggiunto "il limite" (ovvero quando
  <span class="math-span">
   \( COUT = 1\)
  </span>
  ). Per realizzare un contatore x
  <span class="math-span">
   \( 32\)
  </span>
  si avrà quindi la seguente rete:
  <div class="image-environment">
   <div class="image-wrapper spaced-70">
    <img alt="Immagine" src="../resources/contatore-x32.png"/>
   </div>
  </div>
  L'ingresso
  <span class="math-span">
   \( EN\)
  </span>
  dei contatori "a valle" deve essere condizionato anche dall'ingresso
  <span class="math-span">
   \( ENABLE\)
  </span>
  della rete oltre che dall'ingresso
  <span class="math-span">
   \( COUT\)
  </span>
  , in modo da evitare problemi nel caso il contatore si fermi una volta raggiunto "il limite".
  <br/>
  Può essere tuttavia necessario un contatore che conta fino ad un numero che non è una potenza di
  <span class="math-span">
   \( 2\)
  </span>
  : per fare questo è sufficiente calcolare un segnale
  <span class="math-span">
   \( TO_RESET\)
  </span>
  da collegare all'ingresso
  <span class="math-span">
   \( RESET\)
  </span>
  del contatore (condizionato ulteriormente dall'ingresso
  <span class="math-span">
   \( ENABLE\)
  </span>
  ). Tale segnale sarà un mintermine nel caso si voglia discriminare un "numero maggiore o uguale di" mentre sarà un maxtermine nel caso si voglia discriminare un numero "minore o uguale di". Ad esempio, per creare un contatore x
  <span class="math-span">
   \( 20\)
  </span>
  si avrà la seguente rete:
  <div class="image-environment">
   <div class="image-wrapper spaced-70">
    <img alt="Immagine" src="../resources/contatore-x20.png"/>
   </div>
  </div>
 </div>
</div>
<div class="myexample environment" id="example23">
 <h2 class="environment-title">
  Esempio -
  Sintesi diretta - Riconoscitore di sequenze con contatore
 </h2>
 <div class="environment-body">
  Progettare una rete sequenziale sincrona che controlla se gli ultimi tre byte inseriti nell'ingresso
  <span class="math-span">
   \( IN[7, \ldots, 0]\)
  </span>
  mentre il segnale
  <span class="math-span">
   \( EN = 1\)
  </span>
  sono stati
  <span class="math-span">
   \( FF)_{16}\)
  </span>
  ,
  <span class="math-span">
   \( 27)_{16}\)
  </span>
  e
  <span class="math-span">
   \( 30)_{16}\)
  </span>
  (dove
  <span class="math-span">
   \( FF)_{16}\)
  </span>
  è il primo byte della sequenza).
  <br/>
  Nel caso la sequenza sia rispettata, nel periodo di clock successivo l'uscita
  <span class="math-span">
   \( OUT\)
  </span>
  deve essere portata a
  <span class="math-span">
   \( 1\)
  </span>
  e rimanere tale fino a che l'ingresso asincrono
  <span class="math-span">
   \( A\_RESET\)
  </span>
  non è uguale a
  <span class="math-span">
   \( 1\)
  </span>
  : da quel momento la rete deve considerare che non fosse stato inserito alcun byte.
  <br/>
  Innanzitutto la rete è di Moore in quanto deve rispondere al clock successivo all'ultimo inserimento nella sequenza.
  <br/>
  Un modo per riconoscere sequenze secondo Moore è porre un contatore che indica in che stato si è.
  <br/>
  Tale contatore sarà comandato dall'ingresso
  <span class="math-span">
   \( NEXT\)
  </span>
  che sarà attivo solo se
  <span class="math-span">
   \( EN = 1\)
  </span>
  , si sta aspettando un certo valore (
  <span class="math-span">
   \( WAIT0x??\)
  </span>
  ) e l'ultimo ingresso è proprio quel valore (
  <span class="math-span">
   \( WAIT0x??\)
  </span>
  ).     Analogamente, si avrà che il contatore deve essere resettato solo se ci si aspetta qualcosa di diverso dall'ultimo ingresso. Inoltre, il contatore sarà inizializzato in stato
  <span class="math-span">
   \( WAIT0x27\)
  </span>
  nel caso l'ultimo ingresso sia stato
  <span class="math-span">
   \( 0xFF\)
  </span>
  , altrimenti sarà inizializzato a
  <span class="math-span">
   \( WAIT0xFF\)
  </span>
  .
  <div class="image-environment">
   <div class="image-wrapper spaced-80">
    <img alt="Immagine" src="../resources/riconosci-sequenze-contatore.png"/>
   </div>
  </div>
 </div>
</div>
            </article>
            <nav class="buttons-container content-width">
                <a class="navigation-button previous" href="monoimpulsore.html" rel="nofollow"><span>Monoimpulsore</span></a>
                
            </nav>
        </section>
        <div class="scroll-to-bottom-button" onclick="scroll_to_bottom()">
            <span class="material-symbols-outlined">
                keyboard_double_arrow_down
            </span>
        </div>
        <footer class="footer-wrapper">
            <div class="copyright-wrapper">
                <span> &copy; Copyright 2023</span> /
                <span>made by lorenzoarlo</span>
            </div>
            /
            <div class="privacy-wrapper">
                <span><a href="https://lorenzoarlo.github.io/privacy-and-cookies/" rel="nofollow">Pannello preferenze cookie</a></span> /
                <span><a href="https://lorenzoarlo.github.io/privacy-and-cookies/privacy-policy.html" rel="nofollow" target="_blank" >Privacy Policy</a></span>
            </div>
        </footer>
    </div>
</body>
</html>