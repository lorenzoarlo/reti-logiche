<!DOCTYPE html>
<html lang="IT">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="stylesheet" href="../styles/style.css" />
    <link rel="stylesheet" href="../styles/index-style.css" />
    <link rel="stylesheet" href="../styles/content-style.css" />
    <link rel="icon" type="image/x-icon" href="../resources/favicon.ico">
    <link rel="apple-touch-icon" href="../resources/favicon.png" />
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-78NHLXDQD8"></script>
    <script src="../scripts/script.js"></script>
    <style>:root { --bg-clr: #ff7f50; --fg-clr: #262626; }</style>
    <meta name="theme-color" content="#ff7f50" />
    <meta name="keywords" content="reti logiche, reti combinatorie, reti sequenziali" />
    <meta name="description" content="Il seguente sito contiene gli appunti e le definizioni del corso 'Reti logiche'.">
    <meta name="robots" content="index">
    <script defer async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <title>Reti logiche - Reti sequenziali sincrone - RSS notevoli</title>
</head>
<body>
    <div class="container">
        <header class="header-wrapper">
            <div class="title-wrapper">
                <span class="title">
                    Reti logiche
                </span>
                <span class="subtitle">
                    by lorenzoarlo
                </span>
            </div>
            <span class="page-title">
                Reti sequenziali sincrone
            </span>
        </header>
        <section class="content-wrapper">
            <h1 class="section-title content-width">RSS notevoli</h1>
            <article class="content-container content-width">
                <div class="definition environment" id="def4-9"><h2 class="environment-title">Definizione - Registro a <span class="math-span">\( k\)</span> bit</h2><div class="environment-body">     Un registro a <span class="math-span">\( k\)</span> bit è una rete sequenziale sincrona in grado di memorizzare un dato di <span class="math-span">\( k\)</span> bit.     <div class="image-environment"><div class="image-wrapper spaced-60"><img alt="Immagine" src="../resources/register.png"/></div></div>     Esso è caratterizzato da:     <ul class="list-container"><li class="list-item">un ingresso <span class="math-span">\( CLK\)</span> per il segnale di clock;         </li><li class="list-item">un bus di <span class="math-span">\( k\)</span> segnali sincroni in ingresso <span class="math-span">\( IN[k-1, \ldots, 0]\)</span>;         </li><li class="list-item">un ingresso sincrono <span class="math-span">\( WE\)</span> ("<i>Write Enable</i>") per permettere la <strong>sovrascrittura</strong> del dato precedentemente memorizzato (con <span class="math-span">\( WE = 0\)</span> ad ogni fronte di clock rimane il segnale memorizzato in precedenza);         </li><li class="list-item">un segnale asincrono <span class="math-span">\( A\_RESET\)</span> ("Asynchronous RESET") che, se attivo, pone a <span class="math-span">\( 0\)</span> tutti i bit memorizzati.     </li></ul>     Per realizzare un registro ad <span class="math-span">\( 1\)</span> bit (da cui poi è facile ottenere un registro a <span class="math-span">\( k\)</span> bit) è possibile ragionare nel seguente modo:     <ul class="list-container"><li class="list-item">se <span class="math-span">\( WE = 1\)</span>, il flip-flop deve memorizzare l'ingresso <span class="math-span">\( IN\)</span>;         </li><li class="list-item">se <span class="math-span">\( WE = 0\)</span>, il flip-flop deve memorizzare il valore precedente, ovvero <span class="math-span">\( Q\)</span>.     </li></ul>     Dato che è una scelta, un metodo utile per realizzarlo è utilizzare un multiplexer, ovvero     <div class="image-environment"><div class="image-wrapper spaced-70"><img alt="Immagine" src="../resources/circuito-register.png"/></div></div><div class="mynote environment"><h3 class="environment-title">Osservazioni personali - Uno (registro), nessuno (registro) e centomila (registri)...</h3><div class="environment-body">         Partendo dai requisiti sopracitati, è possibile realizzare diversi registri che differiscono per:         <ul class="list-container"><li class="list-item">i comandi disponibili (ad esempio potrebbe non essere presente l'ingresso <span class="math-span">\( A\_RESET\)</span>);             </li><li class="list-item">la sincronicità (o asincronicità) dei comandi (ad esempio un registro con l'ingresso <span class="math-span">\( RESET\)</span> sincrono);             </li><li class="list-item">l'ordine di priorità dei comandi (ad esempio, nel caso di un segnale <span class="math-span">\( RESET\)</span> sincrono, se esso ha priorità maggiore rispetto al <span class="math-span">\( WE\)</span>).         </li></ul>          Tali implementazioni sono valide, e, nel caso le si adoperino, sarà indicato.     </div></div></div></div><div class="myexample environment" id="example19"><h2 class="environment-title">Esempio - Sintesi diretta - Flip-flop T</h2><div class="environment-body">     Realizzare una rete sincrona secondo Moore caratterizzata da:     <ul class="list-container"><li class="list-item">un unico ingresso sincrono <span class="math-span">\( T\)</span>;         </li><li class="list-item">un bit in memoria che commuta ("<i>toggle</i>") ad ogni ciclo di clock in cui <span class="math-span">\( T = 1\)</span>;         </li><li class="list-item">due uscite <span class="math-span">\( Q\)</span> e <span class="math-span">\( Q'\)</span> che forniscono il bit memorizzato (in forma vera e negata).     </li></ul>      Per realizzare questa rete è possibile ragionare nel seguente modo (per ogni ciclo di clock):     <ul class="list-container"><li class="list-item">con <span class="math-span">\( T = 0\)</span> si continua a memorizzare <span class="math-span">\( Q\)</span>;         </li><li class="list-item">con <span class="math-span">\( T = 1\)</span> si memorizza <span class="math-span">\( Q'\)</span>.     </li></ul>     È possibile quindi realizzare la rete nel seguente modo:     <div class="image-environment"><div class="image-wrapper spaced-70"><img alt="Immagine" src="../resources/flip-flop-t.png"/></div></div></div></div><div class="myexample environment" id="example20"><h2 class="environment-title">Esempio - Sintesi diretta - Accumulatore</h2><div class="environment-body">     Realizzare una rete sincrona secondo Moore che ad ogni ciclo di clock somma il valore fornito sull'ingresso <span class="math-span">\( I[k -1 , \ldots, 0]\)</span> di <span class="math-span">\( k\)</span> bit al valore memorizzato.      Ad ogni ciclo di clock la rete deve fornire sull'uscita <span class="math-span">\( OUT[k - 1, \ldots, 0]\)</span> il valore attualmente in memoria. Si consideri inoltre un ulteriore ingresso <span class="math-span">\( INIT\)</span> che permette di inizializzare il valore memorizzato.     La rete è quindi caratterizzata da:      <ul class="list-container"><li class="list-item">un bus di <span class="math-span">\( k\)</span> segnali sincroni in ingresso <span class="math-span">\( I[k-1, \ldots, 0]\)</span> che rappresenta un numero unsigned;         </li><li class="list-item">un ingresso sincrono <span class="math-span">\( INIT\)</span> che permette di inizializzare il valore memorizzato (<span class="math-span">\( INIT = 1\)</span>)         </li><li class="list-item">un'uscita <span class="math-span">\( OUT[k - 1, \ldots, 0]\)</span> che fornisce il valore memorizzato.     </li></ul>      È possibile realizzare la rete nel seguente modo:     <div class="image-environment"><div class="image-wrapper spaced-70"><img alt="Immagine" src="../resources/accumulatore-circuito.png"/></div></div>     Si ha quindi un flip-flop in retroazione che memorizza ad ogni ciclo di clock il valore corrente. Ad ogni ciclo, inoltre, si ha che un adder effettua la somma tra il valore memorizzato in precedenza e il valore fornito in ingresso.     <br/>     Si ha infine un gate AND che, in base al valore dell'ingresso INIT, annulla o "lascia passare" il risultato dell'adder.     </div></div><div class="myexample environment" id="example21"><h2 class="environment-title">Esempio - Sintesi diretta di una RSS</h2><div class="environment-body">     Realizzare una rete sincrona secondo Moore caratterizzata da:     <ul class="list-container"><li class="list-item">un bus di <span class="math-span">\( 4\)</span> segnali in ingresso <span class="math-span">\( N[3,2,1,0]\)</span> che rappresenta un numero unsigned;         </li><li class="list-item">un uscita <span class="math-span">\( Z\)</span> che ha valore <span class="math-span">\( 1\)</span> se <span class="math-span">\( N\)</span> rappresenta un numero di valore maggiore o uguale a <span class="math-span">\( 12)_{10}\)</span>. L'uscita deve mantenere valore <span class="math-span">\( Z = 1\)</span> fino a che <span class="math-span">\( N\)</span> non rappresenta un valore inferiore a <span class="math-span">\( 8)_{10}\)</span>. Negli altri momenti, l'uscita deve avere valore <span class="math-span">\( 0\)</span>;         </li><li class="list-item">l'uscita inizialmente a <span class="math-span">\( 0\)</span>.     </li></ul>      Per realizzare questa rete può essere utile dividere in intervalli il valore che <span class="math-span">\( N\)</span> può assumere:     <ul class="list-container"><li class="list-item">se <span class="math-span">\( N \geq 12\)</span> è sicuro che <span class="math-span">\( Z = 1\)</span>;         </li><li class="list-item">se <span class="math-span">\( N \lt  8\)</span> è sicuro che <span class="math-span">\( Z = 0\)</span>;         </li><li class="list-item">se <span class="math-span">\( 8 \leq N \lt  12\)</span> la rete ha il valore che ha assunto in precedenza (in quanto se in precedenza <span class="math-span">\( Z = 1\)</span> si ha che <span class="math-span">\( N\)</span> sta "decrescendo", altrimenti sta "crescendo").     </li></ul>      Ragionando in questo modo, è utile realizzare separatamente le varie parti della rete, considerando le seguenti "sotto-reti":     <ul class="list-container"><li class="list-item">una rete che verifica se <span class="math-span">\( N \geq 12\)</span>, rappresentata dal segnale <span class="math-span">\( NGE12\)</span> ("<i>N Greater or Equals 12</i>");         </li><li class="list-item">una rete che verifica se <span class="math-span">\( N \lt  8\)</span>, rappresentata dal segnale <span class="math-span">\( NLT8\)</span> ("<i>N Less Than 8</i>");         </li><li class="list-item">una rete che memorizza l'ultimo valore assunto dalla rete (inizialmente <span class="math-span">\( 0\)</span>);     </li></ul>     Seguendo questi ragionamenti e considerando che <span class="math-span">\( NGE12\)</span> assume gli stessi valori dell'uscita (<span class="math-span">\( Z=0\)</span> se <span class="math-span">\( NGE12=0\)</span> e <span class="math-span">\( Z=1\)</span> se <span class="math-span">\( NGE12=1\)</span>) si avrebbe quindi la seguente rete:     <div class="image-environment"><div class="image-wrapper spaced-70"><img alt="Immagine" src="../resources/sintesi-diretta-1.png"/></div></div>     ovvero, se la rete è in uno degli intervalli sicuri (<span class="math-span">\( N \geq 12\)</span> o <span class="math-span">\( N \lt  8\)</span>) allora si deve memorizzare <span class="math-span">\( NGE12\)</span>, altrimenti il valore che si era memorizzato in precedenza.     <br/>     Per completare la rete è ora sufficiente creare le reti combinatorie che costruiscono <span class="math-span">\( NGE12\)</span> e <span class="math-span">\( NLT8\)</span>:     <ul class="list-container"><li class="list-item">in binario si ha che il numero <span class="math-span">\( 12)_{10}\)</span> è rappresentato come <span class="math-span">\( 1100)_{2}\)</span>, si avrà quindi che i numeri maggiori o uguali a <span class="math-span">\( 12\)</span> sono caratterizzati dal mintermine <span class="math-span">\( NGE12 = N3 \cdot N2\)</span>;         </li><li class="list-item">in binario si ha che il numero <span class="math-span">\( 8)_{10}\)</span> è rappresentato come <span class="math-span">\( 1000)_{2}\)</span>, si avrà quindi che i numeri minori di <span class="math-span">\( 8\)</span> sono caratterizzati dal mintermine <span class="math-span">\( NLT8 = N3'\)</span>.     </li></ul>     ovvero     <div class="image-environment"><div class="image-wrapper spaced-50"><img alt="Immagine" src="../resources/nge12-nlt8.png"/></div></div></div></div><div class="definition environment" id="def4-10"><h2 class="environment-title">Definizione - Logical Shift Register</h2><div class="environment-body">     Un Logical Shift Register è una rete logica sincrona in grado di memorizzare gli <strong>ultimi</strong> <span class="math-span">\( k\)</span> bit ricevuti.      <div class="image-environment"><div class="image-wrapper spaced-60"><img alt="Immagine" src="../resources/base-shift-register.png"/></div></div>     I possibili ingressi di questo componente sono:     <ul class="list-container"><li class="list-item">un ingresso <span class="math-span">\( CLK\)</span> per il segnale di clock;         </li><li class="list-item">un ingresso sincrono <span class="math-span">\( LD\)</span> che permette di caricare tutti i <span class="math-span">\( k\)</span> bit forniti sull'ingresso <span class="math-span">\( I[...]\)</span>;         </li><li class="list-item">un bus di <span class="math-span">\( k\)</span> segnali sincroni in ingresso <span class="math-span">\( I[k - 1, \ldots, 0]\)</span>;         </li><li class="list-item">un ingresso sincrono <span class="math-span">\( EN\)</span> che regola se il registro deve continuare a mantenere i dati in memoria (<span class="math-span">\( EN = 0\)</span>) oppure se effettuare lo "scorrimento" (<span class="math-span">\( EN = 1\)</span>);         </li><li class="list-item">un ingresso sicrono <span class="math-span">\( IN\)</span> che indica qual è il bit da inserire;         </li><li class="list-item">un ingresso sincrono <span class="math-span">\( R/L'\)</span> ("<i>Right / Left'</i>") che consente di variare la direzione dello shift.;         </li><li class="list-item">un ingresso asincrono <span class="math-span">\( A\_RESET\)</span> che carica      </li></ul>     In base al valore dell'ingresso <span class="math-span">\( R/L'\)</span> il bit in ingresso <span class="math-span">\( IN\)</span> sarà inserito in una posizione differente:     <ul class="list-container"><li class="list-item">se <span class="math-span">\( R/L'=1\)</span> il bit <span class="math-span">\( IN\)</span> viene inserito in posizione <span class="math-span">\( 0\)</span> (ovvero immaginandolo come un array, nella cella più a sinistra);         </li><li class="list-item">se <span class="math-span">\( R/L'=0\)</span> il bit <span class="math-span">\( IN\)</span> viene inserito in posizione <span class="math-span">\( k -1\)</span> (ovvero immaginandolo come un array, nella cella più a destra);     </li></ul>     È necessario comunque considerare ingressi con priorità. Ad esempio considerando l'ingresso <span class="math-span">\( LD\)</span> come il più prioritario, si avrebbe che gli altri ingressi hanno effetto solo nel caso <span class="math-span">\( LD = 0\)</span>. Analogamente, si avrebbe che gli ingressi <span class="math-span">\( IN\)</span> e <span class="math-span">\( R/L'\)</span> hanno significato solo se <span class="math-span">\( EN = 1\)</span>.     <br/>     L'implementazione del comportamento base (ovvero di uno shift register dotato dei soli ingressi <span class="math-span">\( EN\)</span> e <span class="math-span">\( IN\)</span> con scorrimento a destra) è molto semplice e sfrutta il fatto che nei flip-flop il tempo di hold è minore del tempo di risposta. Si ha infatti la seguente rete:     <div class="image-environment"><div class="image-wrapper spaced-80"><img alt="Immagine" src="../resources/shift-register-circuito.png"/></div></div><div class="mynote environment"><h3 class="environment-title">Osservazioni personali - Scorrimento a sinistra, scorrimento a destra</h3><div class="environment-body">         Immaginando un registro a <span class="math-span">\( k\)</span> bit la cui memoria è la seguente         <div class="image-environment"><div class="image-wrapper spaced-40"><img alt="Immagine" src="../resources/generated-122.png"/></div></div>         si hanno due possibili comportamenti:         <ul class="list-container"><li class="list-item">lo scorrimento a destra, ovvero si ha che il bit dell'ingresso <span class="math-span">\( IN\)</span> è inserito in memoria nella posizione <span class="math-span">\( 0\)</span>. Il comportamento sarebbe quindi il seguente:             <div class="image-environment"><div class="image-wrapper spaced-50"><img alt="Immagine" src="../resources/generated-123.png"/></div></div></li><li class="list-item">lo scorrimento a sinistra, ovvero si ha che il bit dell'ingresso <span class="math-span">\( IN\)</span> è inserito in memoria nella posizione <span class="math-span">\( k - 1\)</span>. Il comportamento sarebbe quindi il seguente:             <div class="image-environment"><div class="image-wrapper spaced-50"><img alt="Immagine" src="../resources/generated-124.png"/></div></div></li></ul></div></div></div></div><div class="definition environment" id="def4-11"><h2 class="environment-title">Definizione - Universal Shift Register</h2><div class="environment-body">     Una versione possibile di Logical Shift Register è l'Universal Shift Register che implementa le varie funzionalità messe a disposizione dallo Shift Register con diversi ingressi, attraverso dei codici. Si ha quindi che, considerando il componente relativo alla seguente rete     <div class="image-environment"><div class="image-wrapper spaced-80"><img alt="Immagine" src="../resources/universal-shift-register-circuito.png"/></div></div>     i codici operativi sarebbero:     <ul class="list-container"><li class="list-item"><span class="math-span">\( S_{1} = 0\)</span> e <span class="math-span">\( S_{0} = 0\)</span> per il comando di "hold";         </li><li class="list-item"><span class="math-span">\( S_{1} = 0\)</span> e <span class="math-span">\( S_{0} = 1\)</span> per il comando di "shit a destra";         </li><li class="list-item"><span class="math-span">\( S_{1} = 1\)</span> e <span class="math-span">\( S_{0} = 0\)</span> per il comando di "shift a sinistra";         </li><li class="list-item"><span class="math-span">\( S_{1} = 1\)</span> e <span class="math-span">\( S_{0} = 1\)</span> per il comando di "load";     </li></ul></div></div><div class="definition environment" id="def4-12"><h2 class="environment-title">Definizione - Comunicazione in serie e in parallelo</h2><div class="environment-body">     Quando si comunica un'informazione è possibile che questa "arrivi a destinazione" attraverso la sequenza di informazioni di un singolo segnale in sequenza (<strong>comunicazione seriale</strong>), oppure attraverso più segnali in contemporanea (<strong>comunicazione parallela</strong>).     <br/>     Generalmente la comunicazione in parallelo risulta essere più efficiente anche se porta con sé diverse difficolta, tra cui:     <ul class="list-container"><li class="list-item">necessità di schermare le vie di comunicazione per evitare interferenze;         </li><li class="list-item">necessità di un protocollo per gestire il sincronismo tra i segnali;         </li><li class="list-item">impossibilità di mantenere la stabilità su lunghe distanze.      </li></ul>     Si decide quindi di utilizzare la comunicazione in parallelo in componenti interni (come la scheda madre) in cui è possibile avere più controllo. Per altri utilizzi, invece, si utilizza la comunicazione in serie che risulta essere meno costosa e complessa permettendo un maggiore sviluppo tecnologico (si veda del caso dei cavetti USB, "<i>Universal Serial Bus</i>"). </div></div><div class="definition environment" id="def4-13"><h2 class="environment-title">Definizione - Utilizzare uno Shift Register per la conversione da comunicazione seriale a parallela</h2><div class="environment-body">     Una rete che effettua la conversione tra comunicazione seriale e in parallelo secondo Moore è la seguente     <div class="image-environment"><div class="image-wrapper spaced-80"><img alt="Immagine" src="../resources/conversione-serie-parallelo-moore.png"/></div></div>     Si avrà quindi che per ottenere un dato in parallelo di <span class="math-span">\( k\)</span> bit da uno in serie sono necessari <span class="math-span">\( k\)</span> flip-flop e ogni informazione è valida ogni <span class="math-span">\( k\)</span> cicli di clock.     <br/>     È possibile realizzare anche la rete secondo Mealy nel seguente modo:     <div class="image-environment"><div class="image-wrapper spaced-80"><img alt="Immagine" src="../resources/conversione-serie-parallelo-mealy.png"/></div></div>     In questo caso sono necessari <span class="math-span">\( k - 1\)</span> flip-flop e l'informazione è valida ogni <span class="math-span">\( k - 1\)</span> cicli di clock. Nonostante ciò si ottiene che una delle uscite non è "stabilizzata" dal flip-flop rendendola soggetta a possibili problemi.     <br/>     In entrambi i casi si hanno reti equivalenti ad uno shift register, ovvero al componente privilegiato per questo compito </div></div><div class="definition environment" id="def4-14"><h2 class="environment-title">Definizione - Utilizzare uno Shift Register per la conversione da comunicazione parallela a seriale</h2><div class="environment-body">     Una rete che effettua la conversione tra comunicazione in parallelo e in serie secondo Moore è la seguente:     <div class="image-environment"><div class="image-wrapper spaced-70"><img alt="Immagine" src="../resources/conversione-parallelo-serie-moore.png"/></div></div>     Si avrà quindi che ad ogni ciclo di clock sarà presente il bit desiderato sull'uscita <span class="math-span">\( OUT[0]\)</span>, nell'ordine <span class="math-span">\( 0\)</span>, <span class="math-span">\( 1\)</span>, <span class="math-span">\( \ldots\)</span>, <span class="math-span">\( k - 1\)</span>. </div></div><div class="definition environment" id="def4-15"><h2 class="environment-title">Definizione - Utilizzare uno Shift Register per effettuare moltiplicazioni e divisioni</h2><div class="environment-body">     Considerando un qualsiasi numero binario unsigned, si ha che il suo shift (e l'ingresso di uno <span class="math-span">\( 0\)</span>) effettui una moltiplicazione (shift verso sinistra) o una divisione intera (shift verso destra) per <span class="math-span">\( 2\)</span>.     <br/>     È quindi possibile svolgere delle moltiplicazioni tra numeri binari utilizzando delle reti sincrone (nonostante queste siano ottenibili anche da circuiti combinatori).     <br/>     Ad esempio, considerando il numero binario <span class="math-span">\( 01101)_{2}\)</span> (uguale a <span class="math-span">\( 13)_{10}\)</span>) si ha che il suo shift verso sinistra     <div class="image-environment"><div class="image-wrapper spaced-50"><img alt="Immagine" src="../resources/generated-125.png"/></div></div>     è uguale a <span class="math-span">\( 11010)_{2}\)</span>, ovvero <span class="math-span">\( 26)_{2}\)</span>.     <br/>     Si ha inoltre che il bit più significativo del numero da moltiplicare (in questo caso <span class="math-span">\( bit_{4}\)</span>) indica se ci sarà overflow (nel caso esso sia <span class="math-span">\( 1\)</span>).     È quindi semplice utilizzare uno shift register per effettuare questa operazione.  </div></div><div class="myexample environment" id="example22"><h2 class="environment-title">Esempio - Sintesi diretta - <span class="math-span">\( k\)</span> bit multiplier</h2><div class="environment-body">     Progettare una rete asincrona secondo Moore che effettui la moltiplicazione tra due numeri di <span class="math-span">\( k\)</span> bit unsigned utilizzando shift register e adder. Si considerino quindi come fattori gli ingressi <span class="math-span">\( A[k - 1 , \ldots, 0]\)</span> e <span class="math-span">\( B[k - 1, \ldots, 0]\)</span> validi quando il segnale <span class="math-span">\( LD\)</span> è uguale a <span class="math-span">\( 1\)</span>.      Il risultato, fornito sull'uscita <span class="math-span">\( OUT[2 \cdot k - 1, \ldots, 0]\)</span>, deve essere disponibile fino a quando <span class="math-span">\( LD\)</span> non assumera nuovamente valore <span class="math-span">\( 1\)</span>.     <br/>     Per progettare la rete consideriamo l'algoritmo di moltiplicazione in colonna.     <div class="image-environment"><div class="image-wrapper spaced-30"><img alt="Immagine" src="../resources/generated-126.png"/></div></div>     Si ha che il risultato è la somma delle moltiplicazioni tra il primo fattore e ogni singola cifra del secondo (moltiplicata per il suo peso). Si avrà quindi che ogni addendo della somma avrà come valore quello del primo fattore moltiplicato per <span class="math-span">\( 2\)</span> per un numero di volte uguale alla sua posizione. Ovvero     <div class="image-environment"><div class="image-wrapper spaced-60"><img alt="Immagine" src="../resources/generated-127.png"/></div></div>     Un'idea potrebbe quindi essere effettuare lo shift (verso sinistra) di <span class="math-span">\( k\)</span> volte del primo fattore (in modo da moltiplicarlo ogni volta per <span class="math-span">\( 2\)</span>) e effettuare lo shift verso sinistra del secondo fattore (in modo da avere sempre il bit da moltiplicare nella stessa posizione). Ad ogni ciclo di clock si ottiene quindi una somma parziale che dovrà essere memorizzata in un accumulatore.     <br/>     La rete sarà quindi così formata:     <div class="image-environment"><div class="image-wrapper spaced-90"><img alt="Immagine" src="../resources/kbit-multiplier.png"/></div></div>     dove <span class="math-span">\( B \ NOT \ 0\)</span> è un segnale che indica se <span class="math-span">\( B\)</span> è un numero non nullo (ovvero un OR con ogni bit di <span class="math-span">\( B\)</span> in ingresso). </div></div><div class="definition environment" id="def4-16"><h2 class="environment-title">Definizione - Shift aritmetico</h2><div class="environment-body">     Per permettere la moltiplicazione e divisione di numeri signed è possibile utilizzare lo shift aritmetico.     <br/>     Tale shift differisce di poco dallo shift logico, in particolare:     <ul class="list-container"><li class="list-item">nella divisione (ovvero shift verso destra) è sufficiente che il bit inserito sia uguale al MSB del numero (ovvero al segno, che non può cambiare).         </li><li class="list-item">nela moltiplicazione (ovvero shift verso sinistra) si continua ad aggiungere <span class="math-span">\( 0\)</span>. Tuttavia, per verificare l'overflow è sufficiente verificare che il segno del risultato sia uguale al segno del numero iniziale, o meglio, è necessario verificare che il MSB e il suo adiacente siano uguali.     </li></ul></div></div><div class="myexample environment" id="example23"><h2 class="environment-title">Esempio - Sintesi diretta - Riconoscitore di sequenze con shift register</h2><div class="environment-body">     Progettare una rete sequenziale sincrona che controlla se gli ultimi tre byte inseriti nell'ingresso <span class="math-span">\( IN[7, \ldots, 0]\)</span> mentre il segnale <span class="math-span">\( EN = 1\)</span> sono stati <span class="math-span">\( FF)_{16}\)</span>, <span class="math-span">\( 27)_{16}\)</span> e <span class="math-span">\( 30)_{16}\)</span> (dove <span class="math-span">\( FF)_{16}\)</span> è il primo byte della sequenza).     <br/>     Nel caso la sequenza sia rispettata, nel periodo di clock successivo l'uscita <span class="math-span">\( OUT\)</span> deve essere portata a <span class="math-span">\( 1\)</span> e rimanere tale fino a che l'ingresso asincrono <span class="math-span">\( A\_RESET\)</span> non è uguale a <span class="math-span">\( 1\)</span>: da quel momento la rete deve considerare che non fosse stato inserito alcun byte.     <br/>     Innanzitutto la rete è di Moore in quanto deve rispondere al clock successivo all'ultimo inserimento nella sequenza.     <br/>     Un modo (inefficiente) per riconoscere sequenze secondo Moore è porre degli Shift Register in serie per creare una coda che permetta di controllare ad ogni ciclo di clock se la sequenza è stata rispettata.     <br/>     Dato che in ingresso si hanno <span class="math-span">\( 8\)</span> bit ad ogni ciclo di clock, è necessario utilizzare <span class="math-span">\( 8\)</span> shift register da <span class="math-span">\( 3\)</span> bit in serie. In questo modo si avrà che:     <ul class="list-container"><li class="list-item">all'uscita <span class="math-span">\( OUT[2]\)</span> di ogni registro si hanno tutti i bit inseriti <span class="math-span">\( 3\)</span> cicli di clock fa;         </li><li class="list-item">all'uscita <span class="math-span">\( OUT[1]\)</span> di ogni registro si hanno tutti i bit inseriti <span class="math-span">\( 2\)</span> cicli di clock fa;         </li><li class="list-item">all'uscita <span class="math-span">\( OUT[0]\)</span> di ogni registro si hanno tutti i bit inseriti <span class="math-span">\( 1\)</span> ciclo di clock fa;     </li></ul>     In questo modo si potranno utilizzare delle reti combinatorie per confrontare i diversi byte.     <br/>     Pensando ora al mantenimento dell'ingresso, si può lavorare utilizzando l'ingresso <span class="math-span">\( EN\_SHIFT\)</span> per decidere quando abilitare lo shift register. <span class="math-span">\( EN\_SHIFT\)</span> deve essere abilitato quando <span class="math-span">\( EN=1\)</span> e <span class="math-span">\( OUT=0\)</span>. Si avrà quindi la seguente rete:     <div class="image-environment"><div class="image-wrapper spaced-80"><img alt="Immagine" src="../resources/riconosci-sequenze-shift-register.png"/></div></div>     Questa soluzione utilizza però un numero troppo elevato di componenti. È infatti sufficiente memorizzare solo se il byte è quello desiderato e per farlo conviene controllare inizialmente se il numero è quello corretto e memorizzarlo come singolo bit. Si avrà quindi la seguente rete:     <div class="image-environment"><div class="image-wrapper spaced-80"><img alt="Immagine" src="../resources/riconosci-sequenze-shift-register-better.png"/></div></div></div></div><div class="definition environment" id="def4-17"><h2 class="environment-title">Definizione - Monoimpulsore</h2><div class="environment-body">     Un monoimpulsore (detto anche "<strong>edge detector</strong>", ovvero rilevatore dei fronti) è una rete logica sincrona che emette in uscita un segnale alto, per un solo ciclo di clock, nel ciclo di clock successivo al fronte di salita dell'ingresso (ovvero passaggio da <span class="math-span">\( IN=0\)</span> a <span class="math-span">\( IN=1\)</span>, nel caso sia "positive edge triggered" ).     L'ingresso, che può essere anche asincrono, deve avere una frequenza di aggiornamento inferiore a quella del clock.      Nel caso che il fronte di salita capiti nell'intervallo "tempo di setup"-"tempo di hold" (ovvero è molto vicino al fronte del clock), è accettabile segnalare il fronte con più di un clock di ritardo (a causa della metastabilità).     <br/>     Un possibile montaggio del <strong>monoimpulsore positive edge triggered</strong> (ovvero sensibile ai fronti di salita) è il seguente:     <div class="image-environment"><div class="image-wrapper spaced-70"><img alt="Immagine" src="../resources/monopulsore-positive-edge-triggered.png"/></div></div>     Il montaggio per un monoimpulsore <strong>negative edge triggered</strong> (ovvero sensibile ai fronti di discesa) è il seguente:     <div class="image-environment"><div class="image-wrapper spaced-70"><img alt="Immagine" src="../resources/monoimpulsore-negative-edge-triggered.png"/></div></div>     Con questo tipo di montaggio (ovvero utilizzando solo due flip-flop), si ha che nel caso non si rispettino i tempi del flip-flop, si avrebbe la metastabilità e il componente potrebbe subire un ritardo di un ciclo di clock.      <br/>     Nel caso l'uscita <span class="math-span">\( OUT\)</span> sia utilizzata da una rete di Moore non ci sarebbe alcun problema in quanto gli ingressi sono "sincronizzati" dalla rete.     <br/>     Per ottenere una rete (nel caso di una rete di Mealy) con meno probabilità di metastabilità è possibile aggiungere un ulteriore flip-flop, al costo però di avere un ritardo sull'aggiornamento dell'uscita.     <div class="mynote environment"><h3 class="environment-title">Osservazioni personali - Monoimpulsore errato</h3><div class="environment-body">         Il seguente montaggio         <div class="image-environment"><div class="image-wrapper spaced-70"><img alt="Immagine" src="../resources/monoimpulsore-errato.png"/></div></div>         non è corretto. Infatti, nel caso <span class="math-span">\( IN\)</span> fosse uguale a <span class="math-span">\( 1\)</span> per più cicli di clock consecutivi, si avrebbe un cortocircuito in quanto l'uscita commuterebbe automaticamente più volte.     </div></div><div class="mynote environment"><h3 class="environment-title">Osservazioni personali - A cosa serve un monoimpulsore?</h3><div class="environment-body">         In una RSS, un monoimpulsore è utile per <strong>rilevare</strong> (e poi sincronizzare) la <strong>pressione</strong> (utilizzandone uno positive edge triggered) <strong>o il rilascio</strong> (utilizzandone uno negative edge triggered) <strong>di un pulsante</strong>: esso rileverà solo "l'istante" in cui ciò avviene, e non tutta la "durata della pressione".     </div></div></div></div><div class="definition environment" id="def4-18"><h2 class="environment-title">Definizione - Contatore binario senza ingressi x<span class="math-span">\( 4\)</span></h2><div class="environment-body">     Per realizzare un contatore binario senza ingressi x<span class="math-span">\( 4\)</span> (ovvero che memorizza <span class="math-span">\( 4\)</span> stati) sono necessari <span class="math-span">\( 2\)</span> bit di stato (ovvero due flip-flop).     <br/>     Per realizzare la logica di "incremento" è possibile utilizzare un <span class="math-span">\( n\)</span> bit adder a cui è costantemente aggiunto il numero <span class="math-span">\( 1\)</span>. Tale realizzazione è però <strong>inefficiente</strong>, in quanto utilizza un numero elevato di componenti.     Un adder, infatti, oltre alla logica di incremento implementa ulteriori funzionalità (come la gestione dell'ingresso riporto e di calcolarlo) mentre, in questo caso, non deve realizzarli.     <br/>     Osservando la sequenza degli stati (dove con <span class="math-span">\( n\)</span> si intende l'istante attuale e con <span class="math-span">\( n + 1\)</span> l'istante successivo)     <div class="image-environment"><div class="image-wrapper spaced-30"><img alt="Immagine" src="../resources/generated-128.png"/></div></div>     è possibile notare che il bit <span class="math-span">\( (Q_{0})^{n + 1}\)</span> non è altro che il NOT del bit <span class="math-span">\( (Q_{0})^{n}\)</span>, mentre il bit <span class="math-span">\( (Q_{1})^{n + 1}\)</span> è dato dallo XOR tra  <span class="math-span">\( (Q_{1})^{n}\)</span> e <span class="math-span">\( (Q_{0})^{n}\)</span>.     <br/>     Si ha quindi che la migliore realizzazione è la seguente:     <div class="image-environment"><div class="image-wrapper spaced-70"><img alt="Immagine" src="../resources/contatore-x4-noinputs.png"/></div></div>     Esistono diverse realizzazioni di contatori binari, differenti in base alla codifica di memorizzazione utilizzata (ad esempio la codifica Gray) ma anche in base al numero (e al tipo) di ingressi. </div></div><div class="definition environment" id="def4-19"><h2 class="environment-title">Definizione - Contatore binario con ingresso sincrono <span class="math-span">\( ENABLE\)</span></h2><div class="environment-body">     Un contatore con ingresso sincrono <span class="math-span">\( ENABLE\)</span> è un contatore che:     <ul class="list-container"><li class="list-item">con <span class="math-span">\( ENABLE = 1\)</span> svolge il regolare funzionamento (contando normalmente);         </li><li class="list-item">con <span class="math-span">\( ENABLE = 0\)</span> rimane costante al valore memorizzato;     </li></ul>     Realizzarlo con dei multiplexer è semplice, si ha infatti:     <div class="image-environment"><div class="image-wrapper spaced-70"><img alt="Immagine" src="../resources/contatore-x4-en.png"/></div></div>     Utilizzare tali componenti risulta però inefficiente, in quanto è possibile ottimizzarli:     <ul class="list-container"><li class="list-item">per il bit <span class="math-span">\( (Q_{0})^{n + 1}\)</span> si ha che può essere così ottimizzato         <div class="image-environment"><div class="image-wrapper spaced-70"><img alt="Immagine" src="../resources/contatore-en-optimiz-1.png"/></div></div>         ovvero è possibile sostituirlo con un gate EXOR che con un ingresso a <span class="math-span">\( 0\)</span> si comporta come identità rispetto all'altro ingresso mentre, con un bit a <span class="math-span">\( 1\)</span> si comporta come un NOT.         </li><li class="list-item">per il bit <span class="math-span">\( (Q_{1})^{n + 1}\)</span> si ha che può essere così ottimizzato         <div class="image-environment"><div class="image-wrapper spaced-70"><img alt="Immagine" src="../resources/contatore-en-optimiz-2.png"/></div></div>         ovvero è possibile aggiungere un gate AND in ingresso. Con <span class="math-span">\( EN = 1\)</span> esso porta in uscita l'ingresso <span class="math-span">\( Q_0\)</span> (ovvero si ha il regolare funzionamento) mentre con <span class="math-span">\( EN = 0\)</span> si ha come uscita dell'AND <span class="math-span">\( 0\)</span> e il gate EXOR porta in uscita l'altro ingresso (che sarebbe il bit in uscita all'istante precedente).     </li></ul>     Si ha quindi che il circuito ottimizzato è il seguente:     <div class="image-environment"><div class="image-wrapper spaced-70"><img alt="Immagine" src="../resources/contatore-x4-en-opt.png"/></div></div></div></div><div class="definition environment" id="def4-20"><h2 class="environment-title">Definizione - Contatore binario con ingresso sincrono <span class="math-span">\( RESET\)</span></h2><div class="environment-body">     Un contatore con ingresso sincrono <span class="math-span">\( RESET\)</span> è un contatore che:     <ul class="list-container"><li class="list-item">con <span class="math-span">\( RESET = 0\)</span> svolge il regolare funzionamento (contando normalmente);         </li><li class="list-item">con <span class="math-span">\( RESET = 1\)</span> memorizza il valore <span class="math-span">\( 0\)</span>.     </li></ul>     Tipicamente è prioritario rispetto all'ingresso <span class="math-span">\( ENABLE\)</span> e, per questo motivo, è "l'ultimo" ad agire sul calcolo dello stato futuro, ovvero     <div class="image-environment"><div class="image-wrapper spaced-70"><img alt="Immagine" src="../resources/contatore-x4-res.png"/></div></div></div></div><div class="definition environment" id="def4-21"><h2 class="environment-title">Definizione - Contatore binario con ingresso sincrono <span class="math-span">\( LOAD\)</span></h2><div class="environment-body">     Un contatore con ingresso sincrono <span class="math-span">\( LOAD\)</span> è un contatore che:     <ul class="list-container"><li class="list-item">con <span class="math-span">\( LOAD = 0\)</span> svolge il regolare funzionamento (contando normalmente);         </li><li class="list-item">con <span class="math-span">\( LOAD = 1\)</span> memorizza i bit forniti sull'ingresso <span class="math-span">\( I[\ldots]\)</span>.     </li></ul>     Tipicamente è prioritario rispetto all'ingresso <span class="math-span">\( ENABLE\)</span> e <span class="math-span">\( RESET\)</span>, quindi sarà posizionato successivamente nel calcolo dello stato futuro.     <div class="image-environment"><div class="image-wrapper spaced-70"><img alt="Immagine" src="../resources/contatore-x4-load.png"/></div></div></div></div><div class="definition environment" id="def4-22"><h2 class="environment-title">Definizione - Contatore binario con ingresso sincrono <span class="math-span">\( UP/DOWN'\)</span></h2><div class="environment-body">     Un contatore con ingresso sincrono <span class="math-span">\( UP/DOWN'\)</span> è un contatore che:     <ul class="list-container"><li class="list-item">con <span class="math-span">\( U/D' = 1\)</span> svolge il regolare funzionamento (incrementando il proprio stato interno);         </li><li class="list-item">con <span class="math-span">\( U/D' = 0\)</span> decrementa il proprio stato interno.     </li></ul>     Chiaramente questo ingresso dipende dal valore di <span class="math-span">\( ENABLE\)</span> (non avrebbe senso infatti decrementare con <span class="math-span">\( ENABLE = 0\)</span>).     <br/>     Per realizzarlo è possibile considerare che il bit <span class="math-span">\( (Q_0)^{n + 1}\)</span> commuta in ogni caso (indipendentemente se incrementa o decrementa) mentre si ha che il bit <span class="math-span">\( (Q_1)^{n + 1}\)</span> assume il seguente comportamento:     <ul class="list-container"><li class="list-item">nel caso dell'incremento, diventa <span class="math-span">\( 1\)</span> quando il bit <span class="math-span">\( (Q_{0})^n = 1\)</span> (in quanto incrementando aggiunge un bit di peso maggiore);         </li><li class="list-item">nel caso del decremento, diventa <span class="math-span">\( 1\)</span> quando il bit <span class="math-span">\( (Q_{0})^n = 0\)</span> (in quanto decrementando è necessario diminuire il bit di peso maggiore);      </li></ul>     Detto ciò, quando si decrementa è sufficiente sostituire a <span class="math-span">\( (Q_0)^n\)</span> in ingresso all'EXOR, il bit <span class="math-span">\( \overline{(Q_0)^n}\)</span>, ovvero     <div class="image-environment"><div class="image-wrapper spaced-70"><img alt="Immagine" src="../resources/contatore-x4-ud.png"/></div></div></div></div><div class="definition environment" id="def4-23"><h2 class="environment-title">Definizione - Contatore binario senza ingressi x<span class="math-span">\( 8\)</span></h2><div class="environment-body">     Per realizzare un contatore binario senza ingressi x<span class="math-span">\( 8\)</span> (ovvero che memorizza <span class="math-span">\( 8\)</span> stati) è sufficiente calcolare il bit <span class="math-span">\( (Q_2)^{n+1}\)</span>. Tale bit commuterà solo quando <span class="math-span">\( (Q_0)^n = 1\)</span> e <span class="math-span">\( (Q_1)^n = 1\)</span>, ovvero quando <span class="math-span">\( (Q_0)^n \cdot (Q_1)^n\)</span>.     <br/>     È quindi sufficiente replicare la logica utilizzata per il bit <span class="math-span">\( (Q_1)^{n + 1}\)</span> (ovvero si ha che uno EXOR con ingresso <span class="math-span">\( 1\)</span> commuta l'altro ingresso) fornendo in input ad un EXOR gli ingressi <span class="math-span">\( ((Q_0)^n \cdot (Q_1)^n)\)</span> e <span class="math-span">\( (Q_2)^n\)</span>, ovvero     <div class="image-environment"><div class="image-wrapper spaced-70"><img alt="Immagine" src="../resources/contatore-x8-noinputs.png"/></div></div></div></div><div class="definition environment" id="def4-24"><h2 class="environment-title">Definizione - Contatore binario</h2><div class="environment-body">     Un Contatore x<span class="math-span">\( (2^{k})\)</span> è una rete logica sincrona in grado di contare ad ogni ciclo di clock fino a raggiungere il valore <span class="math-span">\( 2^{k} - 1\)</span> (o <span class="math-span">\( 0\)</span> nel caso lo si utilizzi con <span class="math-span">\( U/D' = 0\)</span>).     <div class="image-environment"><div class="image-wrapper spaced-50"><img alt="Immagine" src="../resources/contatore.png"/></div></div>     I possibili ingressi di questo componente sono:     <ul class="list-container"><li class="list-item">un ingresso <span class="math-span">\( CLK\)</span> per il segnale di clock;         </li><li class="list-item">un ingresso sincrono <span class="math-span">\( LD\)</span> che permette di caricare tutti i <span class="math-span">\( k\)</span> bit forniti nell'ingresso <span class="math-span">\( I[\ldots]\)</span>;         </li><li class="list-item">un bus di <span class="math-span">\( k\)</span> segnali sincroni in ingresso <span class="math-span">\( I[k - 1, \ldots, 0]\)</span>;         </li><li class="list-item">un ingresso sicrono <span class="math-span">\( RESET\)</span> che forza lo stato <span class="math-span">\( 0\)</span>;         </li><li class="list-item">un ingresso sincrono <span class="math-span">\( EN\)</span> che attiva/disattiva il contatore;         </li><li class="list-item">un ingresso sincrono <span class="math-span">\( U/D'\)</span> ("Up / Down'") che consente di scegliere tra incrementare e decrementare lo stato;         </li><li class="list-item">un bus di <span class="math-span">\( k\)</span> segnali in uscita <span class="math-span">\( Q[...]\)</span> che forniscono lo stato corrente;         </li><li class="list-item">un segnale di uscita <span class="math-span">\( COUT\)</span> che indica se il contatore ha raggiunto lo stato limite (quindi <span class="math-span">\( 2^k - 1\)</span> se <span class="math-span">\( U/D'=1\)</span> o <span class="math-span">\( 0\)</span> se <span class="math-span">\( U/D'=0\)</span>).     </li></ul>     Per realizzare contatori con base di conteggio maggiore (utilizzando contatori x<span class="math-span">\( 2\)</span>, x<span class="math-span">\( 4\)</span> e x<span class="math-span">\( 8\)</span>), è sufficiente collegare due contatori in serie. Si può infatti considerare il ragionamento fatto per estendere a <span class="math-span">\( 3\)</span> bit il contatore x<span class="math-span">\( 2\)</span> in quanto ogni contatore "di peso maggiore" deve contare solo quando il contatore precedente ha raggiunto "il limite" (ovvero quando <span class="math-span">\( COUT = 1\)</span>). Per realizzare un contatore x<span class="math-span">\( 32\)</span> si avrà quindi la seguente rete:     <div class="image-environment"><div class="image-wrapper spaced-70"><img alt="Immagine" src="../resources/contatore-x32.png"/></div></div>     L'ingresso <span class="math-span">\( EN\)</span> dei contatori "a valle" deve essere condizionato anche dall'ingresso <span class="math-span">\( ENABLE\)</span> della rete oltre che dall'ingresso <span class="math-span">\( COUT\)</span>, in modo da evitare problemi nel caso il contatore si fermi una volta raggiunto "il limite".     <br/>     Può essere tuttavia necessario un contatore che conta fino ad un numero che non è una potenza di <span class="math-span">\( 2\)</span>: per fare questo è sufficiente calcolare un segnale <span class="math-span">\( TO_RESET\)</span> da collegare all'ingresso <span class="math-span">\( RESET\)</span> del contatore (condizionato ulteriormente dall'ingresso <span class="math-span">\( ENABLE\)</span>).     Tale segnale sarà un mintermine nel caso si voglia discriminare un "numero maggiore o uguale di" mentre sarà un maxtermine nel caso si voglia discriminare un numero "minore o uguale di". Ad esempio, per creare un contatore x<span class="math-span">\( 20\)</span> si avrà la seguente rete:     <div class="image-environment"><div class="image-wrapper spaced-70"><img alt="Immagine" src="../resources/contatore-x20.png"/></div></div></div></div><div class="myexample environment" id="example24"><h2 class="environment-title">Esempio - Sintesi diretta - Riconoscitore di sequenze con contatore</h2><div class="environment-body">     Progettare una rete sequenziale sincrona che controlla se gli ultimi tre byte inseriti nell'ingresso <span class="math-span">\( IN[7, \ldots, 0]\)</span> mentre il segnale <span class="math-span">\( EN = 1\)</span> sono stati <span class="math-span">\( FF)_{16}\)</span>, <span class="math-span">\( 27)_{16}\)</span> e <span class="math-span">\( 30)_{16}\)</span> (dove <span class="math-span">\( FF)_{16}\)</span> è il primo byte della sequenza).     <br/>     Nel caso la sequenza sia rispettata, nel periodo di clock successivo l'uscita <span class="math-span">\( OUT\)</span> deve essere portata a <span class="math-span">\( 1\)</span> e rimanere tale fino a che l'ingresso asincrono <span class="math-span">\( A\_RESET\)</span> non è uguale a <span class="math-span">\( 1\)</span>: da quel momento la rete deve considerare che non fosse stato inserito alcun byte.     <br/>     Innanzitutto la rete è di Moore in quanto deve rispondere al clock successivo all'ultimo inserimento nella sequenza.     Un modo per riconoscere sequenze secondo Moore è porre un contatore che indica in che stato si è.     Tale contatore sarà comandato dall'ingresso <span class="math-span">\( NEXT\)</span> che sarà attivo solo se <span class="math-span">\( EN = 1\)</span>, si sta aspettando un certo valore (<span class="math-span">\( WAIT0x??\)</span>) e l'ultimo ingresso è proprio quel valore (<span class="math-span">\( IS0x??\)</span>).     Analogamente, si avrà che il contatore deve essere resettato solo se ci si aspetta qualcosa di diverso dall'ultimo ingresso. Inoltre, il contatore sarà inizializzato in stato <span class="math-span">\( WAIT0x27\)</span> nel caso l'ultimo ingresso sia stato <span class="math-span">\( 0xFF\)</span>, altrimenti sarà inizializzato a <span class="math-span">\( WAIT0xFF\)</span>.     <div class="image-environment"><div class="image-wrapper spaced-80"><img alt="Immagine" src="../resources/riconosci-sequenze-contatore.png"/></div></div></div></div><div class="definition environment" id="def4-25"><h2 class="environment-title">Definizione - Divisore di frequenza di clock</h2><div class="environment-body">     Dato che ogni bit dell'uscita di un contatore evolve come un'onda quadra di frequenza     <span class="math-block">\[         \frac{f_{CLK}}{2^{i + 1}}       \]</span>     dove <span class="math-span">\( f_{CLK}\)</span> è la frequenza del clock, <span class="math-span">\( i\)</span> è la posizione dell'uscita presa in considerazione (l'uscita <span class="math-span">\( Q_0\)</span> avrà come frequenza <span class="math-span">\( \frac{f_{CLK}}{2}\)</span>), è possibile realizzare un divisore di frequenza utilizzando un contatore. Sarà infatti sufficiente utilizzare il bit <span class="math-span">\( Q_i\)</span> dell'uscita del contatore per avere la frequenza divisa di <span class="math-span">\( 2^{i + 1}\)</span>. </div></div>
            </article>
            <nav class="buttons-container content-width">
                <a class="navigation-button previous" href="caratteristiche-delle-rss.html" rel="nofollow"><span>Caratteristiche delle RSS</span></a>
                
            </nav>
        </section>
        <div class="scroll-to-bottom-button" onclick="scroll_to_bottom()">
            <span class="material-symbols-outlined">
                keyboard_double_arrow_down
            </span>
        </div>
        <footer class="footer-wrapper">
            <div class="copyright-wrapper">
                <span> &copy; Copyright 2023</span> /
                <span>made by lorenzoarlo</span>
            </div>
            /
            <div class="privacy-wrapper">
                <span><a href="https://lorenzoarlo.github.io/privacy-and-cookies/" rel="nofollow">Pannello preferenze cookie</a></span> /
                <span><a href="https://lorenzoarlo.github.io/privacy-and-cookies/privacy-policy.html" rel="nofollow" target="_blank" >Privacy Policy</a></span>
            </div>
        </footer>
    </div>
</body>
</html>