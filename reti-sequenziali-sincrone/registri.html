<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="stylesheet" href="../styles/style.css" />
    <link rel="stylesheet" href="../styles/index-style.css" />
    <link rel="stylesheet" href="../styles/content-style.css" />
    <link rel="icon" type="image/x-icon" href="../resources/favicon.ico">
    <link rel="apple-touch-icon" href="../resources/favicon.png" />
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-78NHLXDQD8"></script>
    <script src="../scripts/script.js"></script>
    <style>:root { --bg-clr: #ff7f50; --fg-clr: #262626; }</style>
    <meta name="theme-color" content="#ff7f50" />
    <meta name="keywords" content="reti logiche, reti combinatorie, reti sequenziali" />
    <meta name="description" content="Il seguente sito contiene gli appunti e le definizioni del corso 'Reti logiche'.">
    <meta name="robots" content="index">
    <script defer async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <title>Reti logiche - Reti sequenziali sincrone - Registri</title>
</head>
<body>
    <div class="container">
        <header class="header-wrapper">
            <div class="title-wrapper">
                <span class="title">
                    Reti logiche
                </span>
                <span class="subtitle">
                    by lorenzoarlo
                </span>
            </div>
            <span class="page-title">
                Reti sequenziali sincrone
            </span>
        </header>
        <section class="content-wrapper">
            <h1 class="section-title content-width">Registri</h1>
            <article class="content-container content-width">
                <div class="definition environment" id="def5-9"><h2 class="environment-title">Definizione - Registro a <span class="math-span">\( k\)</span> bit</h2><div class="environment-body">     Un registro a <span class="math-span">\( k\)</span> bit è una rete logica sincrona in grado di memorizzare un dato di <span class="math-span">\( k\)</span> bit.     <div class="image-environment"><div class="image-wrapper spaced-60"><img alt="Immagine" src="../resources/register.png"/></div></div>     Esso è caratterizzato da:     <ul class="list-container"><li class="list-item">un ingresso <span class="math-span">\( CLK\)</span> per il segnale di clock;         </li><li class="list-item">un bus di <span class="math-span">\( k\)</span> segnali sincroni in ingresso <span class="math-span">\( IN[k-1, \ldots, 0]\)</span>;         </li><li class="list-item">un ingresso sincrono <span class="math-span">\( WE\)</span> ("Write Enable") per permettere la sovrascrittura del dato precedentemente memorizzato (con <span class="math-span">\( WE = 0\)</span> ad ogni fronte di clock rimane il segnale memorizzato in precedenza);         </li><li class="list-item">un segnale asincrono <span class="math-span">\( A\_RESET\)</span> ("Asynchronous RESET") che se attivo pone a <span class="math-span">\( 0\)</span> tutti i <span class="math-span">\( k\)</span> bit memorizzati.     </li></ul>     Per realizzare un registro ad <span class="math-span">\( 1\)</span> bit (da cui poi è facile ottenere un registro a <span class="math-span">\( k\)</span> bit) è possibile ragionare nel seguente modo:     <ul class="list-container"><li class="list-item">se <span class="math-span">\( WE = 1\)</span>, il flip-flop deve memorizzare l'ingresso <span class="math-span">\( IN\)</span>;         </li><li class="list-item">se <span class="math-span">\( WE = 0\)</span>, il flip-flop deve memorizzare il valore precedente, ovvero <span class="math-span">\( Q\)</span>.     </li></ul>     Dato che è una scelta, un metodo utile per realizzarlo è utilizzare un multiplexer, ovvero     <div class="image-environment"><div class="image-wrapper spaced-70"><img alt="Immagine" src="../resources/circuito-register.png"/></div></div><div class="mynote environment"><h3 class="environment-title">Osservazioni personali - Uno (registro), nessuno (registro) e centomila (registri)...</h3><div class="environment-body">         Partendo dai requisiti sopracitati, è possibile realizzare diversi registri che differiscono per:         <ul class="list-container"><li class="list-item">i comandi disponibili (ad esempio potrebbe non essere presente l'ingresso <span class="math-span">\( A\_RESET\)</span>);             </li><li class="list-item">la sincronicità (o asincronicità) dei comandi (ad esempio un registro con l'ingresso <span class="math-span">\( RESET\)</span> sincrono);             </li><li class="list-item">l'ordine di priorità dei comandi (ad esempio, nel caso di un segnale <span class="math-span">\( RESET\)</span> sincrono, se esso ha priorità maggiore rispetto al <span class="math-span">\( WE\)</span>).         </li></ul>          Tali implementazioni sono valide, e, nel caso le si adoperino, sarà indicato.     </div></div></div></div><div class="myexample environment" id="example18"><h2 class="environment-title">Esempio - Sintesi diretta - Flip-flop T</h2><div class="environment-body">     Realizzare una rete sincrona secondo Moore caratterizzata da:     <ul class="list-container"><li class="list-item">un unico ingresso sincrono <span class="math-span">\( T\)</span>;         </li><li class="list-item">un bit in memoria che commuta ("toggle") ad ogni ciclo di clock in cui <span class="math-span">\( T = 1\)</span>;         </li><li class="list-item">due uscite <span class="math-span">\( Q\)</span> e <span class="math-span">\( Q'\)</span> che forniscono il bit memorizzato (in forma vera e negata).     </li></ul>      Per realizzare questa rete è possibile ragionare nel seguente modo (per ogni ciclo di clock):     <ul class="list-container"><li class="list-item">se <span class="math-span">\( T = 0\)</span> si continua a memorizzare <span class="math-span">\( Q\)</span>;         </li><li class="list-item">se <span class="math-span">\( T = 1\)</span> si memorizza <span class="math-span">\( Q'\)</span>.     </li></ul>     È possibile quindi realizzare la rete nel seguente modo:     <div class="image-environment"><div class="image-wrapper spaced-70"><img alt="Immagine" src="../resources/flip-flop-t.png"/></div></div></div></div><div class="myexample environment" id="example19"><h2 class="environment-title">Esempio - Sintesi diretta - Accumulatore</h2><div class="environment-body">     Realizzare una rete sincrona secondo Moore che ad ogni ciclo di clock somma il valore fornito sull'ingresso <span class="math-span">\( I[k -1 , \ldots, 0]\)</span> di <span class="math-span">\( k\)</span> bit al valore memorizzato. Ad ogni ciclo di clock la rete deve fornire sull'uscita <span class="math-span">\( Z[k - 1, \ldots, 0]\)</span> il valore memorizzato attualmente. Si consideri inoltre un ulteriore ingresso <span class="math-span">\( INIT\)</span> che permette di inizializzare il valore memorizzato (<span class="math-span">\( INIT = 1\)</span>).      <ul class="list-container"><li class="list-item">un bus di <span class="math-span">\( k\)</span> segnali in ingresso <span class="math-span">\( N[k-1, \ldots, 0]\)</span> che rappresenta un numero unsigned;         </li><li class="list-item">un uscita <span class="math-span">\( Z\)</span> che ha valore <span class="math-span">\( 1\)</span> se <span class="math-span">\( N\)</span> rappresenta un numero di valore maggiore o uguale a <span class="math-span">\( 12)_{10}\)</span>. L'uscita deve mantenere valore <span class="math-span">\( Z = 1\)</span> fino a che <span class="math-span">\( N\)</span> non rappresenta un valore inferiore a <span class="math-span">\( 8)_{10}\)</span>. Negli altri momenti, l'uscita deve avere valore <span class="math-span">\( 0\)</span>;         </li><li class="list-item">l'uscita inizialmente è <span class="math-span">\( 0\)</span>.     </li></ul>      È possibile realizzare la rete nel seguente modo:     <div class="image-environment"><div class="image-wrapper spaced-70"><img alt="Immagine" src="../resources/accumulatore-circuito.png"/></div></div>     Si ha quindi un flip-flop in retroazione che memorizza ad ogni ciclo di clock il valore corrente. Ad ogni ciclo, inoltre, si ha che un adder effettua la somma tra il valore memorizzato in precedenza e il valore fornito in ingresso.     <br/>     Si ha infine un gate AND che, in base al valore dell'ingresso INIT, annulla o "lascia passare" il risultato dell'adder.     </div></div><div class="myexample environment" id="example20"><h2 class="environment-title">Esempio - Sintesi diretta</h2><div class="environment-body">     Realizzare una rete sincrona secondo Moore caratterizzata da:     <ul class="list-container"><li class="list-item">un bus di <span class="math-span">\( 4\)</span> segnali in ingresso <span class="math-span">\( N[3,2,1,0]\)</span> che rappresenta un numero unsigned;         </li><li class="list-item">un uscita <span class="math-span">\( Z\)</span> che ha valore <span class="math-span">\( 1\)</span> se <span class="math-span">\( N\)</span> rappresenta un numero di valore maggiore o uguale a <span class="math-span">\( 12)_{10}\)</span>. L'uscita deve mantenere valore <span class="math-span">\( Z = 1\)</span> fino a che <span class="math-span">\( N\)</span> non rappresenta un valore inferiore a <span class="math-span">\( 8)_{10}\)</span>. Negli altri momenti, l'uscita deve avere valore <span class="math-span">\( 0\)</span>;         </li><li class="list-item">l'uscita inizialmente è <span class="math-span">\( 0\)</span>.     </li></ul>      Per realizzare questa rete può essere utile dividere in intervalli il valore che <span class="math-span">\( N\)</span> può assumere:     <ul class="list-container"><li class="list-item">se <span class="math-span">\( N \geq 12\)</span> è sicuro che <span class="math-span">\( Z = 1\)</span>;         </li><li class="list-item">se <span class="math-span">\( N \lt  8\)</span> è sicuro che <span class="math-span">\( Z = 0\)</span>;         </li><li class="list-item">se <span class="math-span">\( 8 \leq N \lt  12\)</span> la rete ha il valore che ha assunto in precedenza (in quanto se in precedenza <span class="math-span">\( Z = 1\)</span> si ha che <span class="math-span">\( N\)</span> sta "decrescendo", altrimenti sta "crescendo").     </li></ul>      Ragionando in questo modo, è utile realizzare separatamente le varie parti della rete, considerando le seguenti "sotto-reti":     <ul class="list-container"><li class="list-item">una rete che verifica se <span class="math-span">\( N \geq 12\)</span>, rappresentata dal segnale <span class="math-span">\( NGE12\)</span> ("N Greater or Equals 12");         </li><li class="list-item">una rete che verifica se <span class="math-span">\( N \lt  8\)</span>, rappresentata dal segnale <span class="math-span">\( NLT8\)</span> ("N Less Than 8");         </li><li class="list-item">una rete che memorizza l'ultimo valore assunto dalla rete (inizialmente <span class="math-span">\( 0\)</span>);     </li></ul>     Seguendo questi ragionamenti e considerando che <span class="math-span">\( NGE12\)</span> assume gli stessi valori dell'uscita (<span class="math-span">\( Z=0\)</span> se <span class="math-span">\( NGE12=0\)</span> e <span class="math-span">\( Z=1\)</span> se <span class="math-span">\( NGE12=1\)</span>) si avrebbe quindi la seguente rete:     <div class="image-environment"><div class="image-wrapper spaced-70"><img alt="Immagine" src="../resources/sintesi-diretta-1.png"/></div></div>     ovvero se la rete è in uno degli intervalli sicuri (<span class="math-span">\( N \geq 12\)</span> o <span class="math-span">\( N \lt  8\)</span>) allora si deve memorizzare <span class="math-span">\( NGE12\)</span>, altrimenti il valore che si era memorizzato in precedenza.     <br/>     Per completare la rete è ora sufficiente creare le reti combinatorie che costruiscono <span class="math-span">\( NGE12\)</span> e <span class="math-span">\( NLT8\)</span>:     <ul class="list-container"><li class="list-item">in binario si ha che il numero <span class="math-span">\( 12)_{10}\)</span> è rappresentato come <span class="math-span">\( 1100)_{2}\)</span>, si avrà quindi che i numeri maggiori o uguali a <span class="math-span">\( 12\)</span> sono caratterizzati dal mintermine <span class="math-span">\( NGE12 = N3 \cdot N2\)</span>;         </li><li class="list-item">in binario si ha che il numero <span class="math-span">\( 8)_{10}\)</span> è rappresentato come <span class="math-span">\( 1000)_{2}\)</span>, si avrà quindi che i numeri minori di <span class="math-span">\( 8\)</span> sono caratterizzati dal mintermine <span class="math-span">\( NLT8 = N3'\)</span>.     </li></ul>     ovvero     <div class="image-environment"><div class="image-wrapper spaced-50"><img alt="Immagine" src="../resources/nge12-nlt8.png"/></div></div></div></div>
            </article>
            <nav class="buttons-container content-width">
                <a class="navigation-button previous" href="reti-sequenziali-sincrone.html" rel="nofollow"><span>Reti sequenziali sincrone</span></a>
                <a class="navigation-button next" href="shift-register.html" rel="nofollow"><span>Shift Register</span></a>
            </nav>
        </section>
        <div class="scroll-to-bottom-button" onclick="scroll_to_bottom()">
            <span class="material-symbols-outlined">
                keyboard_double_arrow_down
            </span>
        </div>
        <footer class="footer-wrapper">
            <div class="copyright-wrapper">
                <span> &copy; Copyright 2023</span> /
                <span>made by lorenzoarlo</span>
            </div>
            /
            <div class="privacy-wrapper">
                <span><a href="https://lorenzoarlo.github.io/privacy-and-cookies/" rel="nofollow">Pannello preferenze cookie</a></span> /
                <span><a href="https://lorenzoarlo.github.io/privacy-and-cookies/privacy-policy.html" rel="nofollow" target="_blank" >Privacy Policy</a></span>
            </div>
        </footer>
    </div>
</body>
</html>