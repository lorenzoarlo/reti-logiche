<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="stylesheet" href="../styles/style.css" />
    <link rel="stylesheet" href="../styles/index-style.css" />
    <link rel="stylesheet" href="../styles/content-style.css" />
    <link rel="icon" type="image/x-icon" href="../resources/favicon.ico">
    <link rel="apple-touch-icon" href="../resources/favicon.png" />
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-78NHLXDQD8"></script>
    <script src="../scripts/script.js"></script>
    <style>:root { --bg-clr: #ff7f50; --fg-clr: #262626; }</style>
    <meta name="theme-color" content="#ff7f50" />
    <meta name="keywords" content="reti logiche, reti combinatorie, reti sequenziali" />
    <meta name="description" content="Il seguente sito contiene gli appunti e le definizioni del corso 'Reti logiche'.">
    <meta name="robots" content="index">
    <script defer async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <title>Reti logiche - Reti sequenziali sincrone - Shift Register</title>
</head>
<body>
    <div class="container">
        <header class="header-wrapper">
            <div class="title-wrapper">
                <span class="title">
                    Reti logiche
                </span>
                <span class="subtitle">
                    by lorenzoarlo
                </span>
            </div>
            <span class="page-title">
                Reti sequenziali sincrone
            </span>
        </header>
        <section class="content-wrapper">
            <h1 class="section-title content-width">Shift Register</h1>
            <article class="content-container content-width">
                <div class="definition environment" id="def5-10"><h2 class="environment-title">Definizione - Logical Shift Register</h2><div class="environment-body">     Un Logical Shift Register è una rete logica sincrona in grado di memorizzare gli <strong>ultimi</strong><span class="math-span">\( k\)</span> bit ricevuti.      <br/>     Durante la regolare attività esso fornisce in uscita al bit <span class="math-span">\( OUT[k - 1]\)</span> (ovvero "l'ultimo" della "coda") il segnale inserito all'istante precedente.     <div class="image-environment"><div class="image-wrapper spaced-60"><img alt="Immagine" src="../resources/base-shift-register.png"/></div></div>     I possibili ingressi di questo componente sono:     <ul class="list-container"><li class="list-item">un ingresso <span class="math-span">\( CLK\)</span> per il segnale di clock;         </li><li class="list-item">un ingresso sincrono <span class="math-span">\( LD\)</span> che permette di caricare tutti i <span class="math-span">\( k\)</span> bit forniti nell'ingresso <span class="math-span">\( I[...]\)</span>;         </li><li class="list-item">un bus di <span class="math-span">\( k\)</span> segnali sincroni in ingresso <span class="math-span">\( I[k - 1, \ldots, 0]\)</span>;         </li><li class="list-item">un ingresso sincrono <span class="math-span">\( EN\)</span> che regola se il registro deve continuare a mantenere i dati in memoria (<span class="math-span">\( EN = 0\)</span>) oppure se effettuare lo "scorrimento" (<span class="math-span">\( EN = 1\)</span>);         </li><li class="list-item">un ingresso sicrono <span class="math-span">\( IN\)</span> che indica qual è l'ultimo bit da inserire;         </li><li class="list-item">un ingresso sincrono <span class="math-span">\( R/L'\)</span> ("Right / Left'") che consente di variare la direzione dello shift;         </li><li class="list-item">un ingresso asincrono <span class="math-span">\( A\_RESET\)</span> che carica      </li></ul>     È necessario comunque considerare ingressi con priorità. Ad esempio considerando l'ingresso <span class="math-span">\( LD\)</span> come il più prioritario, si avrebbe che gli altri ingressi hanno effetto solo nel caso <span class="math-span">\( LD = 0\)</span>. Analogamente, si avrebbe che gli ingressi <span class="math-span">\( IN\)</span> e <span class="math-span">\( R/L'\)</span> hanno significato solo se <span class="math-span">\( EN = 1\)</span>.     <br/>     L'implementazione del comportamento base (ovvero di uno shift register dotato dei soli ingressi <span class="math-span">\( EN\)</span> e <span class="math-span">\( IN\)</span> con scorrimento a destra) è molto semplice e sfrutta il fatto che nei flip-flop il tempo di hold è minore del tempo di risposta. Si ha infatti la seguente rete:     <div class="image-environment"><div class="image-wrapper spaced-80"><img alt="Immagine" src="../resources/shift-register-circuito.png"/></div></div><div class="mynote environment"><h3 class="environment-title">Osservazioni personali - Scorrimento a sinistra, scorrimento a destra</h3><div class="environment-body">         Immaginando un registro a <span class="math-span">\( k\)</span> bit la cui memoria è la seguente         <div class="image-environment"><div class="image-wrapper spaced-40"><img alt="Immagine" src="../resources/generated-109.png"/></div></div>         si hanno due possibili comportamenti:         <ul class="list-container"><li class="list-item">lo scorrimento a destra, ovvero si ha che il bit dell'ingresso <span class="math-span">\( IN\)</span> è inserito in memoria nella posizione <span class="math-span">\( k - 1\)</span>. Il comportamento sarebbe quindi il seguente:             <div class="image-environment"><div class="image-wrapper spaced-50"><img alt="Immagine" src="../resources/generated-110.png"/></div></div></li><li class="list-item">lo scorrimento a sinistra, ovvero si ha che il bit dell'ingresso <span class="math-span">\( IN\)</span> è inserito in memoria nella posizione <span class="math-span">\( 0\)</span>. Il comportamento sarebbe quindi il seguente:             <div class="image-environment"><div class="image-wrapper spaced-50"><img alt="Immagine" src="../resources/generated-111.png"/></div></div></li></ul></div></div></div></div><div class="definition environment" id="def5-11"><h2 class="environment-title">Definizione - Universal Shift Register</h2><div class="environment-body">     Una versione possibile di Logical Shift Register è l'Universal Shift Register che implementa le varie funzionalità messe a disposizione dallo Shift Register con diversi ingressi, attraverso dei codici. Si ha quindi che, considerando il componente relativo alla seguente rete     <div class="image-environment"><div class="image-wrapper spaced-80"><img alt="Immagine" src="../resources/universal-shift-register-circuito.png"/></div></div>     i codici operativi sarebbero:     <ul class="list-container"><li class="list-item"><span class="math-span">\( S_{1} = 0\)</span> e <span class="math-span">\( S_{0} = 0\)</span> per il comando di "hold";         </li><li class="list-item"><span class="math-span">\( S_{1} = 0\)</span> e <span class="math-span">\( S_{0} = 1\)</span> per il comando di "shit a destra";         </li><li class="list-item"><span class="math-span">\( S_{1} = 1\)</span> e <span class="math-span">\( S_{0} = 0\)</span> per il comando di "shift a sinistra";         </li><li class="list-item"><span class="math-span">\( S_{1} = 1\)</span> e <span class="math-span">\( S_{0} = 1\)</span> per il comando di "load";     </li></ul></div></div><div class="definition environment" id="def5-12"><h2 class="environment-title">Definizione - Comunicazione in serie e in parallelo</h2><div class="environment-body">     Quando si comunica un'informazione è possibile che questa "arrivi a destinazione" attraverso la sequenza di informazioni di un singolo segnale in sequenza (comunicazione seriale), oppure attraverso più segnali in contemporanea (comunicazione parallela).     <br/>     Ovviamente, generalmente la comunicazione in parallelo risulta essere più efficiente anche se porta con sé diverse difficolta, tra cui:     <ul class="list-container"><li class="list-item">necessità di schermare le vie di comunicazione per evitare interferenze;         </li><li class="list-item">necessità di un protocollo per gestire il sincronismo tra i segnali;         </li><li class="list-item">impossibilità di mantenere la stabilità su lunghe distanze.      </li></ul>     Si decide quindi di utilizzare la comunicazione in parallelo in componenti interni (come la scheda madre) in cui è possibile avere più controllo. Per altri utilizzi, invece, si utilizza la comunicazione in serie che risulta essere meno costosa e complessa permettendo un maggiore sviluppo tecnologico (si veda del caso dei cavetti USB, "Universal Serial Bus"). </div></div><div class="definition environment" id="def5-13"><h2 class="environment-title">Definizione - Utilizzare uno Shift Register per la conversione da comunicazione seriale a parallela</h2><div class="environment-body">     Una rete che effettua la conversione tra comunicazione seriale e in parallelo secondo Moore è la seguente     <div class="image-environment"><div class="image-wrapper spaced-80"><img alt="Immagine" src="../resources/conversione-serie-parallelo-moore.png"/></div></div>     Si avrà quindi che per ottenere un dato in parallelo di <span class="math-span">\( k\)</span> bit da uno in serie sono necessari <span class="math-span">\( k\)</span> flip-flop e ogni informazione è valida ogni <span class="math-span">\( k\)</span> cicli di clock.     <br/>     È possibile realizzare anche la rete secondo Mealy nel seguente modo:     <div class="image-environment"><div class="image-wrapper spaced-80"><img alt="Immagine" src="../resources/conversione-serie-parallelo-mealy.png"/></div></div>     In questo caso sono necessari <span class="math-span">\( k - 1\)</span> flip-flop e l'informazione è valida ogni <span class="math-span">\( k - 1\)</span> cicli di clock. Nonostante ciò si ottiene che una delle uscite non è "stabilizzata" dal flip-flop rendendola soggetta a possibili problemi.     <br/>     In entrambi i casi si hanno reti equivalenti ad uno shift register, ovvero al componente privilegiato per questo compito </div></div><div class="definition environment" id="def5-14"><h2 class="environment-title">Definizione - Utilizzare uno Shift Register per la conversione da comunicazione parallela a seriale</h2><div class="environment-body">     Una rete che effettua la conversione tra comunicazione in parallelo e in serie secondo Moore è la seguente:     <div class="image-environment"><div class="image-wrapper spaced-80"><img alt="Immagine" src="../resources/conversione-parallelo-serie-moore.png"/></div></div>     Si avrà quindi che ad ogni ciclo di clock sarà presente il bit desiderato sull'uscita <span class="math-span">\( OUT[0]\)</span>.     <br/>     Ciò equivale ad utilizzare uno shift register nel seguente modo:     <div class="image-environment"><div class="image-wrapper spaced-80"><img alt="Immagine" src="../resources/shift-register-parallelo-serie.png"/></div></div>     ovvero equivale a fornire in ingresso i bit nell'ordine inverso rispetto a ciò che si vuole come risultato in serie. </div></div><div class="definition environment" id="def5-15"><h2 class="environment-title">Definizione - Utilizzare uno Shift Register per effettuare moltiplicazioni e divisioni</h2><div class="environment-body">     Considerando un qualsiasi numero binario unsigned, si ha che il suo shift (e l'ingresso di uno <span class="math-span">\( 0\)</span>) effettui una moltiplicazione (shift verso sinistra) o una divisione intera (shift verso destra) per <span class="math-span">\( 2\)</span>.     <br/>     È quindi possibile svolgere delle moltiplicazioni tra numeri binari utilizzando delle reti sincrone (nonostante queste siano ottenibili anche da un circuito combinatorio).     <br/>     Ad esempio, considerando il numero binario <span class="math-span">\( 01101)_{2}\)</span> (uguale a <span class="math-span">\( 13)_{10}\)</span>) si ha che il suo shift verso sinistra     <div class="image-environment"><div class="image-wrapper spaced-50"><img alt="Immagine" src="../resources/generated-112.png"/></div></div>     è uguale a <span class="math-span">\( 11010)_{2}\)</span>, ovvero <span class="math-span">\( 26)_{2}\)</span>.     <br/>     Si ha inoltre che il bit più significativo del numero da moltiplicare (in questo caso <span class="math-span">\( bit_{4}\)</span>) indica se ci sarà overflow (nel caso esso sia <span class="math-span">\( 1\)</span>).     È quindi semplice utilizzare uno shift register per effettuare questa operazione.  </div></div><div class="myexample environment" id="example21"><h2 class="environment-title">Esempio - Sintesi diretta - <span class="math-span">\( k\)</span> bit multiplier</h2><div class="environment-body">     Progettare una rete asincrona secondo Moore che effettui la moltiplicazione tra due numeri di <span class="math-span">\( k\)</span> bit unsigned utilizzando shift register e adder. Si considerino quindi come fattori gli ingressi <span class="math-span">\( A[k - 1 , \ldots, 0]\)</span> e <span class="math-span">\( B[k - 1, \ldots, 0]\)</span> validi quando il segnale <span class="math-span">\( LD\)</span> è uguale a <span class="math-span">\( 1\)</span>.      Il risultato, fornito sull'uscita <span class="math-span">\( OUT[2 \cdot k - 1, \ldots, 0]\)</span>, deve essere disponibile fino a quando <span class="math-span">\( LD\)</span> non assumera nuovamente valore <span class="math-span">\( 1\)</span>.     <br/>     Per progettare la rete consideriamo l'algoritmo di moltiplicazione in colonna.     <div class="image-environment"><div class="image-wrapper spaced-30"><img alt="Immagine" src="../resources/generated-113.png"/></div></div>     Si ha che il risultato è la somma delle moltiplicazioni tra il primo fattore e ogni singola cifra del secondo (moltiplicata per il suo peso). Si avrà quindi che ogni addendo della somma avrà come valore quello del primo fattore moltiplicato per <span class="math-span">\( 2\)</span> per un numero di volte uguale alla sua posizione. Ovvero     <div class="image-environment"><div class="image-wrapper spaced-60"><img alt="Immagine" src="../resources/generated-114.png"/></div></div>     Un'idea potrebbe quindi essere effettuare lo shift (verso sinistra) di <span class="math-span">\( k\)</span> volte del primo fattore (in modo da moltiplicarlo ogni volta per <span class="math-span">\( 2\)</span>) e effettuare lo shift verso sinistra del secondo fattore (in modo da avere sempre il bit da moltiplicare nella stessa posizione). Ad ogni ciclo di clock si ottiene quindi una somma parziale che dovrà essere memorizzata in un accumulatore.     <br/>     La rete sarà quindi così formata:     <div class="image-environment"><div class="image-wrapper spaced-90"><img alt="Immagine" src="../resources/kbit-multiplier.png"/></div></div>     dove <span class="math-span">\( B \ NOT \ 0\)</span> è un segnale che indica se <span class="math-span">\( B\)</span> è un numero non nullo (ovvero un OR con ogni bit di <span class="math-span">\( B\)</span> in ingresso). </div></div><div class="definition environment" id="def5-16"><h2 class="environment-title">Definizione - Shift aritmetico</h2><div class="environment-body">     Per permettere la moltiplicazione e divisione di numeri signed è possibile utilizzare lo shift aritmetico.     <br/>     Tale shift differisce di poco dallo shift logico, in particolare:     <ul class="list-container"><li class="list-item">nella divisione (ovvero shift verso destra) è sufficiente che il bit inserito sia uguale al MSB del numero (ovvero al segno, che non può cambiare).         </li><li class="list-item">nela moltiplicazione (ovvero shift verso sinistra) si continua ad aggiungere <span class="math-span">\( 0\)</span>. Tuttavia, per verificare l'overflow è sufficiente verificare che il segno del risultato sia uguale al segno del numero iniziale, o meglio, è necessario verificare che il MSB e il suo adiacente siano uguali.     </li></ul></div></div><div class="myexample environment" id="example22"><h2 class="environment-title">Esempio - Sintesi diretta - Riconoscitore di sequenze con shift register</h2><div class="environment-body">     Progettare una rete sequenziale sincrona che controlla se gli ultimi tre byte inseriti nell'ingresso <span class="math-span">\( IN[7, \ldots, 0]\)</span> mentre il segnale <span class="math-span">\( EN = 1\)</span> sono stati <span class="math-span">\( FF)_{16}\)</span>, <span class="math-span">\( 27)_{16}\)</span> e <span class="math-span">\( 30)_{16}\)</span> (dove <span class="math-span">\( FF)_{16}\)</span> è il primo byte della sequenza).     <br/>     Nel caso la sequenza sia rispettata, nel periodo di clock successivo l'uscita <span class="math-span">\( OUT\)</span> deve essere portata a <span class="math-span">\( 1\)</span> e rimanere tale fino a che l'ingresso asincrono <span class="math-span">\( A\_RESET\)</span> non è uguale a <span class="math-span">\( 1\)</span>: da quel momento la rete deve considerare che non fosse stato inserito alcun byte.     <br/>     Innanzitutto la rete è di Moore in quanto deve rispondere al clock successivo all'ultimo inserimento nella sequenza.     <br/>     Un modo (inefficiente) per riconoscere sequenze secondo Moore è porre degli Shift Register in serie per creare una coda che permetta di controllare ad ogni ciclo di clock se la sequenza è stata rispettata.     <br/>     Dato che in ingresso si hanno <span class="math-span">\( 8\)</span> bit ad ogni ciclo di clock, è necessario utilizzare <span class="math-span">\( 8\)</span> shift register da <span class="math-span">\( 3\)</span> bit in serie. In questo modo si avrà che:     <ul class="list-container"><li class="list-item">all'uscita <span class="math-span">\( OUT[2]\)</span> di ogni registro si hanno tutti i bit inseriti <span class="math-span">\( 3\)</span> cicli di clock fa;         </li><li class="list-item">all'uscita <span class="math-span">\( OUT[1]\)</span> di ogni registro si hanno tutti i bit inseriti <span class="math-span">\( 2\)</span> cicli di clock fa;         </li><li class="list-item">all'uscita <span class="math-span">\( OUT[0]\)</span> di ogni registro si hanno tutti i bit inseriti <span class="math-span">\( 1\)</span> ciclo di clock fa;     </li></ul>     In questo modo si potranno utilizzare delle reti combinatorie per confrontare i diversi byte.     <br/>     Pensando ora al mantenimento dell'ingresso, si può lavorare utilizzando l'ingresso <span class="math-span">\( EN\_SHIFT\)</span> per decidere quando abilitare lo shift register. <span class="math-span">\( EN\_SHIFT\)</span> deve essere abilitato quando <span class="math-span">\( EN=1\)</span> e <span class="math-span">\( OUT=0\)</span>. Si avrà quindi la seguente rete:     <div class="image-environment"><div class="image-wrapper spaced-80"><img alt="Immagine" src="../resources/riconosci-sequenze-shift-register.png"/></div></div>     Questa soluzione utilizza però un numero troppo elevato di componenti. È infatti sufficiente memorizzare solo se il byte è quello desiderato e per farlo conviene controllare inizialmente se il numero è quello corretto e memorizzarlo come singolo bit. Si avrà quindi la seguente rete:     <div class="image-environment"><div class="image-wrapper spaced-80"><img alt="Immagine" src="../resources/riconosci-sequenze-shift-register-better.png"/></div></div></div></div>
            </article>
            <nav class="buttons-container content-width">
                <a class="navigation-button previous" href="registri.html" rel="nofollow"><span>Registri</span></a>
                <a class="navigation-button next" href="monoimpulsore.html" rel="nofollow"><span>Monoimpulsore</span></a>
            </nav>
        </section>
        <div class="scroll-to-bottom-button" onclick="scroll_to_bottom()">
            <span class="material-symbols-outlined">
                keyboard_double_arrow_down
            </span>
        </div>
        <footer class="footer-wrapper">
            <div class="copyright-wrapper">
                <span> &copy; Copyright 2023</span> /
                <span>made by lorenzoarlo</span>
            </div>
            /
            <div class="privacy-wrapper">
                <span><a href="https://lorenzoarlo.github.io/privacy-and-cookies/" rel="nofollow">Pannello preferenze cookie</a></span> /
                <span><a href="https://lorenzoarlo.github.io/privacy-and-cookies/privacy-policy.html" rel="nofollow" target="_blank" >Privacy Policy</a></span>
            </div>
        </footer>
    </div>
</body>
</html>