<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="stylesheet" href="../styles/style.css" />
    <link rel="stylesheet" href="../styles/index-style.css" />
    <link rel="stylesheet" href="../styles/content-style.css" />
    <link rel="icon" type="image/x-icon" href="../resources/favicon.ico">
    <link rel="apple-touch-icon" href="../resources/favicon.png" />
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-78NHLXDQD8"></script>
    <script src="../scripts/script.js"></script>
    <style>:root { --bg-clr: #ff7f50; --fg-clr: #262626; }</style>
    <meta name="theme-color" content="#ff7f50" />
    <meta name="keywords" content="reti logiche, reti combinatorie, reti sequenziali" />
    <meta name="description" content="Il seguente sito contiene gli appunti e le definizioni del corso 'Reti logiche'.">
    <meta name="robots" content="index">
    <script defer async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <title>Reti logiche - Memorie binarie - Latch SR</title>
</head>
<body>
    <div class="container">
        <header class="header-wrapper">
            <div class="title-wrapper">
                <span class="title">
                    Reti logiche
                </span>
                <span class="subtitle">
                    by lorenzoarlo
                </span>
            </div>
            <span class="page-title">
                Memorie binarie
            </span>
        </header>
        <section class="content-wrapper">
            <h1 class="section-title content-width">Latch SR</h1>
            <article class="content-container content-width">
                <div class="definition environment" id="def5-1"><h2 class="environment-title">Definizione - Memoria binaria</h2><div class="environment-body">     Una memoria binaria è un circuito in grado di memorizzare il valore di un bit.     <br/>     Esse sono realizzate utilizzando delle RSA e sono uno dei componenti primitivi più importanti, in quanto sono utilizzate per realizzare reti sincrone e, ad esempio, circuiti come le RAM.     <br/>     In base alla sequenza di ingressi che porta alla scrittura di un bit e quando sono sensibili a comandi di modifica, si hanno tre tipi di memorie:     <ul class="list-container"><li class="list-item">Latch SR;         </li><li class="list-item">Latch CD;         </li><li class="list-item">Flip-flop D.     </li></ul></div></div><div class="definition environment" id="def5-2"><h2 class="environment-title">Definizione - Latch SR</h2><div class="environment-body">     Il Latch SR     <div class="image-environment"><div class="image-wrapper spaced-50"><img alt="Immagine" src="../resources/latch-sr.png"/></div></div>     è la memoria binaria più semplice ed è caratterizzata da:     <ul class="list-container"><li class="list-item">un ingresso di set <span class="math-span">\( S\)</span>;         </li><li class="list-item">un ingresso di reset <span class="math-span">\( R\)</span>;         </li><li class="list-item">due uscite che rendono disponibile il valore del bit memorizzato (<span class="math-span">\( Q\)</span>) ed il suo complemento (<span class="math-span">\( Q'\)</span>).     </li></ul>     Il comportamento della rete è il seguente:     <div class="image-environment"><div class="image-wrapper spaced-80"><img alt="Immagine" src="../resources/generated-90.png"/></div></div>     Essa è quindi una rete sequenziale dato che alla configurazione <span class="math-span">\( 00\)</span> possono corrispondere due uscite differenti e non è previsto l'utilizzo della configurazione <span class="math-span">\( 11\)</span> nell'uso corretto della rete. Il grafo degli stati che descrive questo componente è il seguente     <div class="image-environment"><div class="image-wrapper spaced-40"><img alt="Immagine" src="../resources/generated-91.png"/></div></div>     dove gli stati <span class="math-span">\( A\)</span> e <span class="math-span">\( B\)</span> indicano     <div class="image-environment"><div class="image-wrapper spaced-30"><img alt="Immagine" src="../resources/generated-92.png"/></div></div>      Dal grafo degli stati è quindi facile derivare la tabella di flusso     <div class="image-environment"><div class="image-wrapper spaced-50"><img alt="Immagine" src="../resources/generated-93.png"/></div></div>     da cui è semplice derivare la tabella delle transizioni     <div class="image-environment"><div class="image-wrapper spaced-50"><img alt="Immagine" src="../resources/generated-94.png"/></div></div>     da cui è facile ottenere la sintesi combinatoria:     <ul class="list-container"><li class="list-item">l'uscita <span class="math-span">\( Q\)</span> è uguale alla sola variabile di stato <span class="math-span">\( y\)</span>;         </li><li class="list-item">lo stato futuro <span class="math-span">\( Y\)</span> può essere sintetizzato in diversi modi (che saranno trattati in seguito).     </li></ul></div></div><div class="definition environment" id="def5-3"><h2 class="environment-title">Definizione - Latch SR - Sintesi PS e a NOR dello stato futuro</h2><div class="environment-body">     Data la tabella della verità dello stato futuro del Latch SR     <div class="image-environment"><div class="image-wrapper spaced-40"><img alt="Immagine" src="../resources/generated-95.png"/></div></div>     è semplice ottenere la sintesi PS, ovvero     <div class="image-environment"><div class="image-wrapper spaced-40"><img alt="Immagine" src="../resources/generated-96.png"/></div></div>     che equivale all'espressione <span class="math-span">\( Y = \bar{R} \cdot (y + S)\)</span> e al circuito     <div class="image-environment"><div class="image-wrapper spaced-50"><img alt="Immagine" src="../resources/latch-sr-PS.png"/></div></div>     Per ottenere quindi l'uscita complementata <span class="math-span">\( Q'\)</span> è necessario utilizzare anche un NOT.     <br/>     È invece possibile trasformare l'espressione in una sintesi a NOR, da cui si ottiene l'espressione     <span class="math-block">\[         Y = R \downarrow (y \downarrow S)         \]</span>     che equivale al seguente circuito     <div class="image-environment"><div class="image-wrapper spaced-50"><img alt="Immagine" src="../resources/latch-sr-nor.png"/></div></div>     dove è già fornita l'uscita complementata.     <div class="mynote environment"><h3 class="environment-title">Osservazioni personali - Uscita complementata e configurazione vietata <span class="math-span">\( 11\)</span></h3><div class="environment-body">         Per verificare che il circuito fornisca l'uscita complementata è necessario verificare che la tabella della verità delle due uscite sia coerente, ovvero che         <span class="math-block">\[             S \downarrow y =_{?} \overline{R \downarrow (y \downarrow S)}         \]</span>         Costruendo la tabella della verità si ottiene         <div class="image-environment"><div class="image-wrapper spaced-40"><img alt="Immagine" src="../resources/generated-97.png"/></div></div>         Come si può notare le due uscite sono coerenti per le diverse configurazioni ad eccezione di tre casistiche:         <ul class="list-container"><li class="list-item">con la configurazione degli ingressi <span class="math-span">\( 11\)</span>, che non risulta essere un problema in quanto la configurazione è vietata nell'uso corretto della rete;             </li><li class="list-item">con lo stato corrente <span class="math-span">\( 1\)</span> (ovvero lo stato "Memorizzo <span class="math-span">\( 1\)</span>") e la configurazione di ingressi <span class="math-span">\( 01\)</span> (che equivalgono all'azione "Scrivi <span class="math-span">\( 0\)</span>"), che non risulta essere un problema in quanto cambiando un bit di ingresso alla volta risulta impossibile trovarsi in questa situazione (in quanto la configurazione di ingressi <span class="math-span">\( 01\)</span> porterebbe ad essere nello stato <span class="math-span">\( y = 0\)</span>).         </li></ul></div></div></div></div><div class="definition environment" id="def5-4"><h2 class="environment-title">Definizione - Latch SR - Sintesi SP e a NAND dello stato futuro</h2><div class="environment-body">     Analogamente come per la sintesi PS, è facile ottenere dalla tabella della verità dello stato futuro del Latch SR     <div class="image-environment"><div class="image-wrapper spaced-40"><img alt="Immagine" src="../resources/generated-98.png"/></div></div>     la sintesi SP     <div class="image-environment"><div class="image-wrapper spaced-40"><img alt="Immagine" src="../resources/generated-99.png"/></div></div>     che equivale all'espressione <span class="math-span">\( Y = S \cdot (y + \bar{R})\)</span> e al circuito     <div class="image-environment"><div class="image-wrapper spaced-50"><img alt="Immagine" src="../resources/latch-sr-SP.png"/></div></div>     Anche in questo caso è conveniente effettuare la sintesi a NAND per ottere l'uscita complementata, da cui si ottiene l'espressione     <span class="math-block">\[         Y = \bar{S} \uparrow (y + \bar{R})         \]</span>     e il circuito     <div class="image-environment"><div class="image-wrapper spaced-50"><img alt="Immagine" src="../resources/latch-sr-nand.png"/></div></div><div class="mynote environment"><h3 class="environment-title">Osservazioni personali - Latch <span class="math-span">\( \bar{S}\bar{R}\)</span></h3><div class="environment-body">         Nel caso il Latch sia realizzato con la sintesi a NAND, esso è anche chiamato Latch <span class="math-span">\( \bar{S}\bar{R}\)</span> in quanto richiede gli ingressi complementati.     </div></div></div></div><div class="definition environment" id="def5-5"><h2 class="environment-title">Definizione - Stato iniziale nei Latch SR</h2><div class="environment-body">     Essendo il Latch SR una rete sequenziale, "soffre" anch'essa della casualità dello stato iniziale:      se in casi come le RAM ciò non risulta essere un problema, in altri casi è necessario che tali valori sia predeterminati.     <br/>     Esistono per questo motivo delle varianti di questo componente che introducono degli ingressi con priorità maggiore rispetto agli ingressi <span class="math-span">\( S\)</span> e <span class="math-span">\( R\)</span>:     <div class="image-environment"><div class="image-wrapper spaced-50"><img alt="Immagine" src="../resources/latch-sr-init.png"/></div></div><ul class="list-container"><li class="list-item">l'ingresso di preset (indicato con <span class="math-span">\( PRE'\)</span> dato che l'ingresso è attivo basso) che forza il latch a memorizzare il bit <span class="math-span">\( 1\)</span>;         </li><li class="list-item">l'ingresso di clear (indicato con <span class="math-span">\( CLR'\)</span> dato che l'ingresso è attivo basso) che forza il latch a memorizzare il bit <span class="math-span">\( 0\)</span>.     </li></ul>     Anche questi ingressi non possono essere chiaramente attivi in contemporanea.     <br/>     L'idea è quindi quella di creare una rete di combinatoria di inizializzazione che "pilota" il latch durante durante l'inizializzazione e il cui comportamento è il seguente (dove <span class="math-span">\( S_{2}\)</span>, <span class="math-span">\( R_{2}\)</span> sono le uscite della rete combinatoria che andranno poi a pilotare il "vero" latch)     <div class="image-environment"><div class="image-wrapper spaced-50"><img alt="Immagine" src="../resources/generated-100.png"/></div></div>     da cui è possibile ottenere le seguenti espressioni:     <span class="math-block">\begin{aligned}         &amp; S_{2} = PRE + (\overline{CLR} \cdot S)         &amp; R_{2} = CLR + (\overline{PRE} \cdot R)     \end{aligned}</span>     equivalenti alla seguente rete:     <div class="image-environment"><div class="image-wrapper spaced-75"><img alt="Immagine" src="../resources/latch-sr-init-circuit.png"/></div></div>     Tale circuito potrebbe essere inoltre ulteriormente semplificato conoscendo la struttura del Latch SR (unendo l'OR ed il NOR ad esempio) oppure realizzare la rete combinatoria più adatta per "pilotare" un Latch <span class="math-span">\( \overline{S}\overline{R}\)</span>.     <br/>     Tale componente potrebbe essere utilizzato nel seguente modo     <div class="image-environment"><div class="image-wrapper spaced-75"><img alt="Immagine" src="../resources/latch-init-0.png"/></div></div>     per memorizzare inizialmente <span class="math-span">\( 0\)</span>, e nel seguente modo per memorizzare <span class="math-span">\( 1\)</span><div class="image-environment"><div class="image-wrapper spaced-75"><img alt="Immagine" src="../resources/latch-init-1.png"/></div></div></div></div><div class="definition environment" id="def5-6"><h2 class="environment-title">Definizione - Durata minima degli ingressi e metastabilità</h2><div class="environment-body">     La durata minima degli ingressi di un latch è di <span class="math-span">\( 2 \cdot \tau_{p}\)</span> ed è solitamente indicata dal costruttore con la dicitura "pulse duration".     <br/>     Nel caso non si rispetti questa durata minima, si ha che il latch può andare in metastabilità.     <div class="mynote environment"><h3 class="environment-title">Osservazioni personali - Un po' di elettronica</h3><div class="environment-body">         Considerando il segnale di stato del Latch, esso può essere "diviso idealmente in due", ovvero in stato presente <span class="math-span">\( q\)</span> e stato futuro <span class="math-span">\( Q\)</span> (il valore dello stato che si avrà tra <span class="math-span">\( 2\tau_{p}\)</span>).         <br/>         Idealmente tale bit assume solo due valori ("High" e "Low"), invece nella realtà è un segnale analogico che assume un numero infinito di valori e che si considera H o L in base alla vicinanza rispetto ad un valore predefinito.         <div class="image-environment"><div class="image-wrapper spaced-70"><img alt="Immagine" src="../resources/grafico-h-l.png"/></div></div>         Il segnale è tuttavia soggetto a rumore (a causa di fenomeni fisici inevitabili) e per rendere il circuito il più robusto possibile si decide di modificare la pendenza della retta che descrive il rapporto <span class="math-span">\( Q = q\)</span> nel seguente modo          <div class="image-environment"><div class="image-wrapper spaced-70"><img alt="Immagine" src="../resources/grafico-h-l-pendenze.png"/></div></div>         In questo modo si ottengono due effetti:         <ul class="list-container"><li class="list-item">nelle zone in cui la pendenza è minore di <span class="math-span">\( 1\)</span> si rende il circuito più incline alla stabilità;             </li><li class="list-item">nelle zone in cui la pendenza è maggiore di <span class="math-span">\( 1\)</span> si rende il circuito meno stabile;         </li></ul>         Infatti, ipotizzando di avere un segnale al margine della zona di tolleranza <span class="math-span">\( H\)</span>, esso (ricordando che stiamo trattando segnali in retroazione) seguirà il seguente percorso         <div class="image-environment"><div class="image-wrapper spaced-70"><img alt="Immagine" src="../resources/metastabilita-pendenza-minore-1.png"/></div></div>         ovvero tenderà alla stabilità. Nel caso si avesse una pendenza maggiore di <span class="math-span">\( 1\)</span>, ciò porterebbe invece all'effetto contrario.         <br/>         Tuttavia per poter ottenere le pendenze corrette nelle zone di campionamento, è necessario "inserire" una zona con pendenza maggiore di <span class="math-span">\( 1\)</span> e ciò porta alla creazione di un terzo "punto focale M" (oltre ai punti focali "H" e "L"). Tale punto è detto di metastabilità in quanto non si può assumere che sia "H" o "L" e al primo disturbo assumerà un valore indeterminabile.         <br/>         È quindi necessario rispettare il vincolo di "pulse-duration" affinchè la rete funzioni correttamente.     </div></div></div></div>
            </article>
            <nav class="buttons-container content-width">
                <a class="navigation-button previous" href="index.html" rel="nofollow"><span>Memorie binarie</span></a>
                <a class="navigation-button next" href="latch-cd.html" rel="nofollow"><span>Latch CD</span></a>
            </nav>
        </section>
        <div class="scroll-to-bottom-button" onclick="scroll_to_bottom()">
            <span class="material-symbols-outlined">
                keyboard_double_arrow_down
            </span>
        </div>
        <footer class="footer-wrapper">
            <div class="copyright-wrapper">
                <span> &copy; Copyright 2023</span> /
                <span>made by lorenzoarlo</span>
            </div>
            /
            <div class="privacy-wrapper">
                <span><a href="https://lorenzoarlo.github.io/privacy-and-cookies/" rel="nofollow">Pannello preferenze cookie</a></span> /
                <span><a href="https://lorenzoarlo.github.io/privacy-and-cookies/privacy-policy.html" rel="nofollow" target="_blank" >Privacy Policy</a></span>
            </div>
        </footer>
    </div>
</body>
</html>