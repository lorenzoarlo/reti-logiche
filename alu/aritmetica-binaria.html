<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="stylesheet" href="../styles/style.css" />
    <link rel="stylesheet" href="../styles/index-style.css" />
    <link rel="stylesheet" href="../styles/content-style.css" />
    <link rel="icon" type="image/x-icon" href="../resources/favicon.ico">
    <link rel=”apple-touch-icon” href=”../resources/favicon.ico” />
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-78NHLXDQD8"></script>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5785471996225878" crossorigin="anonymous"></script>
    <script src="../scripts/script.js"></script>
    <style>:root { --bg-clr: #ff7f50; --fg-clr: #262626; }</style>
    <meta name="theme-color" content="#ff7f50" />
    <meta name="keywords" content="reti logiche, reti combinatorie, reti sequenziali" />
    <meta name="description" content="Il seguente sito contiene gli appunti e le definizioni del corso 'Reti logiche'.">
    <meta name="robots" content="index">
    <script defer async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <title>Reti logiche - ALU - Aritmetica binaria</title>
</head>
<body>
    <div class="container">
        <header class="header-wrapper">
            <div class="title-wrapper">
                <span class="title">
                    Reti logiche
                </span>
                <span class="subtitle">
                    by lorenzoarlo
                </span>
            </div>
            <span class="page-title">
                ALU
            </span>
        </header>
        <section class="content-wrapper">
            <h1 class="section-title">Aritmetica binaria</h1>
            <article class="content-container content-width">
                <div class="definition environment" id="def3-1">
 <h2 class="environment-title">
  Definizione -
  Aritmetica binaria tra numeri unsigned
 </h2>
 <div class="environment-body">
  Il procedimento per effettuare operazioni di somma e differenza tra numeri binari non è differente dalle operazioni in colonna con i numeri decimali.
  <br/>
  Si aggiunge tuttavia il concetto di overflow, dovuto al fatto che nei sistemi digitali si ha un numero fisso e finito di cifre disponibili (e quindi un numero massimo rappresentabile): ipotizzando infatti di dedicare
  <span class="math-span">
   \( 4\)
  </span>
  bit per la rappresentazione di un numero, si ha che il massimo numero rappresentabile è
  <span class="math-span">
   \( 15\)
  </span>
  (
  <span class="math-span">
   \( 2^{n} - 1\)
  </span>
  ). Sommando quindi (ad esempio) i numeri
  <span class="math-span">
   \( 11\)
  </span>
  e
  <span class="math-span">
   \( 10\)
  </span>
  (entrambi rappresentabili con
  <span class="math-span">
   \( 4\)
  </span>
  bit), si otterrebbe il valore
  <span class="math-span">
   \( 21\)
  </span>
  (che necessiterebbe di almeno
  <span class="math-span">
   \( 5\)
  </span>
  bit).
  <div class="image-environment">
   <div class="image-wrapper spaced-40">
    <img alt="Immagine" src="../resources/generated-48.png"/>
   </div>
  </div>
  Tale concetto è facilmente osservabile dalla presenza dell'ultimo bit di riporto (il "carry out") a
  <span class="math-span">
   \( 1\)
  </span>
  .
 </div>
</div>
<div class="definition environment" id="def3-2">
 <h2 class="environment-title">
  Definizione -
  Adder
 </h2>
 <div class="environment-body">
  L'adder è il circuito combinatorio che realizza la somma.
  <br/>
  Invece di progettare una rete con
  <span class="math-span">
   \( 2 \cdot n\)
  </span>
  ingressi (
  <span class="math-span">
   \( n\)
  </span>
  per ogni numero), si può notare la possibilità di adottare un approccio modulare: ciò che è vero per due numeri fatti di un singolo bit, può essere ripetuto per
  <span class="math-span">
   \( n\)
  </span>
  volte (aggiungendo il riporto).     Sarà quindi sufficiente creare una rete che somma tre bit (i due bit in ingresso
  <span class="math-span">
   \( a_{i}\)
  </span>
  e
  <span class="math-span">
   \( b_{i}\)
  </span>
  aggiunti del bit di riporto precedenti
  <span class="math-span">
   \( r_{i}\)
  </span>
  ) e che restituisce il bit somma
  <span class="math-span">
   \( s_{i}\)
  </span>
  e il bit di riporto successivo
  <span class="math-span">
   \( r_{i + 1}\)
  </span>
  .
 </div>
</div>
<div class="definition environment" id="def3-3">
 <h2 class="environment-title">
  Definizione -
  Half Adder
 </h2>
 <div class="environment-body">
  L'Half Adder prevede la presenza di due soli bit di ingresso (
  <span class="math-span">
   \( a_{i}\)
  </span>
  e
  <span class="math-span">
   \( b_{i}\)
  </span>
  ) e può essere realizzato semplicemente nel seguente modo:
  <div class="image-environment">
   <div class="image-wrapper spaced-75">
    <img alt="Immagine" src="../resources/sintesi-half-adder.png"/>
   </div>
  </div>
  Per quanto riguarda il bit somma
  <span class="math-span">
   \( s_{i}\)
  </span>
  , può essere ottenuto utilizzando un gate XOR (che realizza proprio la somma logica), mentre per il riporto si utilizza un gate AND (che verifica la presenza di due bit a
  <span class="math-span">
   \( 1\)
  </span>
  ).
 </div>
</div>
<div class="definition environment" id="def3-4">
 <h2 class="environment-title">
  Definizione -
  Full Adder
 </h2>
 <div class="environment-body">
  Il Full Adder riesce a sommare i due bit di ingresso
  <span class="math-span">
   \( a_{i}\)
  </span>
  e
  <span class="math-span">
   \( b_{i}\)
  </span>
  ed un terzo bit di riporto
  <span class="math-span">
   \( r_{i}\)
  </span>
  e può essere realizzato così:
  <div class="image-environment">
   <div class="image-wrapper spaced-75">
    <img alt="Immagine" src="../resources/sintesi-full-adder.png"/>
   </div>
  </div>
  Esso è realizzato ponendo due Half Adder in serie: il bit somma
  <span class="math-span">
   \( s_{i}\)
  </span>
  è realizzato grazie agli XOR, mentre il bit di riporto
  <span class="math-span">
   \( r_{i + 1}\)
  </span>
  si ottiene valutando la presenza di almeno un riporto dei due Half Adder (con un gate OR).
 </div>
</div>
<div class="definition environment" id="def3-5">
 <h2 class="environment-title">
  Definizione -
  Adder a
  <span class="math-span">
   \( n\)
  </span>
  bit
 </h2>
 <div class="environment-body">
  In base alle necessità, è possibile realizzare un Adder a
  <span class="math-span">
   \( n\)
  </span>
  bit in due diversi modi.
  <br/>
  Nel caso lo si realizzi ponendo in serie un Half Adder e
  <span class="math-span">
   \( n - 1\)
  </span>
  Full Adder si ottiene una rete a due ingressi (ognuno dei quali è un bus di
  <span class="math-span">
   \( n\)
  </span>
  bit) e in uscita ha un bus di
  <span class="math-span">
   \( n\)
  </span>
  bit che rappresenta la somma e un segnale ad un bit detto
  <span class="math-span">
   \( c_{out}\)
  </span>
  ("
  <i>
   carry out
  </i>
  ", ovvero il riporto).
  <br/>
  Nel caso invece lo si realizzi ponendo in serie
  <span class="math-span">
   \( n\)
  </span>
  Full Adder, si ottiene una rete analoga alla precedente ma che tuttavia prevede un bit in ingresso detto
  <span class="math-span">
   \( c_{in}\)
  </span>
  ("
  <i>
   carry in
  </i>
  " ovvero il riporto in ingresso). In questo modo è possibile disporre in serie
  <span class="math-span">
   \( m\)
  </span>
  Full Adder per ottenere un Full Adder
  <span class="math-span">
   \( m \cdot n\)
  </span>
  bit.
 </div>
</div>
<div class="definition environment" id="def3-6">
 <h2 class="environment-title">
  Definizione -
  Complemento a
  <span class="math-span">
   \( \beta - 1\)
  </span>
 </h2>
 <div class="environment-body">
  Considerando un numero
  <span class="math-span">
   \( a\)
  </span>
  di
  <span class="math-span">
   \( n\)
  </span>
  cifre in base
  <span class="math-span">
   \( \beta\)
  </span>
  , si dice che il complemento a
  <span class="math-span">
   \( \beta - 1\)
  </span>
  di tale numero è dato da
  <span class="math-block">
   \[         (\beta^{n} - 1) - a        \]
  </span>
  Da come si può dedurre da tale formula, il complemento a
  <span class="math-span">
   \( \beta - 1\)
  </span>
  di un numero indica la differenza tra il massimo numero rappresentabile con
  <span class="math-span">
   \( n\)
  </span>
  bit ed il numero stesso.
  <br/>
  Nell'aritmentica binaria, il complemento a
  <span class="math-span">
   \( \beta - 1\)
  </span>
  (detto anche "complemento a
  <span class="math-span">
   \( 1\)
  </span>
  ") di un numero è ottenibile effettuando il not "bit a bit".
 </div>
</div>
<div class="myexample environment" id="example14">
 <h2 class="environment-title">
  Esempio -
  Complemento a
  <span class="math-span">
   \( 9\)
  </span>
  (
  <span class="math-span">
   \( \beta - 1\)
  </span>
  )
 </h2>
 <div class="environment-body">
  Considerando il numero
  <span class="math-span">
   \( 001234)_{10}\)
  </span>
  , si ha che il suo complemento a
  <span class="math-span">
   \( 9\)
  </span>
  (considerando che è di
  <span class="math-span">
   \( 6\)
  </span>
  cifre e che è in base
  <span class="math-span">
   \( 10\)
  </span>
  ) è dato da
  <span class="math-block">
   \[         (10^{6} - 1) - 1\,234 = 999\,999 - 1\,234 = 998\,765     \]
  </span>
 </div>
</div>
<div class="myexample environment" id="example15">
 <h2 class="environment-title">
  Esempio -
  Complemento a
  <span class="math-span">
   \( 1\)
  </span>
  (
  <span class="math-span">
   \( \beta - 1\)
  </span>
  )
 </h2>
 <div class="environment-body">
  Considerando il numero
  <span class="math-span">
   \( 1010001)_{2}\)
  </span>
  , si ha che il suo complemento a
  <span class="math-span">
   \( 1\)
  </span>
  (considerando che ha
  <span class="math-span">
   \( 7\)
  </span>
  cifre e che è in base
  <span class="math-span">
   \( 2\)
  </span>
  ) è dato da
  <span class="math-block">
   \[         (2^{6} - 1) - 1010001 = 111111 - 1010001 = 0101110     \]
  </span>
  che è anche calcolabile effettuando il not "bit a bit".
 </div>
</div>
<div class="definition environment" id="def3-7">
 <h2 class="environment-title">
  Definizione -
  Complemento a
  <span class="math-span">
   \( \beta\)
  </span>
 </h2>
 <div class="environment-body">
  Considerando un numero
  <span class="math-span">
   \( a\)
  </span>
  di
  <span class="math-span">
   \( n\)
  </span>
  cifre in base
  <span class="math-span">
   \( \beta\)
  </span>
  , si dice che il complemento a
  <span class="math-span">
   \( \beta\)
  </span>
  di tale numero è dato da
  <span class="math-block">
   \[         \beta^{n} - a      \]
  </span>
  Da come è possibile dedurre dalla formula, esso è anche calcolabile aggiungendo
  <span class="math-span">
   \( 1\)
  </span>
  al complemento
  <span class="math-span">
   \( \beta - 1\)
  </span>
  .
  <br/>
  Nell'aritmentica binaria, il complemento a
  <span class="math-span">
   \( \beta\)
  </span>
  (detto anche "complemento a
  <span class="math-span">
   \( 2\)
  </span>
  ") di un numero è ottenibile sia effettuando il not "bit a bit" del numero e poi sommandogli
  <span class="math-span">
   \( 1\)
  </span>
  (ovvero sommando
  <span class="math-span">
   \( 1\)
  </span>
  al complemento a
  <span class="math-span">
   \( 1\)
  </span>
  ), sia lasciando invariato il numero fino al primo
  <span class="math-span">
   \( 1\)
  </span>
  partendo da destra (esso incluso) e complementando i rimanenti.
 </div>
</div>
<div class="myexample environment" id="example16">
 <h2 class="environment-title">
  Esempio -
  Complemento a
  <span class="math-span">
   \( 2\)
  </span>
  (
  <span class="math-span">
   \( \beta\)
  </span>
  )
 </h2>
 <div class="environment-body">
  Considerando il numero
  <span class="math-span">
   \( 1010001)_{2}\)
  </span>
  , si ha che il suo complemento a
  <span class="math-span">
   \( 2\)
  </span>
  è dato da
  <span class="math-block">
   \[         NOT(1010001) + 1 = 0101110 + 1 = 0101111     \]
  </span>
 </div>
</div>
<div class="definition environment" id="def3-8">
 <h2 class="environment-title">
  Definizione -
  Sottrazione tra numeri unsigned con Full Adder
 </h2>
 <div class="environment-body">
  Considerando due numeri binari unsigned
  <span class="math-span">
   \( a\)
  </span>
  e
  <span class="math-span">
   \( b\)
  </span>
  con
  <span class="math-span">
   \( a \geq b\)
  </span>
  , è possibile calcolare la differenza
  <span class="math-span">
   \( (a - b)\)
  </span>
  utilizzando la rappresentazione in complemento a
  <span class="math-span">
   \( 2\)
  </span>
  per
  <span class="math-span">
   \( b\)
  </span>
  (in quanto, sostituendo
  <span class="math-span">
   \( b\)
  </span>
  con l'equivalente
  <span class="math-span">
   \( (2^{n} - b)\)
  </span>
  si ottiene il valore
  <span class="math-span">
   \( (a - b + 2^{n})\)
  </span>
  ).
  <br/>
  Per implementare la sottrazione utilizzando un Full Adder a
  <span class="math-span">
   \( n\)
  </span>
  bit è sufficiente complementare
  <span class="math-span">
   \( b\)
  </span>
  , impostare il bit
  <span class="math-span">
   \( c_{in} = 1\)
  </span>
  e considerare il
  <span class="math-span">
   \( c_{out}\)
  </span>
  come un flag di validità: nel caso sia
  <span class="math-span">
   \( 0\)
  </span>
  il risultato non risulta valido.
  <div class="image-environment">
   <div class="image-wrapper spaced-75">
    <img alt="Immagine" src="../resources/sottrazione-unsigned-full-adder.png"/>
   </div>
  </div>
  Di seguito lo schema logico per un generico adder/subctracter
  <div class="image-environment">
   <div class="image-wrapper spaced-75">
    <img alt="Immagine" src="../resources/full-adder-unsigned-generico.png"/>
   </div>
  </div>
  L'ingresso "
  <span class="math-span">
   \( S / D'\)
  </span>
  " assumerà il valore
  <span class="math-span">
   \( 0\)
  </span>
  nel caso si voglia che il circuito esegua un'addizione,
  <span class="math-span">
   \( 1\)
  </span>
  nel caso si voglia calcolare una sottrazione.     L'uscita
  <span class="math-span">
   \( CF\)
  </span>
  indica la validità dell'operazione (
  <span class="math-span">
   \( 1\)
  </span>
  se è valida,
  <span class="math-span">
   \( 0\)
  </span>
  se non lo è).
 </div>
</div>
<div class="definition environment" id="def3-9">
 <h2 class="environment-title">
  Definizione -
  Rappresentazione in base
  <span class="math-span">
   \( 2\)
  </span>
  di numeri con segno
 </h2>
 <div class="environment-body">
  È possibile rappresentare i numeri signed in diversi modi:
  <ul class="list-container">
   <li class="list-item">
    rappresentazione modulo e segno, ovvero si dedica un bit (il più significativo) al segno e i restanti al valore assoluto. Con
    <span class="math-span">
     \( n\)
    </span>
    bit si rappresenta quindi l'intervallo
    <span class="math-block">
     \[             [ -(2^{n - 1} - 1), 2^{n - 1} - 1 ]           \]
    </span>
    Si rappresenta quindi un intervallo simmetrico con due rappresentazioni per lo
    <span class="math-span">
     \( 0\)
    </span>
    (
    <span class="math-span">
     \( -0\)
    </span>
    e
    <span class="math-span">
     \( +0\)
    </span>
    ).
   </li>
   <li class="list-item">
    rappresentazione in complemento a
    <span class="math-span">
     \( 2\)
    </span>
    , ovvero si rappresentano i numeri negativi in complemento a
    <span class="math-span">
     \( 2\)
    </span>
    (dedicando implicitamente un bit al segno, ovvero il bit più significativo ha valore
    <span class="math-span">
     \( -2^{n}\)
    </span>
    ). Si ha quindi con un intervallo di
    <span class="math-span">
     \( n\)
    </span>
    bit si può rappresentare il seguente intervallo:
    <span class="math-block">
     \[             [ -2^{n - 1}, 2^{n - 1} - 1]         \]
    </span>
   </li>
  </ul>
  Tra queste, la rappresentazione più usata è quella in complemento a
  <span class="math-span">
   \( 2\)
  </span>
  .
  <div class="mynote environment">
   <h3 class="environment-title">
    Osservazioni personali -
    Why "Complemento a
    <span class="math-span">
     \( 2\)
    </span>
    "?
   </h3>
   <div class="environment-body">
    Le motivazioni per cui si è scelta la rappresentazione in complemento a
    <span class="math-span">
     \( 2\)
    </span>
    si deve all'efficienza dei calcoli (che risulta essere molto più complesso nella rappresentazione modulo e segno).
   </div>
  </div>
 </div>
</div>
<div class="definition environment" id="def3-10">
 <h2 class="environment-title">
  Definizione -
  Operazioni tra numeri signed utilizzando Full Adder
 </h2>
 <div class="environment-body">
  Per gestire le operazioni con i numeri con segno, è necessario gestire meglio l'overflow: si ha infatti che nella rappresentazione in complemento a
  <span class="math-span">
   \( 2\)
  </span>
  esso non dipende dal solo bit di "carry out", bensì dipende dal fatto di segnare due numeri dello stesso segno e ottenerne uno con segno diverso: ciò equivale a verificare che
  <span class="math-block">
   \[         overflow \ = \ a_{n - 1} == b_{n - 1} \quad and \quad a_{n - 1} \neq s_{n - 1}        \]
  </span>
  Ciò equivale a verificare che
  <span class="math-block">
   \[         overflow \ = \ c_{out} \neq r_{n - 1}         \]
  </span>
  dove
  <span class="math-span">
   \( r_{n - 1}\)
  </span>
  è il carry out del
  <span class="math-span">
   \( n - 1\)
  </span>
  -esimo adder, in quanto si ha che se
  <span class="math-block">
   \[         a_{n - 1} = b_{n - 1}       \]
  </span>
  (ovvero se hanno lo stesso segno) si ha che
  <span class="math-block">
   \[         s_{r - 1} = c_{out} (s_{r})     \]
  </span>
  (in quanto se si sommano due bit uguali ad un terzo bit, il risultato sarà il valore di tale bit) e si ha che
  <span class="math-block">
   \[         c_{out} = a_{n - 1}       \]
  </span>
  (in quanto esso sarà
  <span class="math-span">
   \( 1\)
  </span>
  solo se sia
  <span class="math-span">
   \( a_{n - 1}\)
  </span>
  e
  <span class="math-span">
   \( b_{n - 1}\)
  </span>
  sono
  <span class="math-span">
   \( 1\)
  </span>
  ).
  <br/>
  Detto ciò, per aggiungere il flag di overflow è sufficiente "mettere" in xor il carry out della rete (
  <span class="math-span">
   \( c_{out}\)
  </span>
  , ovvero il
  <span class="math-span">
   \( r_{n}\)
  </span>
  ) con quello del penultimo (
  <span class="math-span">
   \( r_{n - 1}\)
  </span>
  ).
 </div>
</div>
<div class="definition environment" id="def3-11">
 <h2 class="environment-title">
  Definizione -
  Limiti del
  <span class="math-span">
   \( n\)
  </span>
  -bit Adder (ripple-carry Adder)
 </h2>
 <div class="environment-body">
  Tale realizzazione di
  <span class="math-span">
   \( n\)
  </span>
  -bit Adder (detta anche "ripple-carry Adder")  è molto lenta: ciò è dovuto al fatto che la disposizione in serie degli adder rende necessario che ogni Adder debba "aspettare" che il precedente abbia terminato in quanto deve conoscere il
  <span class="math-span">
   \( c_{out}\)
  </span>
  del precedente.
  <br/>
  Ipotizzando quindi che ogni Adder impieghi
  <span class="math-span">
   \( 2 \tau_{p}\)
  </span>
  per calcolare il riporto, si ha che per il calcolo della somma tra numeri di
  <span class="math-span">
   \( 64\)
  </span>
  bit si avrà un ritardo (ovvero un risultato aggiornato) di
  <span class="math-span">
   \( 128 \tau_{p}\)
  </span>
  .
 </div>
</div>
<div class="definition environment" id="def3-12">
 <h2 class="environment-title">
  Definizione -
  Carry lookahead Adder
 </h2>
 <div class="environment-body">
  Con la miniaturizzazione dei componenti, è stato possibile realizzare un altro Adder composto da più gate ma che non pone in cascata diverse reti.
  <br/>
  Tale realizzazione si basa sul principio che è possibile esprimere ogni bit risultato in funzione dei bit di ingresso. Si ha infatti che:
  <ul class="list-container">
   <li class="list-item">
    l'
    <span class="math-span">
     \( i\)
    </span>
    -esimo bit di somma
    <span class="math-span">
     \( s_{i}\)
    </span>
    è calcolato come il seguente XOR
    <span class="math-block">
     \[             s_{i} = a_{i} \oplus b_{i} \oplus r_{i}             \]
    </span>
    ovvero la somma logica dei segnali e dell'
    <span class="math-span">
     \( i\)
    </span>
    -esimo riporto;
   </li>
   <li class="list-item">
    l'
    <span class="math-span">
     \( (i + 1)\)
    </span>
    -esimo bit di riporto
    <span class="math-span">
     \( r_{i + 1}\)
    </span>
    può essere calcolato come
    <span class="math-block">
     \[             r_{i + 1} = (r_{i} \cdot (a_{i} \oplus b_{i})) + (a_{i} \cdot b_{i})           \]
    </span>
    Dato inoltre che anche
    <span class="math-span">
     \( r_{i}\)
    </span>
    può essere espresso espresso in funzione dei segnali al bit
    <span class="math-span">
     \( (i - 1)\)
    </span>
    . In questo modo si ha che il riporto
    <span class="math-span">
     \( r_{i + 1}\)
    </span>
    sarà dato dalla seguente espressione
    <span class="math-block">
     \[             r_{i + i} = \left( r_{0} \cdot \prod_{j = 0}^{i} \left( a_{j} \oplus b_{j} \right)  \right) + \left( \sum_{j = 0}^{i} \left( \ a_{j} \cdot b_{j} \right) \cdot \prod_{k = j + 1}^{i} \left( a_{k} \cdot b_{k} \right)  \right)         \]
    </span>
    Si ottiene in questo modo che ogni riporto è disponibile dopo
    <span class="math-span">
     \( 3 \tau_{p}\)
    </span>
    , indipendentemente dal numero di bit che si sommano.
   </li>
  </ul>
 </div>
</div>
<div class="definition environment" id="def3-13">
 <h2 class="environment-title">
  Definizione -
  Arithmetic Logic Unit (ALU)
 </h2>
 <div class="environment-body">
  L'ALU ("Arithmetic Logic Unit") è una macchina combinatoria in grado di eseguire operazioni aritmetiche e logiche su due operandi.      Uno specifico segnale in ingresso, detto op-code, indica quale di queste operazioni eseguire. Oltre al risultato dell'operazione, forniscono in uscita anche una serie di flag che indicano il verificarsi di specifiche condizioni.
  <br/>
  Tale componente è fondamentalmente costruito sulla base di un Full Adder adeguatamente modificato per eseguire diverse operazioni aritmetiche e diverse operazioni logiche.
  <br/>
  Tra i flag aggiunti si ricordano:
  <ul class="list-container">
   <li class="list-item">
    lo Zero Flag, che segnala se il risultato è
    <span class="math-span">
     \( 0\)
    </span>
    ;
   </li>
   <li class="list-item">
    il Sign Flag, che segnala se il risultato è negativo (considerando sempre la rappresentazione in complemento a
    <span class="math-span">
     \( 2\)
    </span>
    ).
   </li>
  </ul>
 </div>
</div>
            </article>
            <nav class="buttons-container content-width">
                <a class="navigation-button previous" href="index.html" rel="nofollow"><span>ALU</span></a>
                <a class="navigation-button next" href="../reti-sequenziali-asincrone/index.html" rel="nofollow"><span>Reti sequenziali asincrone</span></a>
            </nav>
        </section>
        <div class="scroll-to-bottom-button" onclick="scroll_to_bottom()">
            <span class="material-symbols-outlined">
                keyboard_double_arrow_down
            </span>
        </div>
        <footer class="footer-wrapper">
            <div class="copyright-wrapper">
                <span> &copy; Copyright 2023</span> /
                <span>made by lorenzoarlo</span>
            </div>
            /
            <div class="privacy-wrapper">
                <span><a href="https://lorenzoarlo.github.io/privacy-and-cookies/" rel="nofollow">Pannello preferenze cookie</a></span> /
                <span><a href="https://lorenzoarlo.github.io/privacy-and-cookies/privacy-policy.html" rel="nofollow" target="_blank" >Privacy Policy</a></span>
            </div>
        </footer>
    </div>
</body>
</html>